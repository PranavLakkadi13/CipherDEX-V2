{
  "language": "Solidity",
  "sources": {
    "@fhenixprotocol/contracts/FHE.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\n// solhint-disable one-contract-per-file\n\npragma solidity >=0.8.19 <0.9.0;\n\nimport {Precompiles, FheOps} from \"./FheOS.sol\";\n\ntype ebool is uint256;\ntype euint8 is uint256;\ntype euint16 is uint256;\ntype euint32 is uint256;\n\nstruct inEbool {\n    bytes data;\n}\nstruct inEuint8 {\n    bytes data;\n}\nstruct inEuint16 {\n    bytes data;\n}\nstruct inEuint32 {\n    bytes data;\n}\n\nlibrary Common {\n    // Values used to communicate types to the runtime.\n    uint8 internal constant EBOOL_TFHE_GO = 0;\n    uint8 internal constant EUINT8_TFHE_GO = 0;\n    uint8 internal constant EUINT16_TFHE_GO = 1;\n    uint8 internal constant EUINT32_TFHE_GO = 2;\n\n    function bigIntToBool(uint256 i) internal pure returns (bool) {\n        return (i > 0);\n    }\n\n    function bigIntToUint8(uint256 i) internal pure returns (uint8) {\n        return uint8(i);\n    }\n\n    function bigIntToUint16(uint256 i) internal pure returns (uint16) {\n        return uint16(i);\n    }\n\n    function bigIntToUint32(uint256 i) internal pure returns (uint32) {\n        return uint32(i);\n    }\n\n    function bigIntToUint64(uint256 i) internal pure returns (uint64) {\n        return uint64(i);\n    }\n\n    function bigIntToUint128(uint256 i) internal pure returns (uint128) {\n        return uint128(i);\n    }\n\n    function bigIntToUint256(uint256 i) internal pure returns (uint256) {\n        return i;\n    }\n    \n    function toBytes(uint256 x) internal pure returns (bytes memory b) {\n        b = new bytes(32);\n        assembly { mstore(add(b, 32), x) }\n    }\n    \n}\n\nlibrary Impl {\n    function sealoutput(uint8 utype, uint256 ciphertext, bytes32 publicKey) internal pure returns (bytes memory reencrypted) {\n        // Call the sealoutput precompile.\n        reencrypted = FheOps(Precompiles.Fheos).sealOutput(utype, Common.toBytes(ciphertext), bytes.concat(publicKey));\n\n        return reencrypted;\n    }\n\n    function verify(bytes memory _ciphertextBytes, uint8 _toType) internal pure returns (uint256 result) {\n        bytes memory output;\n\n        // Call the verify precompile.\n        output = FheOps(Precompiles.Fheos).verify(_toType, _ciphertextBytes);\n        result = getValue(output);\n    }\n\n    function cast(uint8 utype, uint256 ciphertext, uint8 toType) internal pure returns (uint256 result) {\n        bytes memory output;\n\n        // Call the cast precompile.\n        output = FheOps(Precompiles.Fheos).cast(utype, Common.toBytes(ciphertext), toType);\n        result = getValue(output);\n    }\n\n    function getValue(bytes memory a) internal pure returns (uint256 value) {\n        assembly {\n            value := mload(add(a, 0x20))\n        }\n    }\n\n    function trivialEncrypt(uint256 value, uint8 toType) internal pure returns (uint256 result) {\n        bytes memory output;\n\n        // Call the trivialEncrypt precompile.\n        output = FheOps(Precompiles.Fheos).trivialEncrypt(Common.toBytes(value), toType);\n\n        result = getValue(output);\n    }\n\n    function select(uint8 utype, uint256 control, uint256 ifTrue, uint256 ifFalse) internal pure returns (uint256 result) {\n        bytes memory output;\n\n        // Call the trivialEncrypt precompile.\n        output = FheOps(Precompiles.Fheos).select(utype, Common.toBytes(control), Common.toBytes(ifTrue), Common.toBytes(ifFalse));\n\n        result = getValue(output);\n    }\n}\n\nlibrary FHE {\n    euint8 public constant NIL8 = euint8.wrap(0);\n    euint16 public constant NIL16 = euint16.wrap(0);\n    euint32 public constant NIL32 = euint32.wrap(0);\n\n    // Return true if the encrypted integer is initialized and false otherwise.\n    function isInitialized(ebool v) internal pure returns (bool) {\n        return ebool.unwrap(v) != 0;\n    }\n\n    // Return true if the encrypted integer is initialized and false otherwise.\n    function isInitialized(euint8 v) internal pure returns (bool) {\n        return euint8.unwrap(v) != 0;\n    }\n\n    // Return true if the encrypted integer is initialized and false otherwise.\n    function isInitialized(euint16 v) internal pure returns (bool) {\n        return euint16.unwrap(v) != 0;\n    }\n\n    // Return true if the encrypted integer is initialized and false otherwise.\n    function isInitialized(euint32 v) internal pure returns (bool) {\n        return euint32.unwrap(v) != 0;\n    }\n\n    function getValue(bytes memory a) private pure returns (uint256 value) {\n        assembly {\n            value := mload(add(a, 0x20))\n        }\n    }\n    \n    function mathHelper(\n        uint8 utype,\n        uint256 lhs,\n        uint256 rhs,\n        function(uint8, bytes memory, bytes memory) external pure returns (bytes memory) impl\n    ) internal pure returns (uint256 result) {\n        bytes memory output;\n        output = impl(utype, Common.toBytes(lhs), Common.toBytes(rhs));\n        result = getValue(output);\n    }\n    \n    /// @notice This functions performs the add operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function add(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint8(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint8(0);\n        }\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).add);\n        return euint8.wrap(result);\n    }\n    /// @notice This functions performs the add operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function add(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint16(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint16(0);\n        }\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).add);\n        return euint16.wrap(result);\n    }\n    /// @notice This functions performs the add operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function add(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint32(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint32(0);\n        }\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).add);\n        return euint32.wrap(result);\n    }\n    /// @notice performs the sealoutput function on a ebool ciphertext. This operation returns the plaintext value, sealed for the public key provided \n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param value Ciphertext to decrypt and seal\n    /// @param publicKey Public Key that will receive the sealed plaintext\n    /// @return Plaintext input, sealed for the owner of `publicKey`\n    function sealoutput(ebool value, bytes32 publicKey) internal pure returns (bytes memory) {\n        if (!isInitialized(value)) {\n            value = asEbool(0);\n        }\n        uint256 unwrapped = ebool.unwrap(value);\n\n        return Impl.sealoutput(Common.EBOOL_TFHE_GO, unwrapped, publicKey);\n    }\n    /// @notice performs the sealoutput function on a euint8 ciphertext. This operation returns the plaintext value, sealed for the public key provided \n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param value Ciphertext to decrypt and seal\n    /// @param publicKey Public Key that will receive the sealed plaintext\n    /// @return Plaintext input, sealed for the owner of `publicKey`\n    function sealoutput(euint8 value, bytes32 publicKey) internal pure returns (bytes memory) {\n        if (!isInitialized(value)) {\n            value = asEuint8(0);\n        }\n        uint256 unwrapped = euint8.unwrap(value);\n\n        return Impl.sealoutput(Common.EUINT8_TFHE_GO, unwrapped, publicKey);\n    }\n    /// @notice performs the sealoutput function on a euint16 ciphertext. This operation returns the plaintext value, sealed for the public key provided \n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param value Ciphertext to decrypt and seal\n    /// @param publicKey Public Key that will receive the sealed plaintext\n    /// @return Plaintext input, sealed for the owner of `publicKey`\n    function sealoutput(euint16 value, bytes32 publicKey) internal pure returns (bytes memory) {\n        if (!isInitialized(value)) {\n            value = asEuint16(0);\n        }\n        uint256 unwrapped = euint16.unwrap(value);\n\n        return Impl.sealoutput(Common.EUINT16_TFHE_GO, unwrapped, publicKey);\n    }\n    /// @notice performs the sealoutput function on a euint32 ciphertext. This operation returns the plaintext value, sealed for the public key provided \n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param value Ciphertext to decrypt and seal\n    /// @param publicKey Public Key that will receive the sealed plaintext\n    /// @return Plaintext input, sealed for the owner of `publicKey`\n    function sealoutput(euint32 value, bytes32 publicKey) internal pure returns (bytes memory) {\n        if (!isInitialized(value)) {\n            value = asEuint32(0);\n        }\n        uint256 unwrapped = euint32.unwrap(value);\n\n        return Impl.sealoutput(Common.EUINT32_TFHE_GO, unwrapped, publicKey);\n    }\n    /// @notice Performs the decrypt operation on a ciphertext\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param input1 the input ciphertext\n    function decrypt(ebool input1) internal pure returns (bool) {\n        if (!isInitialized(input1)) {\n            input1 = asEbool(0);\n        }\n        uint256 unwrappedInput1 = ebool.unwrap(input1);\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\n        uint256 result = FheOps(Precompiles.Fheos).decrypt(Common.EBOOL_TFHE_GO, inputAsBytes);\n        return Common.bigIntToBool(result);\n    }\n    /// @notice Performs the decrypt operation on a ciphertext\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param input1 the input ciphertext\n    function decrypt(euint8 input1) internal pure returns (uint8) {\n        if (!isInitialized(input1)) {\n            input1 = asEuint8(0);\n        }\n        uint256 unwrappedInput1 = euint8.unwrap(input1);\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\n        uint256 result = FheOps(Precompiles.Fheos).decrypt(Common.EUINT8_TFHE_GO, inputAsBytes);\n        return Common.bigIntToUint8(result);\n    }\n    /// @notice Performs the decrypt operation on a ciphertext\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param input1 the input ciphertext\n    function decrypt(euint16 input1) internal pure returns (uint16) {\n        if (!isInitialized(input1)) {\n            input1 = asEuint16(0);\n        }\n        uint256 unwrappedInput1 = euint16.unwrap(input1);\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\n        uint256 result = FheOps(Precompiles.Fheos).decrypt(Common.EUINT16_TFHE_GO, inputAsBytes);\n        return Common.bigIntToUint16(result);\n    }\n    /// @notice Performs the decrypt operation on a ciphertext\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param input1 the input ciphertext\n    function decrypt(euint32 input1) internal pure returns (uint32) {\n        if (!isInitialized(input1)) {\n            input1 = asEuint32(0);\n        }\n        uint256 unwrappedInput1 = euint32.unwrap(input1);\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\n        uint256 result = FheOps(Precompiles.Fheos).decrypt(Common.EUINT32_TFHE_GO, inputAsBytes);\n        return Common.bigIntToUint32(result);\n    }\n    /// @notice This functions performs the lte operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function lte(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint8(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint8(0);\n        }\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).lte);\n        return ebool.wrap(result);\n    }\n    /// @notice This functions performs the lte operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function lte(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint16(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint16(0);\n        }\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).lte);\n        return ebool.wrap(result);\n    }\n    /// @notice This functions performs the lte operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function lte(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint32(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint32(0);\n        }\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).lte);\n        return ebool.wrap(result);\n    }\n    /// @notice This functions performs the sub operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function sub(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint8(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint8(0);\n        }\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).sub);\n        return euint8.wrap(result);\n    }\n    /// @notice This functions performs the sub operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function sub(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint16(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint16(0);\n        }\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).sub);\n        return euint16.wrap(result);\n    }\n    /// @notice This functions performs the sub operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function sub(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint32(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint32(0);\n        }\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).sub);\n        return euint32.wrap(result);\n    }\n    /// @notice This functions performs the mul operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function mul(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint8(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint8(0);\n        }\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).mul);\n        return euint8.wrap(result);\n    }\n    /// @notice This functions performs the mul operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function mul(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint16(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint16(0);\n        }\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).mul);\n        return euint16.wrap(result);\n    }\n    /// @notice This functions performs the mul operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function mul(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint32(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint32(0);\n        }\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).mul);\n        return euint32.wrap(result);\n    }\n    /// @notice This functions performs the lt operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function lt(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint8(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint8(0);\n        }\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).lt);\n        return ebool.wrap(result);\n    }\n    /// @notice This functions performs the lt operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function lt(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint16(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint16(0);\n        }\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).lt);\n        return ebool.wrap(result);\n    }\n    /// @notice This functions performs the lt operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function lt(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint32(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint32(0);\n        }\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).lt);\n        return ebool.wrap(result);\n    }\n\n    function select(ebool input1, ebool input2, ebool input3) internal pure returns (ebool) {\n        if (!isInitialized(input1)) {\n            input1 = asEbool(0);\n        }\n        if (!isInitialized(input2)) {\n            input2 = asEbool(0);\n        }\n        if (!isInitialized(input3)) {\n            input3 = asEbool(0);\n        }\n\n        uint256 unwrappedInput1 = ebool.unwrap(input1);\n        uint256 unwrappedInput2 = ebool.unwrap(input2);\n        uint256 unwrappedInput3 = ebool.unwrap(input3);\n\n        uint256 result = Impl.select(Common.EBOOL_TFHE_GO, unwrappedInput1, unwrappedInput2, unwrappedInput3);\n        return ebool.wrap(result);\n    }\n\n    function select(ebool input1, euint8 input2, euint8 input3) internal pure returns (euint8) {\n        if (!isInitialized(input1)) {\n            input1 = asEbool(0);\n        }\n        if (!isInitialized(input2)) {\n            input2 = asEuint8(0);\n        }\n        if (!isInitialized(input3)) {\n            input3 = asEuint8(0);\n        }\n\n        uint256 unwrappedInput1 = ebool.unwrap(input1);\n        uint256 unwrappedInput2 = euint8.unwrap(input2);\n        uint256 unwrappedInput3 = euint8.unwrap(input3);\n\n        uint256 result = Impl.select(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, unwrappedInput3);\n        return euint8.wrap(result);\n    }\n\n    function select(ebool input1, euint16 input2, euint16 input3) internal pure returns (euint16) {\n        if (!isInitialized(input1)) {\n            input1 = asEbool(0);\n        }\n        if (!isInitialized(input2)) {\n            input2 = asEuint16(0);\n        }\n        if (!isInitialized(input3)) {\n            input3 = asEuint16(0);\n        }\n\n        uint256 unwrappedInput1 = ebool.unwrap(input1);\n        uint256 unwrappedInput2 = euint16.unwrap(input2);\n        uint256 unwrappedInput3 = euint16.unwrap(input3);\n\n        uint256 result = Impl.select(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, unwrappedInput3);\n        return euint16.wrap(result);\n    }\n\n    function select(ebool input1, euint32 input2, euint32 input3) internal pure returns (euint32) {\n        if (!isInitialized(input1)) {\n            input1 = asEbool(0);\n        }\n        if (!isInitialized(input2)) {\n            input2 = asEuint32(0);\n        }\n        if (!isInitialized(input3)) {\n            input3 = asEuint32(0);\n        }\n\n        uint256 unwrappedInput1 = ebool.unwrap(input1);\n        uint256 unwrappedInput2 = euint32.unwrap(input2);\n        uint256 unwrappedInput3 = euint32.unwrap(input3);\n\n        uint256 result = Impl.select(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, unwrappedInput3);\n        return euint32.wrap(result);\n    }\n    /// @notice Performs the req operation on a ciphertext\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param input1 the input ciphertext\n    function req(ebool input1) internal pure  {\n        if (!isInitialized(input1)) {\n            input1 = asEbool(0);\n        }\n        uint256 unwrappedInput1 = ebool.unwrap(input1);\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\n        FheOps(Precompiles.Fheos).req(Common.EBOOL_TFHE_GO, inputAsBytes);\n    }\n    /// @notice Performs the req operation on a ciphertext\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param input1 the input ciphertext\n    function req(euint8 input1) internal pure  {\n        if (!isInitialized(input1)) {\n            input1 = asEuint8(0);\n        }\n        uint256 unwrappedInput1 = euint8.unwrap(input1);\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\n        FheOps(Precompiles.Fheos).req(Common.EUINT8_TFHE_GO, inputAsBytes);\n    }\n    /// @notice Performs the req operation on a ciphertext\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param input1 the input ciphertext\n    function req(euint16 input1) internal pure  {\n        if (!isInitialized(input1)) {\n            input1 = asEuint16(0);\n        }\n        uint256 unwrappedInput1 = euint16.unwrap(input1);\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\n        FheOps(Precompiles.Fheos).req(Common.EUINT16_TFHE_GO, inputAsBytes);\n    }\n    /// @notice Performs the req operation on a ciphertext\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param input1 the input ciphertext\n    function req(euint32 input1) internal pure  {\n        if (!isInitialized(input1)) {\n            input1 = asEuint32(0);\n        }\n        uint256 unwrappedInput1 = euint32.unwrap(input1);\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\n        FheOps(Precompiles.Fheos).req(Common.EUINT32_TFHE_GO, inputAsBytes);\n    }\n    /// @notice This functions performs the div operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function div(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint8(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint8(0);\n        }\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).div);\n        return euint8.wrap(result);\n    }\n    /// @notice This functions performs the div operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function div(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint16(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint16(0);\n        }\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).div);\n        return euint16.wrap(result);\n    }\n    /// @notice This functions performs the div operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function div(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint32(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint32(0);\n        }\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).div);\n        return euint32.wrap(result);\n    }\n    /// @notice This functions performs the gt operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function gt(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint8(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint8(0);\n        }\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).gt);\n        return ebool.wrap(result);\n    }\n    /// @notice This functions performs the gt operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function gt(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint16(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint16(0);\n        }\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).gt);\n        return ebool.wrap(result);\n    }\n    /// @notice This functions performs the gt operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function gt(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint32(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint32(0);\n        }\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).gt);\n        return ebool.wrap(result);\n    }\n    /// @notice This functions performs the gte operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function gte(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint8(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint8(0);\n        }\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).gte);\n        return ebool.wrap(result);\n    }\n    /// @notice This functions performs the gte operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function gte(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint16(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint16(0);\n        }\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).gte);\n        return ebool.wrap(result);\n    }\n    /// @notice This functions performs the gte operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function gte(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint32(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint32(0);\n        }\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).gte);\n        return ebool.wrap(result);\n    }\n    /// @notice This functions performs the rem operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function rem(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint8(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint8(0);\n        }\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).rem);\n        return euint8.wrap(result);\n    }\n    /// @notice This functions performs the rem operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function rem(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint16(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint16(0);\n        }\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).rem);\n        return euint16.wrap(result);\n    }\n    /// @notice This functions performs the rem operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function rem(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint32(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint32(0);\n        }\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).rem);\n        return euint32.wrap(result);\n    }\n    /// @notice This functions performs the and operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function and(ebool lhs, ebool rhs) internal pure returns (ebool) {\n        if (!isInitialized(lhs)) {\n            lhs = asEbool(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEbool(0);\n        }\n        uint256 unwrappedInput1 = ebool.unwrap(lhs);\n        uint256 unwrappedInput2 = ebool.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EBOOL_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).and);\n        return ebool.wrap(result);\n    }\n    /// @notice This functions performs the and operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function and(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint8(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint8(0);\n        }\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).and);\n        return euint8.wrap(result);\n    }\n    /// @notice This functions performs the and operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function and(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint16(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint16(0);\n        }\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).and);\n        return euint16.wrap(result);\n    }\n    /// @notice This functions performs the and operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function and(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint32(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint32(0);\n        }\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).and);\n        return euint32.wrap(result);\n    }\n    /// @notice This functions performs the or operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function or(ebool lhs, ebool rhs) internal pure returns (ebool) {\n        if (!isInitialized(lhs)) {\n            lhs = asEbool(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEbool(0);\n        }\n        uint256 unwrappedInput1 = ebool.unwrap(lhs);\n        uint256 unwrappedInput2 = ebool.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EBOOL_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).or);\n        return ebool.wrap(result);\n    }\n    /// @notice This functions performs the or operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function or(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint8(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint8(0);\n        }\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).or);\n        return euint8.wrap(result);\n    }\n    /// @notice This functions performs the or operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function or(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint16(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint16(0);\n        }\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).or);\n        return euint16.wrap(result);\n    }\n    /// @notice This functions performs the or operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function or(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint32(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint32(0);\n        }\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).or);\n        return euint32.wrap(result);\n    }\n    /// @notice This functions performs the xor operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function xor(ebool lhs, ebool rhs) internal pure returns (ebool) {\n        if (!isInitialized(lhs)) {\n            lhs = asEbool(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEbool(0);\n        }\n        uint256 unwrappedInput1 = ebool.unwrap(lhs);\n        uint256 unwrappedInput2 = ebool.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EBOOL_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).xor);\n        return ebool.wrap(result);\n    }\n    /// @notice This functions performs the xor operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function xor(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint8(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint8(0);\n        }\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).xor);\n        return euint8.wrap(result);\n    }\n    /// @notice This functions performs the xor operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function xor(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint16(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint16(0);\n        }\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).xor);\n        return euint16.wrap(result);\n    }\n    /// @notice This functions performs the xor operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function xor(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint32(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint32(0);\n        }\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).xor);\n        return euint32.wrap(result);\n    }\n    /// @notice This functions performs the eq operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function eq(ebool lhs, ebool rhs) internal pure returns (ebool) {\n        if (!isInitialized(lhs)) {\n            lhs = asEbool(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEbool(0);\n        }\n        uint256 unwrappedInput1 = ebool.unwrap(lhs);\n        uint256 unwrappedInput2 = ebool.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EBOOL_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).eq);\n        return ebool.wrap(result);\n    }\n    /// @notice This functions performs the eq operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function eq(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint8(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint8(0);\n        }\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).eq);\n        return ebool.wrap(result);\n    }\n    /// @notice This functions performs the eq operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function eq(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint16(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint16(0);\n        }\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).eq);\n        return ebool.wrap(result);\n    }\n    /// @notice This functions performs the eq operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function eq(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint32(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint32(0);\n        }\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).eq);\n        return ebool.wrap(result);\n    }\n    /// @notice This functions performs the ne operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function ne(ebool lhs, ebool rhs) internal pure returns (ebool) {\n        if (!isInitialized(lhs)) {\n            lhs = asEbool(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEbool(0);\n        }\n        uint256 unwrappedInput1 = ebool.unwrap(lhs);\n        uint256 unwrappedInput2 = ebool.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EBOOL_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).ne);\n        return ebool.wrap(result);\n    }\n    /// @notice This functions performs the ne operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function ne(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint8(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint8(0);\n        }\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).ne);\n        return ebool.wrap(result);\n    }\n    /// @notice This functions performs the ne operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function ne(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint16(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint16(0);\n        }\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).ne);\n        return ebool.wrap(result);\n    }\n    /// @notice This functions performs the ne operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function ne(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint32(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint32(0);\n        }\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).ne);\n        return ebool.wrap(result);\n    }\n    /// @notice This functions performs the min operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function min(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint8(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint8(0);\n        }\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).min);\n        return euint8.wrap(result);\n    }\n    /// @notice This functions performs the min operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function min(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint16(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint16(0);\n        }\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).min);\n        return euint16.wrap(result);\n    }\n    /// @notice This functions performs the min operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function min(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint32(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint32(0);\n        }\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).min);\n        return euint32.wrap(result);\n    }\n    /// @notice This functions performs the max operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function max(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint8(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint8(0);\n        }\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).max);\n        return euint8.wrap(result);\n    }\n    /// @notice This functions performs the max operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function max(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint16(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint16(0);\n        }\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).max);\n        return euint16.wrap(result);\n    }\n    /// @notice This functions performs the max operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function max(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint32(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint32(0);\n        }\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).max);\n        return euint32.wrap(result);\n    }\n    /// @notice This functions performs the shl operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function shl(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint8(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint8(0);\n        }\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).shl);\n        return euint8.wrap(result);\n    }\n    /// @notice This functions performs the shl operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function shl(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint16(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint16(0);\n        }\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).shl);\n        return euint16.wrap(result);\n    }\n    /// @notice This functions performs the shl operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function shl(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint32(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint32(0);\n        }\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).shl);\n        return euint32.wrap(result);\n    }\n    /// @notice This functions performs the shr operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function shr(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint8(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint8(0);\n        }\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).shr);\n        return euint8.wrap(result);\n    }\n    /// @notice This functions performs the shr operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function shr(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint16(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint16(0);\n        }\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).shr);\n        return euint16.wrap(result);\n    }\n    /// @notice This functions performs the shr operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function shr(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint32(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint32(0);\n        }\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).shr);\n        return euint32.wrap(result);\n    }\n\n    /// @notice Performs the \"not\" for the ebool type\n    /// @dev Implemented by a workaround due to ebool being a euint8 type behind the scenes, therefore xor is needed to assure that not(true) = false and vise-versa\n    /// @param value input ebool ciphertext\n    /// @return Result of the not operation on `value` \n    function not(ebool value) internal pure returns (ebool) {\n        return xor(value, asEbool(true));\n    }\n    /// @notice Performs the not operation on a ciphertext\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param input1 the input ciphertext\n    function not(euint8 input1) internal pure returns (euint8) {\n        if (!isInitialized(input1)) {\n            input1 = asEuint8(0);\n        }\n        uint256 unwrappedInput1 = euint8.unwrap(input1);\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\n        bytes memory b = FheOps(Precompiles.Fheos).not(Common.EUINT8_TFHE_GO, inputAsBytes);\n        uint256 result = Impl.getValue(b);\n        return euint8.wrap(result);\n    }\n    /// @notice Performs the not operation on a ciphertext\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param input1 the input ciphertext\n    function not(euint16 input1) internal pure returns (euint16) {\n        if (!isInitialized(input1)) {\n            input1 = asEuint16(0);\n        }\n        uint256 unwrappedInput1 = euint16.unwrap(input1);\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\n        bytes memory b = FheOps(Precompiles.Fheos).not(Common.EUINT16_TFHE_GO, inputAsBytes);\n        uint256 result = Impl.getValue(b);\n        return euint16.wrap(result);\n    }\n    /// @notice Performs the not operation on a ciphertext\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param input1 the input ciphertext\n    function not(euint32 input1) internal pure returns (euint32) {\n        if (!isInitialized(input1)) {\n            input1 = asEuint32(0);\n        }\n        uint256 unwrappedInput1 = euint32.unwrap(input1);\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\n        bytes memory b = FheOps(Precompiles.Fheos).not(Common.EUINT32_TFHE_GO, inputAsBytes);\n        uint256 result = Impl.getValue(b);\n        return euint32.wrap(result);\n    }\n\n    // ********** TYPE CASTING ************* //\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an ebool\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\n    /// @return a ciphertext representation of the input\n    function asEbool(inEbool memory value) internal pure returns (ebool) {\n        return FHE.asEbool(value.data);\n    }\n    /// @notice Converts a ebool to an euint8\n    function asEuint8(ebool value) internal pure returns (euint8) {\n        return euint8.wrap(Impl.cast(Common.EBOOL_TFHE_GO, ebool.unwrap(value), Common.EUINT8_TFHE_GO));\n    }\n    /// @notice Converts a ebool to an euint16\n    function asEuint16(ebool value) internal pure returns (euint16) {\n        return euint16.wrap(Impl.cast(Common.EBOOL_TFHE_GO, ebool.unwrap(value), Common.EUINT16_TFHE_GO));\n    }\n    /// @notice Converts a ebool to an euint32\n    function asEuint32(ebool value) internal pure returns (euint32) {\n        return euint32.wrap(Impl.cast(Common.EBOOL_TFHE_GO, ebool.unwrap(value), Common.EUINT32_TFHE_GO));\n    }\n    \n    /// @notice Converts a euint8 to an ebool\n    function asEbool(euint8 value) internal pure returns (ebool) {\n        return ne(value, asEuint8(0));\n    }\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint8\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\n    /// @return a ciphertext representation of the input\n    function asEuint8(inEuint8 memory value) internal pure returns (euint8) {\n        return FHE.asEuint8(value.data);\n    }\n    /// @notice Converts a euint8 to an euint16\n    function asEuint16(euint8 value) internal pure returns (euint16) {\n        return euint16.wrap(Impl.cast(Common.EUINT8_TFHE_GO, euint8.unwrap(value), Common.EUINT16_TFHE_GO));\n    }\n    /// @notice Converts a euint8 to an euint32\n    function asEuint32(euint8 value) internal pure returns (euint32) {\n        return euint32.wrap(Impl.cast(Common.EUINT8_TFHE_GO, euint8.unwrap(value), Common.EUINT32_TFHE_GO));\n    }\n    \n    /// @notice Converts a euint16 to an ebool\n    function asEbool(euint16 value) internal pure returns (ebool) {\n        return ne(value, asEuint16(0));\n    }\n    /// @notice Converts a euint16 to an euint8\n    function asEuint8(euint16 value) internal pure returns (euint8) {\n        return euint8.wrap(Impl.cast(Common.EUINT16_TFHE_GO, euint16.unwrap(value), Common.EUINT8_TFHE_GO));\n    }\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint16\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\n    /// @return a ciphertext representation of the input\n    function asEuint16(inEuint16 memory value) internal pure returns (euint16) {\n        return FHE.asEuint16(value.data);\n    }\n    /// @notice Converts a euint16 to an euint32\n    function asEuint32(euint16 value) internal pure returns (euint32) {\n        return euint32.wrap(Impl.cast(Common.EUINT16_TFHE_GO, euint16.unwrap(value), Common.EUINT32_TFHE_GO));\n    }\n    \n    /// @notice Converts a euint32 to an ebool\n    function asEbool(euint32 value) internal pure returns (ebool) {\n        return ne(value, asEuint32(0));\n    }\n    /// @notice Converts a euint32 to an euint8\n    function asEuint8(euint32 value) internal pure returns (euint8) {\n        return euint8.wrap(Impl.cast(Common.EUINT32_TFHE_GO, euint32.unwrap(value), Common.EUINT8_TFHE_GO));\n    }\n    /// @notice Converts a euint32 to an euint16\n    function asEuint16(euint32 value) internal pure returns (euint16) {\n        return euint16.wrap(Impl.cast(Common.EUINT32_TFHE_GO, euint32.unwrap(value), Common.EUINT16_TFHE_GO));\n    }\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint32\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\n    /// @return a ciphertext representation of the input\n    function asEuint32(inEuint32 memory value) internal pure returns (euint32) {\n        return FHE.asEuint32(value.data);\n    }\n    /// @notice Converts a uint256 to an ebool\n    function asEbool(uint256 value) internal pure returns (ebool) {\n        return ebool.wrap(Impl.trivialEncrypt(value, Common.EBOOL_TFHE_GO));\n    }\n    /// @notice Converts a uint256 to an euint8\n    function asEuint8(uint256 value) internal pure returns (euint8) {\n        return euint8.wrap(Impl.trivialEncrypt(value, Common.EUINT8_TFHE_GO));\n    }\n    /// @notice Converts a uint256 to an euint16\n    function asEuint16(uint256 value) internal pure returns (euint16) {\n        return euint16.wrap(Impl.trivialEncrypt(value, Common.EUINT16_TFHE_GO));\n    }\n    /// @notice Converts a uint256 to an euint32\n    function asEuint32(uint256 value) internal pure returns (euint32) {\n        return euint32.wrap(Impl.trivialEncrypt(value, Common.EUINT32_TFHE_GO));\n    }\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an ebool\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\n    /// @return a ciphertext representation of the input\n    function asEbool(bytes memory value) internal pure returns (ebool) {\n        return ebool.wrap(Impl.verify(value, Common.EBOOL_TFHE_GO));\n    }\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint8\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\n    /// @return a ciphertext representation of the input\n    function asEuint8(bytes memory value) internal pure returns (euint8) {\n        return euint8.wrap(Impl.verify(value, Common.EUINT8_TFHE_GO));\n    }\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint16\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\n    /// @return a ciphertext representation of the input\n    function asEuint16(bytes memory value) internal pure returns (euint16) {\n        return euint16.wrap(Impl.verify(value, Common.EUINT16_TFHE_GO));\n    }\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint32\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\n    /// @return a ciphertext representation of the input\n    function asEuint32(bytes memory value) internal pure returns (euint32) {\n        return euint32.wrap(Impl.verify(value, Common.EUINT32_TFHE_GO));\n    }\n    /// @notice Converts a plaintext boolean value to a ciphertext ebool\n    /// @dev Privacy: The input value is public, therefore the ciphertext should be considered public and should be used\n    ///only for mathematical operations, not to represent data that should be private\n    /// @return A ciphertext representation of the input \n    function asEbool(bool value) internal pure returns (ebool) {\n        uint256 sVal = 0;\n        if (value) {\n            sVal = 1;\n        }\n\n        return asEbool(sVal);\n    }\n}\n\n// ********** OPERATOR OVERLOADING ************* //\n\nusing {operatorAddEuint8 as +} for euint8 global;\n/// @notice Performs the add operation\nfunction operatorAddEuint8(euint8 lhs, euint8 rhs) pure returns (euint8) {\n    return FHE.add(lhs, rhs);\n}\n\nusing {operatorAddEuint16 as +} for euint16 global;\n/// @notice Performs the add operation\nfunction operatorAddEuint16(euint16 lhs, euint16 rhs) pure returns (euint16) {\n    return FHE.add(lhs, rhs);\n}\n\nusing {operatorAddEuint32 as +} for euint32 global;\n/// @notice Performs the add operation\nfunction operatorAddEuint32(euint32 lhs, euint32 rhs) pure returns (euint32) {\n    return FHE.add(lhs, rhs);\n}\n\nusing {operatorSubEuint8 as -} for euint8 global;\n/// @notice Performs the sub operation\nfunction operatorSubEuint8(euint8 lhs, euint8 rhs) pure returns (euint8) {\n    return FHE.sub(lhs, rhs);\n}\n\nusing {operatorSubEuint16 as -} for euint16 global;\n/// @notice Performs the sub operation\nfunction operatorSubEuint16(euint16 lhs, euint16 rhs) pure returns (euint16) {\n    return FHE.sub(lhs, rhs);\n}\n\nusing {operatorSubEuint32 as -} for euint32 global;\n/// @notice Performs the sub operation\nfunction operatorSubEuint32(euint32 lhs, euint32 rhs) pure returns (euint32) {\n    return FHE.sub(lhs, rhs);\n}\n\nusing {operatorMulEuint8 as *} for euint8 global;\n/// @notice Performs the mul operation\nfunction operatorMulEuint8(euint8 lhs, euint8 rhs) pure returns (euint8) {\n    return FHE.mul(lhs, rhs);\n}\n\nusing {operatorMulEuint16 as *} for euint16 global;\n/// @notice Performs the mul operation\nfunction operatorMulEuint16(euint16 lhs, euint16 rhs) pure returns (euint16) {\n    return FHE.mul(lhs, rhs);\n}\n\nusing {operatorMulEuint32 as *} for euint32 global;\n/// @notice Performs the mul operation\nfunction operatorMulEuint32(euint32 lhs, euint32 rhs) pure returns (euint32) {\n    return FHE.mul(lhs, rhs);\n}\n\nusing {operatorDivEuint8 as /} for euint8 global;\n/// @notice Performs the div operation\nfunction operatorDivEuint8(euint8 lhs, euint8 rhs) pure returns (euint8) {\n    return FHE.div(lhs, rhs);\n}\n\nusing {operatorDivEuint16 as /} for euint16 global;\n/// @notice Performs the div operation\nfunction operatorDivEuint16(euint16 lhs, euint16 rhs) pure returns (euint16) {\n    return FHE.div(lhs, rhs);\n}\n\nusing {operatorDivEuint32 as /} for euint32 global;\n/// @notice Performs the div operation\nfunction operatorDivEuint32(euint32 lhs, euint32 rhs) pure returns (euint32) {\n    return FHE.div(lhs, rhs);\n}\n\nusing {operatorOrEbool as |} for ebool global;\n/// @notice Performs the or operation\nfunction operatorOrEbool(ebool lhs, ebool rhs) pure returns (ebool) {\n    return FHE.or(lhs, rhs);\n}\n\nusing {operatorOrEuint8 as |} for euint8 global;\n/// @notice Performs the or operation\nfunction operatorOrEuint8(euint8 lhs, euint8 rhs) pure returns (euint8) {\n    return FHE.or(lhs, rhs);\n}\n\nusing {operatorOrEuint16 as |} for euint16 global;\n/// @notice Performs the or operation\nfunction operatorOrEuint16(euint16 lhs, euint16 rhs) pure returns (euint16) {\n    return FHE.or(lhs, rhs);\n}\n\nusing {operatorOrEuint32 as |} for euint32 global;\n/// @notice Performs the or operation\nfunction operatorOrEuint32(euint32 lhs, euint32 rhs) pure returns (euint32) {\n    return FHE.or(lhs, rhs);\n}\n\nusing {operatorAndEbool as &} for ebool global;\n/// @notice Performs the and operation\nfunction operatorAndEbool(ebool lhs, ebool rhs) pure returns (ebool) {\n    return FHE.and(lhs, rhs);\n}\n\nusing {operatorAndEuint8 as &} for euint8 global;\n/// @notice Performs the and operation\nfunction operatorAndEuint8(euint8 lhs, euint8 rhs) pure returns (euint8) {\n    return FHE.and(lhs, rhs);\n}\n\nusing {operatorAndEuint16 as &} for euint16 global;\n/// @notice Performs the and operation\nfunction operatorAndEuint16(euint16 lhs, euint16 rhs) pure returns (euint16) {\n    return FHE.and(lhs, rhs);\n}\n\nusing {operatorAndEuint32 as &} for euint32 global;\n/// @notice Performs the and operation\nfunction operatorAndEuint32(euint32 lhs, euint32 rhs) pure returns (euint32) {\n    return FHE.and(lhs, rhs);\n}\n\nusing {operatorXorEbool as ^} for ebool global;\n/// @notice Performs the xor operation\nfunction operatorXorEbool(ebool lhs, ebool rhs) pure returns (ebool) {\n    return FHE.xor(lhs, rhs);\n}\n\nusing {operatorXorEuint8 as ^} for euint8 global;\n/// @notice Performs the xor operation\nfunction operatorXorEuint8(euint8 lhs, euint8 rhs) pure returns (euint8) {\n    return FHE.xor(lhs, rhs);\n}\n\nusing {operatorXorEuint16 as ^} for euint16 global;\n/// @notice Performs the xor operation\nfunction operatorXorEuint16(euint16 lhs, euint16 rhs) pure returns (euint16) {\n    return FHE.xor(lhs, rhs);\n}\n\nusing {operatorXorEuint32 as ^} for euint32 global;\n/// @notice Performs the xor operation\nfunction operatorXorEuint32(euint32 lhs, euint32 rhs) pure returns (euint32) {\n    return FHE.xor(lhs, rhs);\n}\n\nusing {operatorRemEuint8 as %} for euint8 global;\n/// @notice Performs the rem operation\nfunction operatorRemEuint8(euint8 lhs, euint8 rhs) pure returns (euint8) {\n    return FHE.rem(lhs, rhs);\n}\n\nusing {operatorRemEuint16 as %} for euint16 global;\n/// @notice Performs the rem operation\nfunction operatorRemEuint16(euint16 lhs, euint16 rhs) pure returns (euint16) {\n    return FHE.rem(lhs, rhs);\n}\n\nusing {operatorRemEuint32 as %} for euint32 global;\n/// @notice Performs the rem operation\nfunction operatorRemEuint32(euint32 lhs, euint32 rhs) pure returns (euint32) {\n    return FHE.rem(lhs, rhs);\n}\n\n// ********** BINDING DEFS ************* //\n\nusing BindingsEbool for ebool global;\nlibrary BindingsEbool {\n    \n    /// @notice Performs the eq operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type ebool\n    /// @return the result of the eq\n    function eq(ebool lhs, ebool rhs) internal pure returns (ebool) {\n        return FHE.eq(lhs, rhs);\n    }\n    \n    /// @notice Performs the ne operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type ebool\n    /// @return the result of the ne\n    function ne(ebool lhs, ebool rhs) internal pure returns (ebool) {\n        return FHE.ne(lhs, rhs);\n    }\n    \n    /// @notice Performs the and operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type ebool\n    /// @return the result of the and\n    function and(ebool lhs, ebool rhs) internal pure returns (ebool) {\n        return FHE.and(lhs, rhs);\n    }\n    \n    /// @notice Performs the or operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type ebool\n    /// @return the result of the or\n    function or(ebool lhs, ebool rhs) internal pure returns (ebool) {\n        return FHE.or(lhs, rhs);\n    }\n    \n    /// @notice Performs the xor operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type ebool\n    /// @return the result of the xor\n    function xor(ebool lhs, ebool rhs) internal pure returns (ebool) {\n        return FHE.xor(lhs, rhs);\n    }\n    function toU8(ebool value) internal pure returns (euint8) {\n        return FHE.asEuint8(value);\n    }\n    function toU16(ebool value) internal pure returns (euint16) {\n        return FHE.asEuint16(value);\n    }\n    function toU32(ebool value) internal pure returns (euint32) {\n        return FHE.asEuint32(value);\n    }\n    function seal(ebool value, bytes32 publicKey) internal pure returns (bytes memory) {\n        return FHE.sealoutput(value, publicKey);\n    }\n}\n\nusing BindingsEuint8 for euint8 global;\nlibrary BindingsEuint8 {\n    \n    /// @notice Performs the add operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @return the result of the add\n    function add(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\n        return FHE.add(lhs, rhs);\n    }\n    \n    /// @notice Performs the mul operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @return the result of the mul\n    function mul(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\n        return FHE.mul(lhs, rhs);\n    }\n    \n    /// @notice Performs the div operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @return the result of the div\n    function div(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\n        return FHE.div(lhs, rhs);\n    }\n    \n    /// @notice Performs the sub operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @return the result of the sub\n    function sub(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\n        return FHE.sub(lhs, rhs);\n    }\n    \n    /// @notice Performs the eq operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @return the result of the eq\n    function eq(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\n        return FHE.eq(lhs, rhs);\n    }\n    \n    /// @notice Performs the ne operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @return the result of the ne\n    function ne(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\n        return FHE.ne(lhs, rhs);\n    }\n    \n    /// @notice Performs the and operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @return the result of the and\n    function and(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\n        return FHE.and(lhs, rhs);\n    }\n    \n    /// @notice Performs the or operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @return the result of the or\n    function or(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\n        return FHE.or(lhs, rhs);\n    }\n    \n    /// @notice Performs the xor operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @return the result of the xor\n    function xor(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\n        return FHE.xor(lhs, rhs);\n    }\n    \n    /// @notice Performs the gt operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @return the result of the gt\n    function gt(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\n        return FHE.gt(lhs, rhs);\n    }\n    \n    /// @notice Performs the gte operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @return the result of the gte\n    function gte(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\n        return FHE.gte(lhs, rhs);\n    }\n    \n    /// @notice Performs the lt operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @return the result of the lt\n    function lt(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\n        return FHE.lt(lhs, rhs);\n    }\n    \n    /// @notice Performs the lte operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @return the result of the lte\n    function lte(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\n        return FHE.lte(lhs, rhs);\n    }\n    \n    /// @notice Performs the rem operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @return the result of the rem\n    function rem(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\n        return FHE.rem(lhs, rhs);\n    }\n    \n    /// @notice Performs the max operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @return the result of the max\n    function max(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\n        return FHE.max(lhs, rhs);\n    }\n    \n    /// @notice Performs the min operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @return the result of the min\n    function min(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\n        return FHE.min(lhs, rhs);\n    }\n    \n    /// @notice Performs the shl operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @return the result of the shl\n    function shl(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\n        return FHE.shl(lhs, rhs);\n    }\n    \n    /// @notice Performs the shr operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @return the result of the shr\n    function shr(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\n        return FHE.shr(lhs, rhs);\n    }\n    function toBool(euint8 value) internal pure returns (ebool) {\n        return FHE.asEbool(value);\n    }\n    function toU16(euint8 value) internal pure returns (euint16) {\n        return FHE.asEuint16(value);\n    }\n    function toU32(euint8 value) internal pure returns (euint32) {\n        return FHE.asEuint32(value);\n    }\n    function seal(euint8 value, bytes32 publicKey) internal pure returns (bytes memory) {\n        return FHE.sealoutput(value, publicKey);\n    }\n}\n\nusing BindingsEuint16 for euint16 global;\nlibrary BindingsEuint16 {\n    \n    /// @notice Performs the add operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @return the result of the add\n    function add(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\n        return FHE.add(lhs, rhs);\n    }\n    \n    /// @notice Performs the mul operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @return the result of the mul\n    function mul(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\n        return FHE.mul(lhs, rhs);\n    }\n    \n    /// @notice Performs the div operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @return the result of the div\n    function div(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\n        return FHE.div(lhs, rhs);\n    }\n    \n    /// @notice Performs the sub operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @return the result of the sub\n    function sub(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\n        return FHE.sub(lhs, rhs);\n    }\n    \n    /// @notice Performs the eq operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @return the result of the eq\n    function eq(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\n        return FHE.eq(lhs, rhs);\n    }\n    \n    /// @notice Performs the ne operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @return the result of the ne\n    function ne(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\n        return FHE.ne(lhs, rhs);\n    }\n    \n    /// @notice Performs the and operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @return the result of the and\n    function and(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\n        return FHE.and(lhs, rhs);\n    }\n    \n    /// @notice Performs the or operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @return the result of the or\n    function or(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\n        return FHE.or(lhs, rhs);\n    }\n    \n    /// @notice Performs the xor operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @return the result of the xor\n    function xor(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\n        return FHE.xor(lhs, rhs);\n    }\n    \n    /// @notice Performs the gt operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @return the result of the gt\n    function gt(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\n        return FHE.gt(lhs, rhs);\n    }\n    \n    /// @notice Performs the gte operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @return the result of the gte\n    function gte(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\n        return FHE.gte(lhs, rhs);\n    }\n    \n    /// @notice Performs the lt operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @return the result of the lt\n    function lt(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\n        return FHE.lt(lhs, rhs);\n    }\n    \n    /// @notice Performs the lte operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @return the result of the lte\n    function lte(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\n        return FHE.lte(lhs, rhs);\n    }\n    \n    /// @notice Performs the rem operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @return the result of the rem\n    function rem(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\n        return FHE.rem(lhs, rhs);\n    }\n    \n    /// @notice Performs the max operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @return the result of the max\n    function max(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\n        return FHE.max(lhs, rhs);\n    }\n    \n    /// @notice Performs the min operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @return the result of the min\n    function min(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\n        return FHE.min(lhs, rhs);\n    }\n    \n    /// @notice Performs the shl operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @return the result of the shl\n    function shl(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\n        return FHE.shl(lhs, rhs);\n    }\n    \n    /// @notice Performs the shr operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @return the result of the shr\n    function shr(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\n        return FHE.shr(lhs, rhs);\n    }\n    function toBool(euint16 value) internal pure returns (ebool) {\n        return FHE.asEbool(value);\n    }\n    function toU8(euint16 value) internal pure returns (euint8) {\n        return FHE.asEuint8(value);\n    }\n    function toU32(euint16 value) internal pure returns (euint32) {\n        return FHE.asEuint32(value);\n    }\n    function seal(euint16 value, bytes32 publicKey) internal pure returns (bytes memory) {\n        return FHE.sealoutput(value, publicKey);\n    }\n}\n\nusing BindingsEuint32 for euint32 global;\nlibrary BindingsEuint32 {\n    \n    /// @notice Performs the add operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @return the result of the add\n    function add(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\n        return FHE.add(lhs, rhs);\n    }\n    \n    /// @notice Performs the mul operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @return the result of the mul\n    function mul(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\n        return FHE.mul(lhs, rhs);\n    }\n    \n    /// @notice Performs the div operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @return the result of the div\n    function div(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\n        return FHE.div(lhs, rhs);\n    }\n    \n    /// @notice Performs the sub operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @return the result of the sub\n    function sub(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\n        return FHE.sub(lhs, rhs);\n    }\n    \n    /// @notice Performs the eq operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @return the result of the eq\n    function eq(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\n        return FHE.eq(lhs, rhs);\n    }\n    \n    /// @notice Performs the ne operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @return the result of the ne\n    function ne(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\n        return FHE.ne(lhs, rhs);\n    }\n    \n    /// @notice Performs the and operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @return the result of the and\n    function and(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\n        return FHE.and(lhs, rhs);\n    }\n    \n    /// @notice Performs the or operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @return the result of the or\n    function or(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\n        return FHE.or(lhs, rhs);\n    }\n    \n    /// @notice Performs the xor operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @return the result of the xor\n    function xor(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\n        return FHE.xor(lhs, rhs);\n    }\n    \n    /// @notice Performs the gt operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @return the result of the gt\n    function gt(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\n        return FHE.gt(lhs, rhs);\n    }\n    \n    /// @notice Performs the gte operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @return the result of the gte\n    function gte(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\n        return FHE.gte(lhs, rhs);\n    }\n    \n    /// @notice Performs the lt operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @return the result of the lt\n    function lt(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\n        return FHE.lt(lhs, rhs);\n    }\n    \n    /// @notice Performs the lte operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @return the result of the lte\n    function lte(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\n        return FHE.lte(lhs, rhs);\n    }\n    \n    /// @notice Performs the rem operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @return the result of the rem\n    function rem(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\n        return FHE.rem(lhs, rhs);\n    }\n    \n    /// @notice Performs the max operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @return the result of the max\n    function max(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\n        return FHE.max(lhs, rhs);\n    }\n    \n    /// @notice Performs the min operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @return the result of the min\n    function min(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\n        return FHE.min(lhs, rhs);\n    }\n    \n    /// @notice Performs the shl operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @return the result of the shl\n    function shl(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\n        return FHE.shl(lhs, rhs);\n    }\n    \n    /// @notice Performs the shr operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @return the result of the shr\n    function shr(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\n        return FHE.shr(lhs, rhs);\n    }\n    function toBool(euint32 value) internal pure returns (ebool) {\n        return FHE.asEbool(value);\n    }\n    function toU8(euint32 value) internal pure returns (euint8) {\n        return FHE.asEuint8(value);\n    }\n    function toU16(euint32 value) internal pure returns (euint16) {\n        return FHE.asEuint16(value);\n    }\n    function seal(euint32 value, bytes32 publicKey) internal pure returns (bytes memory) {\n        return FHE.sealoutput(value, publicKey);\n    }\n}"
    },
    "@fhenixprotocol/contracts/FheOS.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\n// solhint-disable one-contract-per-file\npragma solidity >=0.8.13 <0.9.0;\n\nlibrary Precompiles {\n    //solhint-disable const-name-snakecase\n    address public constant Fheos = address(128);\n}\n\ninterface FheOps {\n    function add(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\n    function verify(uint8 utype, bytes memory input) external pure returns (bytes memory);\n    function sealOutput(uint8 utype, bytes memory ctHash, bytes memory pk) external pure returns (bytes memory);\n    function decrypt(uint8 utype, bytes memory input) external pure returns (uint256);\n    function lte(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\n    function sub(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\n    function mul(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\n    function lt(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\n    function select(uint8 utype, bytes memory controlHash, bytes memory ifTrueHash, bytes memory ifFalseHash) external pure returns (bytes memory);\n    function req(uint8 utype, bytes memory input) external pure returns (bytes memory);\n    function cast(uint8 utype, bytes memory input, uint8 toType) external pure returns (bytes memory);\n    function trivialEncrypt(bytes memory input, uint8 toType) external pure returns (bytes memory);\n    function div(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\n    function gt(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\n    function gte(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\n    function rem(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\n    function and(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\n    function or(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\n    function xor(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\n    function eq(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\n    function ne(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\n    function min(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\n    function max(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\n    function shl(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\n    function shr(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\n    function not(uint8 utype, bytes memory value) external pure returns (bytes memory);\n    function getNetworkPublicKey() external pure returns (bytes memory);\n}"
    },
    "contracts/EncryptedPairFHE.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\nimport \"@fhenixprotocol/contracts/FHE.sol\";\nimport \"./interfaces/IERC20.sol\";\n\ncontract Pair {\n\n    IERC20 public token0;\n    IERC20 public token1;\n    address public  factory;\n\n    uint public reserve0;\n    uint public reserve1;\n\n    uint public totalSupply;\n    mapping(address => uint) public balanceOf;\n\n    constructor() {\n        factory = msg.sender;\n    }\n\n    function initialize(address _token0, address _token1) external {\n        require(msg.sender == factory, 'Only Factory can call this'); // sufficient check\n        token0 = IERC20(_token0);\n        token1 = IERC20(_token1);\n    }\n\n    function _mint(address _to, uint _amount) private {\n        balanceOf[_to] += _amount;\n        totalSupply += _amount;\n    }\n\n    function _burn(address _from, uint _amount) private {\n        balanceOf[_from] -= _amount;\n        totalSupply -= _amount;\n    }\n\n    function _update(uint _reserve0, uint _reserve1) private {\n        reserve0 = _reserve0;\n        reserve1 = _reserve1;\n    }\n\n    function swap(address _tokenIn, inEuint32 calldata _amountIn) external returns (uint amountOut) {\n        // euint32 x = TFHE.asEuint32(_amountIn);\n        // uint32 amountIn = TFHE.decrypt(x);\n        euint32 x = FHE.asEuint32(_amountIn);\n        uint256 amountIn = FHE.decrypt(x);\n        require(\n            _tokenIn == address(token0) || _tokenIn == address(token1),\n            \"invalid token\"\n        );\n        require(uint256(amountIn) > 0, \"amount in = 0\");\n\n        bool isToken0 = _tokenIn == address(token0);\n        (IERC20 tokenIn, IERC20 tokenOut, uint reserveIn, uint reserveOut) = isToken0\n            ? (token0, token1, reserve0, reserve1)\n            : (token1, token0, reserve1, reserve0);\n\n        tokenIn.transferFrom(msg.sender, address(this), uint256(amountIn));\n\n        uint amountInWithFee = (uint256(amountIn) * 997) / 1000;\n        amountOut = (reserveOut * amountInWithFee) / (reserveIn + amountInWithFee);\n\n        tokenOut.transfer(msg.sender, uint256(amountOut));\n\n        _update(token0.balanceOf(address(this)), token1.balanceOf(address(this)));\n    }\n\n    function addLiquidity(inEuint32 calldata _amount0, inEuint32 calldata _amount1) external returns (uint shares) {\n        // euint32 x = TFHE.asEuint32(_amount0);\n        // euint32 y = TFHE.asEuint32(_amount1);\n        // uint32 amount0 = TFHE.decrypt(x);\n        // uint32 amount1 = TFHE.decrypt(y);\n\n        euint32 x = FHE.asEuint32(_amount0);\n        euint32 y = FHE.asEuint32(_amount1);\n        uint32 amount0 = FHE.decrypt(x);\n        uint32 amount1 = FHE.decrypt(y);\n        \n        token0.transferFrom(msg.sender, address(this), uint256(amount0));\n        token1.transferFrom(msg.sender, address(this), uint256(amount1));\n\n        if (reserve0 > 0 || reserve1 > 0) {\n            require(reserve0 * uint(amount1) == reserve1 * uint(amount0), \"x / y != dx / dy\");\n        }\n\n        if (totalSupply == 0) {\n            shares = _sqrt(uint256(amount0) * uint256(amount1));\n        } else {\n            shares = _min(\n                (uint256(amount0) * totalSupply) / reserve0,\n                (uint256(amount1) * totalSupply) / reserve1\n            );\n        }\n        require(shares > 0, \"shares = 0\");\n        _mint(msg.sender, shares);\n\n        _update(token0.balanceOf(address(this)), token1.balanceOf(address(this)));\n    }\n\n    function removeLiquidity(\n        inEuint32 calldata _shares\n    ) external returns (uint amount0, uint amount1) {\n        \n        euint32 x = FHE.asEuint32(_shares);\n\n        uint32 shares = FHE.decrypt(x);\n        uint bal0 = token0.balanceOf(address(this));\n        uint bal1 = token1.balanceOf(address(this));\n\n        amount0 = (uint256(shares) * bal0) / totalSupply;\n        amount1 = (uint256(shares) * bal1) / totalSupply;\n        require(amount0 > 0 && amount1 > 0, \"amount0 or amount1 = 0\");\n\n        _burn(msg.sender, shares);\n        _update(bal0 - amount0, bal1 - amount1);\n\n        token0.transfer(msg.sender, uint256(amount0));\n        token1.transfer(msg.sender, uint256(amount1));\n    }\n\n    function _sqrt(uint y) private pure returns (uint z) {\n        if (y > 3) {\n            z = y;\n            uint x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    function _min(uint x, uint y) private pure returns (uint) {\n        return x <= y ? x : y;\n    }\n}"
    },
    "contracts/Factory.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.19;\n\nimport \"./EncryptedPairFHE.sol\";\n\nimport \"hardhat/console.sol\";\n\ncontract FactoryFHE {\n\n    mapping(address => mapping(address => address)) public getPair;\n\n    address[] public allPairs;\n\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function allPairsLength() external view returns (uint) {\n        return allPairs.length;\n    }\n\n    function createPair(address tokenA, address tokenB) external returns (address pair) {\n        console.log(\"done\");\n        require(tokenA != tokenB, 'IDENTICAL_ADDRESSES');\n        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        console.log(\"The address of token0 \", token0);\n        require(token0 != address(0), 'ZERO_ADDRESS');\n        require(getPair[token0][token1] == address(0), 'PAIR_EXISTS'); // single check is sufficient\n        bytes memory bytecode = type(Pair).creationCode;\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1));\n        assembly {\n            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)\n        }\n        console.log(\"The address of \", pair);\n        Pair(pair).initialize(token0, token1);\n        getPair[token0][token1] = pair;\n        getPair[token1][token0] = pair; // populate mapping in the reverse direction\n        allPairs.push(pair);\n        emit PairCreated(token0, token1, pair, allPairs.length);\n    }\n}\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT \npragma solidity 0.8.19;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint);\n\n    function balanceOf(address account) external view returns (uint);\n\n    function transfer(address recipient, uint amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint amount\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint amount);\n    event Approval(address indexed owner, address indexed spender, uint amount);\n}"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS =\n        0x000000000000000000636F6e736F6c652e6c6f67;\n\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            pop(\n                staticcall(\n                    gas(),\n                    consoleAddress,\n                    add(payload, 32),\n                    mload(payload),\n                    0,\n                    0\n                )\n            )\n        }\n    }\n\n    function _castToPure(\n      function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castToPure(_sendLogPayloadImplementation)(payload);\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n    function logInt(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}