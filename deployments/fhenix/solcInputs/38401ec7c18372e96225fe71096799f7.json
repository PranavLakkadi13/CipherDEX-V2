{
  "language": "Solidity",
  "sources": {
    "@fhenixprotocol/contracts/FHE.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\n// solhint-disable one-contract-per-file\n\npragma solidity >=0.8.19 <0.9.0;\n\nimport {Precompiles, FheOps} from \"./FheOS.sol\";\n\ntype ebool is uint256;\ntype euint8 is uint256;\ntype euint16 is uint256;\ntype euint32 is uint256;\n\nstruct inEbool {\n    bytes data;\n}\nstruct inEuint8 {\n    bytes data;\n}\nstruct inEuint16 {\n    bytes data;\n}\nstruct inEuint32 {\n    bytes data;\n}\n\nlibrary Common {\n    // Values used to communicate types to the runtime.\n    uint8 internal constant EBOOL_TFHE_GO = 0;\n    uint8 internal constant EUINT8_TFHE_GO = 0;\n    uint8 internal constant EUINT16_TFHE_GO = 1;\n    uint8 internal constant EUINT32_TFHE_GO = 2;\n\n    function bigIntToBool(uint256 i) internal pure returns (bool) {\n        return (i > 0);\n    }\n\n    function bigIntToUint8(uint256 i) internal pure returns (uint8) {\n        return uint8(i);\n    }\n\n    function bigIntToUint16(uint256 i) internal pure returns (uint16) {\n        return uint16(i);\n    }\n\n    function bigIntToUint32(uint256 i) internal pure returns (uint32) {\n        return uint32(i);\n    }\n\n    function bigIntToUint64(uint256 i) internal pure returns (uint64) {\n        return uint64(i);\n    }\n\n    function bigIntToUint128(uint256 i) internal pure returns (uint128) {\n        return uint128(i);\n    }\n\n    function bigIntToUint256(uint256 i) internal pure returns (uint256) {\n        return i;\n    }\n    \n    function toBytes(uint256 x) internal pure returns (bytes memory b) {\n        b = new bytes(32);\n        assembly { mstore(add(b, 32), x) }\n    }\n    \n}\n\nlibrary Impl {\n    function sealoutput(uint8 utype, uint256 ciphertext, bytes32 publicKey) internal pure returns (bytes memory reencrypted) {\n        // Call the sealoutput precompile.\n        reencrypted = FheOps(Precompiles.Fheos).sealOutput(utype, Common.toBytes(ciphertext), bytes.concat(publicKey));\n\n        return reencrypted;\n    }\n\n    function verify(bytes memory _ciphertextBytes, uint8 _toType) internal pure returns (uint256 result) {\n        bytes memory output;\n\n        // Call the verify precompile.\n        output = FheOps(Precompiles.Fheos).verify(_toType, _ciphertextBytes);\n        result = getValue(output);\n    }\n\n    function cast(uint8 utype, uint256 ciphertext, uint8 toType) internal pure returns (uint256 result) {\n        bytes memory output;\n\n        // Call the cast precompile.\n        output = FheOps(Precompiles.Fheos).cast(utype, Common.toBytes(ciphertext), toType);\n        result = getValue(output);\n    }\n\n    function getValue(bytes memory a) internal pure returns (uint256 value) {\n        assembly {\n            value := mload(add(a, 0x20))\n        }\n    }\n\n    function trivialEncrypt(uint256 value, uint8 toType) internal pure returns (uint256 result) {\n        bytes memory output;\n\n        // Call the trivialEncrypt precompile.\n        output = FheOps(Precompiles.Fheos).trivialEncrypt(Common.toBytes(value), toType);\n\n        result = getValue(output);\n    }\n\n    function select(uint8 utype, uint256 control, uint256 ifTrue, uint256 ifFalse) internal pure returns (uint256 result) {\n        bytes memory output;\n\n        // Call the trivialEncrypt precompile.\n        output = FheOps(Precompiles.Fheos).select(utype, Common.toBytes(control), Common.toBytes(ifTrue), Common.toBytes(ifFalse));\n\n        result = getValue(output);\n    }\n}\n\nlibrary FHE {\n    euint8 public constant NIL8 = euint8.wrap(0);\n    euint16 public constant NIL16 = euint16.wrap(0);\n    euint32 public constant NIL32 = euint32.wrap(0);\n\n    // Return true if the encrypted integer is initialized and false otherwise.\n    function isInitialized(ebool v) internal pure returns (bool) {\n        return ebool.unwrap(v) != 0;\n    }\n\n    // Return true if the encrypted integer is initialized and false otherwise.\n    function isInitialized(euint8 v) internal pure returns (bool) {\n        return euint8.unwrap(v) != 0;\n    }\n\n    // Return true if the encrypted integer is initialized and false otherwise.\n    function isInitialized(euint16 v) internal pure returns (bool) {\n        return euint16.unwrap(v) != 0;\n    }\n\n    // Return true if the encrypted integer is initialized and false otherwise.\n    function isInitialized(euint32 v) internal pure returns (bool) {\n        return euint32.unwrap(v) != 0;\n    }\n\n    function getValue(bytes memory a) private pure returns (uint256 value) {\n        assembly {\n            value := mload(add(a, 0x20))\n        }\n    }\n    \n    function mathHelper(\n        uint8 utype,\n        uint256 lhs,\n        uint256 rhs,\n        function(uint8, bytes memory, bytes memory) external pure returns (bytes memory) impl\n    ) internal pure returns (uint256 result) {\n        bytes memory output;\n        output = impl(utype, Common.toBytes(lhs), Common.toBytes(rhs));\n        result = getValue(output);\n    }\n    \n    /// @notice This functions performs the add operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function add(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint8(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint8(0);\n        }\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).add);\n        return euint8.wrap(result);\n    }\n    /// @notice This functions performs the add operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function add(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint16(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint16(0);\n        }\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).add);\n        return euint16.wrap(result);\n    }\n    /// @notice This functions performs the add operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function add(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint32(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint32(0);\n        }\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).add);\n        return euint32.wrap(result);\n    }\n    /// @notice performs the sealoutput function on a ebool ciphertext. This operation returns the plaintext value, sealed for the public key provided \n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param value Ciphertext to decrypt and seal\n    /// @param publicKey Public Key that will receive the sealed plaintext\n    /// @return Plaintext input, sealed for the owner of `publicKey`\n    function sealoutput(ebool value, bytes32 publicKey) internal pure returns (bytes memory) {\n        if (!isInitialized(value)) {\n            value = asEbool(0);\n        }\n        uint256 unwrapped = ebool.unwrap(value);\n\n        return Impl.sealoutput(Common.EBOOL_TFHE_GO, unwrapped, publicKey);\n    }\n    /// @notice performs the sealoutput function on a euint8 ciphertext. This operation returns the plaintext value, sealed for the public key provided \n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param value Ciphertext to decrypt and seal\n    /// @param publicKey Public Key that will receive the sealed plaintext\n    /// @return Plaintext input, sealed for the owner of `publicKey`\n    function sealoutput(euint8 value, bytes32 publicKey) internal pure returns (bytes memory) {\n        if (!isInitialized(value)) {\n            value = asEuint8(0);\n        }\n        uint256 unwrapped = euint8.unwrap(value);\n\n        return Impl.sealoutput(Common.EUINT8_TFHE_GO, unwrapped, publicKey);\n    }\n    /// @notice performs the sealoutput function on a euint16 ciphertext. This operation returns the plaintext value, sealed for the public key provided \n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param value Ciphertext to decrypt and seal\n    /// @param publicKey Public Key that will receive the sealed plaintext\n    /// @return Plaintext input, sealed for the owner of `publicKey`\n    function sealoutput(euint16 value, bytes32 publicKey) internal pure returns (bytes memory) {\n        if (!isInitialized(value)) {\n            value = asEuint16(0);\n        }\n        uint256 unwrapped = euint16.unwrap(value);\n\n        return Impl.sealoutput(Common.EUINT16_TFHE_GO, unwrapped, publicKey);\n    }\n    /// @notice performs the sealoutput function on a euint32 ciphertext. This operation returns the plaintext value, sealed for the public key provided \n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param value Ciphertext to decrypt and seal\n    /// @param publicKey Public Key that will receive the sealed plaintext\n    /// @return Plaintext input, sealed for the owner of `publicKey`\n    function sealoutput(euint32 value, bytes32 publicKey) internal pure returns (bytes memory) {\n        if (!isInitialized(value)) {\n            value = asEuint32(0);\n        }\n        uint256 unwrapped = euint32.unwrap(value);\n\n        return Impl.sealoutput(Common.EUINT32_TFHE_GO, unwrapped, publicKey);\n    }\n    /// @notice Performs the decrypt operation on a ciphertext\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param input1 the input ciphertext\n    function decrypt(ebool input1) internal pure returns (bool) {\n        if (!isInitialized(input1)) {\n            input1 = asEbool(0);\n        }\n        uint256 unwrappedInput1 = ebool.unwrap(input1);\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\n        uint256 result = FheOps(Precompiles.Fheos).decrypt(Common.EBOOL_TFHE_GO, inputAsBytes);\n        return Common.bigIntToBool(result);\n    }\n    /// @notice Performs the decrypt operation on a ciphertext\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param input1 the input ciphertext\n    function decrypt(euint8 input1) internal pure returns (uint8) {\n        if (!isInitialized(input1)) {\n            input1 = asEuint8(0);\n        }\n        uint256 unwrappedInput1 = euint8.unwrap(input1);\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\n        uint256 result = FheOps(Precompiles.Fheos).decrypt(Common.EUINT8_TFHE_GO, inputAsBytes);\n        return Common.bigIntToUint8(result);\n    }\n    /// @notice Performs the decrypt operation on a ciphertext\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param input1 the input ciphertext\n    function decrypt(euint16 input1) internal pure returns (uint16) {\n        if (!isInitialized(input1)) {\n            input1 = asEuint16(0);\n        }\n        uint256 unwrappedInput1 = euint16.unwrap(input1);\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\n        uint256 result = FheOps(Precompiles.Fheos).decrypt(Common.EUINT16_TFHE_GO, inputAsBytes);\n        return Common.bigIntToUint16(result);\n    }\n    /// @notice Performs the decrypt operation on a ciphertext\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param input1 the input ciphertext\n    function decrypt(euint32 input1) internal pure returns (uint32) {\n        if (!isInitialized(input1)) {\n            input1 = asEuint32(0);\n        }\n        uint256 unwrappedInput1 = euint32.unwrap(input1);\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\n        uint256 result = FheOps(Precompiles.Fheos).decrypt(Common.EUINT32_TFHE_GO, inputAsBytes);\n        return Common.bigIntToUint32(result);\n    }\n    /// @notice This functions performs the lte operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function lte(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint8(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint8(0);\n        }\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).lte);\n        return ebool.wrap(result);\n    }\n    /// @notice This functions performs the lte operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function lte(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint16(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint16(0);\n        }\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).lte);\n        return ebool.wrap(result);\n    }\n    /// @notice This functions performs the lte operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function lte(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint32(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint32(0);\n        }\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).lte);\n        return ebool.wrap(result);\n    }\n    /// @notice This functions performs the sub operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function sub(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint8(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint8(0);\n        }\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).sub);\n        return euint8.wrap(result);\n    }\n    /// @notice This functions performs the sub operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function sub(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint16(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint16(0);\n        }\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).sub);\n        return euint16.wrap(result);\n    }\n    /// @notice This functions performs the sub operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function sub(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint32(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint32(0);\n        }\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).sub);\n        return euint32.wrap(result);\n    }\n    /// @notice This functions performs the mul operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function mul(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint8(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint8(0);\n        }\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).mul);\n        return euint8.wrap(result);\n    }\n    /// @notice This functions performs the mul operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function mul(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint16(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint16(0);\n        }\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).mul);\n        return euint16.wrap(result);\n    }\n    /// @notice This functions performs the mul operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function mul(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint32(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint32(0);\n        }\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).mul);\n        return euint32.wrap(result);\n    }\n    /// @notice This functions performs the lt operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function lt(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint8(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint8(0);\n        }\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).lt);\n        return ebool.wrap(result);\n    }\n    /// @notice This functions performs the lt operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function lt(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint16(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint16(0);\n        }\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).lt);\n        return ebool.wrap(result);\n    }\n    /// @notice This functions performs the lt operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function lt(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint32(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint32(0);\n        }\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).lt);\n        return ebool.wrap(result);\n    }\n\n    function select(ebool input1, ebool input2, ebool input3) internal pure returns (ebool) {\n        if (!isInitialized(input1)) {\n            input1 = asEbool(0);\n        }\n        if (!isInitialized(input2)) {\n            input2 = asEbool(0);\n        }\n        if (!isInitialized(input3)) {\n            input3 = asEbool(0);\n        }\n\n        uint256 unwrappedInput1 = ebool.unwrap(input1);\n        uint256 unwrappedInput2 = ebool.unwrap(input2);\n        uint256 unwrappedInput3 = ebool.unwrap(input3);\n\n        uint256 result = Impl.select(Common.EBOOL_TFHE_GO, unwrappedInput1, unwrappedInput2, unwrappedInput3);\n        return ebool.wrap(result);\n    }\n\n    function select(ebool input1, euint8 input2, euint8 input3) internal pure returns (euint8) {\n        if (!isInitialized(input1)) {\n            input1 = asEbool(0);\n        }\n        if (!isInitialized(input2)) {\n            input2 = asEuint8(0);\n        }\n        if (!isInitialized(input3)) {\n            input3 = asEuint8(0);\n        }\n\n        uint256 unwrappedInput1 = ebool.unwrap(input1);\n        uint256 unwrappedInput2 = euint8.unwrap(input2);\n        uint256 unwrappedInput3 = euint8.unwrap(input3);\n\n        uint256 result = Impl.select(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, unwrappedInput3);\n        return euint8.wrap(result);\n    }\n\n    function select(ebool input1, euint16 input2, euint16 input3) internal pure returns (euint16) {\n        if (!isInitialized(input1)) {\n            input1 = asEbool(0);\n        }\n        if (!isInitialized(input2)) {\n            input2 = asEuint16(0);\n        }\n        if (!isInitialized(input3)) {\n            input3 = asEuint16(0);\n        }\n\n        uint256 unwrappedInput1 = ebool.unwrap(input1);\n        uint256 unwrappedInput2 = euint16.unwrap(input2);\n        uint256 unwrappedInput3 = euint16.unwrap(input3);\n\n        uint256 result = Impl.select(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, unwrappedInput3);\n        return euint16.wrap(result);\n    }\n\n    function select(ebool input1, euint32 input2, euint32 input3) internal pure returns (euint32) {\n        if (!isInitialized(input1)) {\n            input1 = asEbool(0);\n        }\n        if (!isInitialized(input2)) {\n            input2 = asEuint32(0);\n        }\n        if (!isInitialized(input3)) {\n            input3 = asEuint32(0);\n        }\n\n        uint256 unwrappedInput1 = ebool.unwrap(input1);\n        uint256 unwrappedInput2 = euint32.unwrap(input2);\n        uint256 unwrappedInput3 = euint32.unwrap(input3);\n\n        uint256 result = Impl.select(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, unwrappedInput3);\n        return euint32.wrap(result);\n    }\n    /// @notice Performs the req operation on a ciphertext\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param input1 the input ciphertext\n    function req(ebool input1) internal pure  {\n        if (!isInitialized(input1)) {\n            input1 = asEbool(0);\n        }\n        uint256 unwrappedInput1 = ebool.unwrap(input1);\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\n        FheOps(Precompiles.Fheos).req(Common.EBOOL_TFHE_GO, inputAsBytes);\n    }\n    /// @notice Performs the req operation on a ciphertext\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param input1 the input ciphertext\n    function req(euint8 input1) internal pure  {\n        if (!isInitialized(input1)) {\n            input1 = asEuint8(0);\n        }\n        uint256 unwrappedInput1 = euint8.unwrap(input1);\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\n        FheOps(Precompiles.Fheos).req(Common.EUINT8_TFHE_GO, inputAsBytes);\n    }\n    /// @notice Performs the req operation on a ciphertext\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param input1 the input ciphertext\n    function req(euint16 input1) internal pure  {\n        if (!isInitialized(input1)) {\n            input1 = asEuint16(0);\n        }\n        uint256 unwrappedInput1 = euint16.unwrap(input1);\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\n        FheOps(Precompiles.Fheos).req(Common.EUINT16_TFHE_GO, inputAsBytes);\n    }\n    /// @notice Performs the req operation on a ciphertext\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param input1 the input ciphertext\n    function req(euint32 input1) internal pure  {\n        if (!isInitialized(input1)) {\n            input1 = asEuint32(0);\n        }\n        uint256 unwrappedInput1 = euint32.unwrap(input1);\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\n        FheOps(Precompiles.Fheos).req(Common.EUINT32_TFHE_GO, inputAsBytes);\n    }\n    /// @notice This functions performs the div operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function div(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint8(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint8(0);\n        }\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).div);\n        return euint8.wrap(result);\n    }\n    /// @notice This functions performs the div operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function div(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint16(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint16(0);\n        }\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).div);\n        return euint16.wrap(result);\n    }\n    /// @notice This functions performs the div operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function div(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint32(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint32(0);\n        }\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).div);\n        return euint32.wrap(result);\n    }\n    /// @notice This functions performs the gt operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function gt(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint8(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint8(0);\n        }\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).gt);\n        return ebool.wrap(result);\n    }\n    /// @notice This functions performs the gt operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function gt(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint16(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint16(0);\n        }\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).gt);\n        return ebool.wrap(result);\n    }\n    /// @notice This functions performs the gt operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function gt(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint32(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint32(0);\n        }\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).gt);\n        return ebool.wrap(result);\n    }\n    /// @notice This functions performs the gte operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function gte(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint8(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint8(0);\n        }\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).gte);\n        return ebool.wrap(result);\n    }\n    /// @notice This functions performs the gte operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function gte(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint16(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint16(0);\n        }\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).gte);\n        return ebool.wrap(result);\n    }\n    /// @notice This functions performs the gte operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function gte(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint32(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint32(0);\n        }\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).gte);\n        return ebool.wrap(result);\n    }\n    /// @notice This functions performs the rem operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function rem(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint8(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint8(0);\n        }\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).rem);\n        return euint8.wrap(result);\n    }\n    /// @notice This functions performs the rem operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function rem(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint16(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint16(0);\n        }\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).rem);\n        return euint16.wrap(result);\n    }\n    /// @notice This functions performs the rem operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function rem(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint32(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint32(0);\n        }\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).rem);\n        return euint32.wrap(result);\n    }\n    /// @notice This functions performs the and operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function and(ebool lhs, ebool rhs) internal pure returns (ebool) {\n        if (!isInitialized(lhs)) {\n            lhs = asEbool(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEbool(0);\n        }\n        uint256 unwrappedInput1 = ebool.unwrap(lhs);\n        uint256 unwrappedInput2 = ebool.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EBOOL_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).and);\n        return ebool.wrap(result);\n    }\n    /// @notice This functions performs the and operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function and(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint8(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint8(0);\n        }\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).and);\n        return euint8.wrap(result);\n    }\n    /// @notice This functions performs the and operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function and(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint16(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint16(0);\n        }\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).and);\n        return euint16.wrap(result);\n    }\n    /// @notice This functions performs the and operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function and(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint32(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint32(0);\n        }\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).and);\n        return euint32.wrap(result);\n    }\n    /// @notice This functions performs the or operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function or(ebool lhs, ebool rhs) internal pure returns (ebool) {\n        if (!isInitialized(lhs)) {\n            lhs = asEbool(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEbool(0);\n        }\n        uint256 unwrappedInput1 = ebool.unwrap(lhs);\n        uint256 unwrappedInput2 = ebool.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EBOOL_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).or);\n        return ebool.wrap(result);\n    }\n    /// @notice This functions performs the or operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function or(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint8(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint8(0);\n        }\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).or);\n        return euint8.wrap(result);\n    }\n    /// @notice This functions performs the or operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function or(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint16(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint16(0);\n        }\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).or);\n        return euint16.wrap(result);\n    }\n    /// @notice This functions performs the or operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function or(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint32(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint32(0);\n        }\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).or);\n        return euint32.wrap(result);\n    }\n    /// @notice This functions performs the xor operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function xor(ebool lhs, ebool rhs) internal pure returns (ebool) {\n        if (!isInitialized(lhs)) {\n            lhs = asEbool(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEbool(0);\n        }\n        uint256 unwrappedInput1 = ebool.unwrap(lhs);\n        uint256 unwrappedInput2 = ebool.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EBOOL_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).xor);\n        return ebool.wrap(result);\n    }\n    /// @notice This functions performs the xor operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function xor(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint8(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint8(0);\n        }\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).xor);\n        return euint8.wrap(result);\n    }\n    /// @notice This functions performs the xor operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function xor(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint16(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint16(0);\n        }\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).xor);\n        return euint16.wrap(result);\n    }\n    /// @notice This functions performs the xor operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function xor(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint32(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint32(0);\n        }\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).xor);\n        return euint32.wrap(result);\n    }\n    /// @notice This functions performs the eq operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function eq(ebool lhs, ebool rhs) internal pure returns (ebool) {\n        if (!isInitialized(lhs)) {\n            lhs = asEbool(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEbool(0);\n        }\n        uint256 unwrappedInput1 = ebool.unwrap(lhs);\n        uint256 unwrappedInput2 = ebool.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EBOOL_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).eq);\n        return ebool.wrap(result);\n    }\n    /// @notice This functions performs the eq operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function eq(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint8(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint8(0);\n        }\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).eq);\n        return ebool.wrap(result);\n    }\n    /// @notice This functions performs the eq operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function eq(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint16(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint16(0);\n        }\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).eq);\n        return ebool.wrap(result);\n    }\n    /// @notice This functions performs the eq operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function eq(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint32(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint32(0);\n        }\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).eq);\n        return ebool.wrap(result);\n    }\n    /// @notice This functions performs the ne operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function ne(ebool lhs, ebool rhs) internal pure returns (ebool) {\n        if (!isInitialized(lhs)) {\n            lhs = asEbool(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEbool(0);\n        }\n        uint256 unwrappedInput1 = ebool.unwrap(lhs);\n        uint256 unwrappedInput2 = ebool.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EBOOL_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).ne);\n        return ebool.wrap(result);\n    }\n    /// @notice This functions performs the ne operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function ne(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint8(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint8(0);\n        }\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).ne);\n        return ebool.wrap(result);\n    }\n    /// @notice This functions performs the ne operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function ne(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint16(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint16(0);\n        }\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).ne);\n        return ebool.wrap(result);\n    }\n    /// @notice This functions performs the ne operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function ne(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint32(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint32(0);\n        }\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).ne);\n        return ebool.wrap(result);\n    }\n    /// @notice This functions performs the min operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function min(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint8(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint8(0);\n        }\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).min);\n        return euint8.wrap(result);\n    }\n    /// @notice This functions performs the min operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function min(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint16(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint16(0);\n        }\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).min);\n        return euint16.wrap(result);\n    }\n    /// @notice This functions performs the min operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function min(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint32(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint32(0);\n        }\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).min);\n        return euint32.wrap(result);\n    }\n    /// @notice This functions performs the max operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function max(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint8(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint8(0);\n        }\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).max);\n        return euint8.wrap(result);\n    }\n    /// @notice This functions performs the max operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function max(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint16(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint16(0);\n        }\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).max);\n        return euint16.wrap(result);\n    }\n    /// @notice This functions performs the max operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function max(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint32(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint32(0);\n        }\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).max);\n        return euint32.wrap(result);\n    }\n    /// @notice This functions performs the shl operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function shl(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint8(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint8(0);\n        }\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).shl);\n        return euint8.wrap(result);\n    }\n    /// @notice This functions performs the shl operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function shl(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint16(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint16(0);\n        }\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).shl);\n        return euint16.wrap(result);\n    }\n    /// @notice This functions performs the shl operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function shl(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint32(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint32(0);\n        }\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).shl);\n        return euint32.wrap(result);\n    }\n    /// @notice This functions performs the shr operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function shr(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint8(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint8(0);\n        }\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).shr);\n        return euint8.wrap(result);\n    }\n    /// @notice This functions performs the shr operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function shr(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint16(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint16(0);\n        }\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).shr);\n        return euint16.wrap(result);\n    }\n    /// @notice This functions performs the shr operation\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs The first input \n    /// @param rhs The second input\n    /// @return The result of the operation\n    function shr(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\n        if (!isInitialized(lhs)) {\n            lhs = asEuint32(0);\n        }\n        if (!isInitialized(rhs)) {\n            rhs = asEuint32(0);\n        }\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\n\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).shr);\n        return euint32.wrap(result);\n    }\n\n    /// @notice Performs the \"not\" for the ebool type\n    /// @dev Implemented by a workaround due to ebool being a euint8 type behind the scenes, therefore xor is needed to assure that not(true) = false and vise-versa\n    /// @param value input ebool ciphertext\n    /// @return Result of the not operation on `value` \n    function not(ebool value) internal pure returns (ebool) {\n        return xor(value, asEbool(true));\n    }\n    /// @notice Performs the not operation on a ciphertext\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param input1 the input ciphertext\n    function not(euint8 input1) internal pure returns (euint8) {\n        if (!isInitialized(input1)) {\n            input1 = asEuint8(0);\n        }\n        uint256 unwrappedInput1 = euint8.unwrap(input1);\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\n        bytes memory b = FheOps(Precompiles.Fheos).not(Common.EUINT8_TFHE_GO, inputAsBytes);\n        uint256 result = Impl.getValue(b);\n        return euint8.wrap(result);\n    }\n    /// @notice Performs the not operation on a ciphertext\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param input1 the input ciphertext\n    function not(euint16 input1) internal pure returns (euint16) {\n        if (!isInitialized(input1)) {\n            input1 = asEuint16(0);\n        }\n        uint256 unwrappedInput1 = euint16.unwrap(input1);\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\n        bytes memory b = FheOps(Precompiles.Fheos).not(Common.EUINT16_TFHE_GO, inputAsBytes);\n        uint256 result = Impl.getValue(b);\n        return euint16.wrap(result);\n    }\n    /// @notice Performs the not operation on a ciphertext\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param input1 the input ciphertext\n    function not(euint32 input1) internal pure returns (euint32) {\n        if (!isInitialized(input1)) {\n            input1 = asEuint32(0);\n        }\n        uint256 unwrappedInput1 = euint32.unwrap(input1);\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\n        bytes memory b = FheOps(Precompiles.Fheos).not(Common.EUINT32_TFHE_GO, inputAsBytes);\n        uint256 result = Impl.getValue(b);\n        return euint32.wrap(result);\n    }\n\n    // ********** TYPE CASTING ************* //\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an ebool\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\n    /// @return a ciphertext representation of the input\n    function asEbool(inEbool memory value) internal pure returns (ebool) {\n        return FHE.asEbool(value.data);\n    }\n    /// @notice Converts a ebool to an euint8\n    function asEuint8(ebool value) internal pure returns (euint8) {\n        return euint8.wrap(Impl.cast(Common.EBOOL_TFHE_GO, ebool.unwrap(value), Common.EUINT8_TFHE_GO));\n    }\n    /// @notice Converts a ebool to an euint16\n    function asEuint16(ebool value) internal pure returns (euint16) {\n        return euint16.wrap(Impl.cast(Common.EBOOL_TFHE_GO, ebool.unwrap(value), Common.EUINT16_TFHE_GO));\n    }\n    /// @notice Converts a ebool to an euint32\n    function asEuint32(ebool value) internal pure returns (euint32) {\n        return euint32.wrap(Impl.cast(Common.EBOOL_TFHE_GO, ebool.unwrap(value), Common.EUINT32_TFHE_GO));\n    }\n    \n    /// @notice Converts a euint8 to an ebool\n    function asEbool(euint8 value) internal pure returns (ebool) {\n        return ne(value, asEuint8(0));\n    }\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint8\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\n    /// @return a ciphertext representation of the input\n    function asEuint8(inEuint8 memory value) internal pure returns (euint8) {\n        return FHE.asEuint8(value.data);\n    }\n    /// @notice Converts a euint8 to an euint16\n    function asEuint16(euint8 value) internal pure returns (euint16) {\n        return euint16.wrap(Impl.cast(Common.EUINT8_TFHE_GO, euint8.unwrap(value), Common.EUINT16_TFHE_GO));\n    }\n    /// @notice Converts a euint8 to an euint32\n    function asEuint32(euint8 value) internal pure returns (euint32) {\n        return euint32.wrap(Impl.cast(Common.EUINT8_TFHE_GO, euint8.unwrap(value), Common.EUINT32_TFHE_GO));\n    }\n    \n    /// @notice Converts a euint16 to an ebool\n    function asEbool(euint16 value) internal pure returns (ebool) {\n        return ne(value, asEuint16(0));\n    }\n    /// @notice Converts a euint16 to an euint8\n    function asEuint8(euint16 value) internal pure returns (euint8) {\n        return euint8.wrap(Impl.cast(Common.EUINT16_TFHE_GO, euint16.unwrap(value), Common.EUINT8_TFHE_GO));\n    }\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint16\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\n    /// @return a ciphertext representation of the input\n    function asEuint16(inEuint16 memory value) internal pure returns (euint16) {\n        return FHE.asEuint16(value.data);\n    }\n    /// @notice Converts a euint16 to an euint32\n    function asEuint32(euint16 value) internal pure returns (euint32) {\n        return euint32.wrap(Impl.cast(Common.EUINT16_TFHE_GO, euint16.unwrap(value), Common.EUINT32_TFHE_GO));\n    }\n    \n    /// @notice Converts a euint32 to an ebool\n    function asEbool(euint32 value) internal pure returns (ebool) {\n        return ne(value, asEuint32(0));\n    }\n    /// @notice Converts a euint32 to an euint8\n    function asEuint8(euint32 value) internal pure returns (euint8) {\n        return euint8.wrap(Impl.cast(Common.EUINT32_TFHE_GO, euint32.unwrap(value), Common.EUINT8_TFHE_GO));\n    }\n    /// @notice Converts a euint32 to an euint16\n    function asEuint16(euint32 value) internal pure returns (euint16) {\n        return euint16.wrap(Impl.cast(Common.EUINT32_TFHE_GO, euint32.unwrap(value), Common.EUINT16_TFHE_GO));\n    }\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint32\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\n    /// @return a ciphertext representation of the input\n    function asEuint32(inEuint32 memory value) internal pure returns (euint32) {\n        return FHE.asEuint32(value.data);\n    }\n    /// @notice Converts a uint256 to an ebool\n    function asEbool(uint256 value) internal pure returns (ebool) {\n        return ebool.wrap(Impl.trivialEncrypt(value, Common.EBOOL_TFHE_GO));\n    }\n    /// @notice Converts a uint256 to an euint8\n    function asEuint8(uint256 value) internal pure returns (euint8) {\n        return euint8.wrap(Impl.trivialEncrypt(value, Common.EUINT8_TFHE_GO));\n    }\n    /// @notice Converts a uint256 to an euint16\n    function asEuint16(uint256 value) internal pure returns (euint16) {\n        return euint16.wrap(Impl.trivialEncrypt(value, Common.EUINT16_TFHE_GO));\n    }\n    /// @notice Converts a uint256 to an euint32\n    function asEuint32(uint256 value) internal pure returns (euint32) {\n        return euint32.wrap(Impl.trivialEncrypt(value, Common.EUINT32_TFHE_GO));\n    }\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an ebool\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\n    /// @return a ciphertext representation of the input\n    function asEbool(bytes memory value) internal pure returns (ebool) {\n        return ebool.wrap(Impl.verify(value, Common.EBOOL_TFHE_GO));\n    }\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint8\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\n    /// @return a ciphertext representation of the input\n    function asEuint8(bytes memory value) internal pure returns (euint8) {\n        return euint8.wrap(Impl.verify(value, Common.EUINT8_TFHE_GO));\n    }\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint16\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\n    /// @return a ciphertext representation of the input\n    function asEuint16(bytes memory value) internal pure returns (euint16) {\n        return euint16.wrap(Impl.verify(value, Common.EUINT16_TFHE_GO));\n    }\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint32\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\n    /// @return a ciphertext representation of the input\n    function asEuint32(bytes memory value) internal pure returns (euint32) {\n        return euint32.wrap(Impl.verify(value, Common.EUINT32_TFHE_GO));\n    }\n    /// @notice Converts a plaintext boolean value to a ciphertext ebool\n    /// @dev Privacy: The input value is public, therefore the ciphertext should be considered public and should be used\n    ///only for mathematical operations, not to represent data that should be private\n    /// @return A ciphertext representation of the input \n    function asEbool(bool value) internal pure returns (ebool) {\n        uint256 sVal = 0;\n        if (value) {\n            sVal = 1;\n        }\n\n        return asEbool(sVal);\n    }\n}\n\n// ********** OPERATOR OVERLOADING ************* //\n\nusing {operatorAddEuint8 as +} for euint8 global;\n/// @notice Performs the add operation\nfunction operatorAddEuint8(euint8 lhs, euint8 rhs) pure returns (euint8) {\n    return FHE.add(lhs, rhs);\n}\n\nusing {operatorAddEuint16 as +} for euint16 global;\n/// @notice Performs the add operation\nfunction operatorAddEuint16(euint16 lhs, euint16 rhs) pure returns (euint16) {\n    return FHE.add(lhs, rhs);\n}\n\nusing {operatorAddEuint32 as +} for euint32 global;\n/// @notice Performs the add operation\nfunction operatorAddEuint32(euint32 lhs, euint32 rhs) pure returns (euint32) {\n    return FHE.add(lhs, rhs);\n}\n\nusing {operatorSubEuint8 as -} for euint8 global;\n/// @notice Performs the sub operation\nfunction operatorSubEuint8(euint8 lhs, euint8 rhs) pure returns (euint8) {\n    return FHE.sub(lhs, rhs);\n}\n\nusing {operatorSubEuint16 as -} for euint16 global;\n/// @notice Performs the sub operation\nfunction operatorSubEuint16(euint16 lhs, euint16 rhs) pure returns (euint16) {\n    return FHE.sub(lhs, rhs);\n}\n\nusing {operatorSubEuint32 as -} for euint32 global;\n/// @notice Performs the sub operation\nfunction operatorSubEuint32(euint32 lhs, euint32 rhs) pure returns (euint32) {\n    return FHE.sub(lhs, rhs);\n}\n\nusing {operatorMulEuint8 as *} for euint8 global;\n/// @notice Performs the mul operation\nfunction operatorMulEuint8(euint8 lhs, euint8 rhs) pure returns (euint8) {\n    return FHE.mul(lhs, rhs);\n}\n\nusing {operatorMulEuint16 as *} for euint16 global;\n/// @notice Performs the mul operation\nfunction operatorMulEuint16(euint16 lhs, euint16 rhs) pure returns (euint16) {\n    return FHE.mul(lhs, rhs);\n}\n\nusing {operatorMulEuint32 as *} for euint32 global;\n/// @notice Performs the mul operation\nfunction operatorMulEuint32(euint32 lhs, euint32 rhs) pure returns (euint32) {\n    return FHE.mul(lhs, rhs);\n}\n\nusing {operatorDivEuint8 as /} for euint8 global;\n/// @notice Performs the div operation\nfunction operatorDivEuint8(euint8 lhs, euint8 rhs) pure returns (euint8) {\n    return FHE.div(lhs, rhs);\n}\n\nusing {operatorDivEuint16 as /} for euint16 global;\n/// @notice Performs the div operation\nfunction operatorDivEuint16(euint16 lhs, euint16 rhs) pure returns (euint16) {\n    return FHE.div(lhs, rhs);\n}\n\nusing {operatorDivEuint32 as /} for euint32 global;\n/// @notice Performs the div operation\nfunction operatorDivEuint32(euint32 lhs, euint32 rhs) pure returns (euint32) {\n    return FHE.div(lhs, rhs);\n}\n\nusing {operatorOrEbool as |} for ebool global;\n/// @notice Performs the or operation\nfunction operatorOrEbool(ebool lhs, ebool rhs) pure returns (ebool) {\n    return FHE.or(lhs, rhs);\n}\n\nusing {operatorOrEuint8 as |} for euint8 global;\n/// @notice Performs the or operation\nfunction operatorOrEuint8(euint8 lhs, euint8 rhs) pure returns (euint8) {\n    return FHE.or(lhs, rhs);\n}\n\nusing {operatorOrEuint16 as |} for euint16 global;\n/// @notice Performs the or operation\nfunction operatorOrEuint16(euint16 lhs, euint16 rhs) pure returns (euint16) {\n    return FHE.or(lhs, rhs);\n}\n\nusing {operatorOrEuint32 as |} for euint32 global;\n/// @notice Performs the or operation\nfunction operatorOrEuint32(euint32 lhs, euint32 rhs) pure returns (euint32) {\n    return FHE.or(lhs, rhs);\n}\n\nusing {operatorAndEbool as &} for ebool global;\n/// @notice Performs the and operation\nfunction operatorAndEbool(ebool lhs, ebool rhs) pure returns (ebool) {\n    return FHE.and(lhs, rhs);\n}\n\nusing {operatorAndEuint8 as &} for euint8 global;\n/// @notice Performs the and operation\nfunction operatorAndEuint8(euint8 lhs, euint8 rhs) pure returns (euint8) {\n    return FHE.and(lhs, rhs);\n}\n\nusing {operatorAndEuint16 as &} for euint16 global;\n/// @notice Performs the and operation\nfunction operatorAndEuint16(euint16 lhs, euint16 rhs) pure returns (euint16) {\n    return FHE.and(lhs, rhs);\n}\n\nusing {operatorAndEuint32 as &} for euint32 global;\n/// @notice Performs the and operation\nfunction operatorAndEuint32(euint32 lhs, euint32 rhs) pure returns (euint32) {\n    return FHE.and(lhs, rhs);\n}\n\nusing {operatorXorEbool as ^} for ebool global;\n/// @notice Performs the xor operation\nfunction operatorXorEbool(ebool lhs, ebool rhs) pure returns (ebool) {\n    return FHE.xor(lhs, rhs);\n}\n\nusing {operatorXorEuint8 as ^} for euint8 global;\n/// @notice Performs the xor operation\nfunction operatorXorEuint8(euint8 lhs, euint8 rhs) pure returns (euint8) {\n    return FHE.xor(lhs, rhs);\n}\n\nusing {operatorXorEuint16 as ^} for euint16 global;\n/// @notice Performs the xor operation\nfunction operatorXorEuint16(euint16 lhs, euint16 rhs) pure returns (euint16) {\n    return FHE.xor(lhs, rhs);\n}\n\nusing {operatorXorEuint32 as ^} for euint32 global;\n/// @notice Performs the xor operation\nfunction operatorXorEuint32(euint32 lhs, euint32 rhs) pure returns (euint32) {\n    return FHE.xor(lhs, rhs);\n}\n\nusing {operatorRemEuint8 as %} for euint8 global;\n/// @notice Performs the rem operation\nfunction operatorRemEuint8(euint8 lhs, euint8 rhs) pure returns (euint8) {\n    return FHE.rem(lhs, rhs);\n}\n\nusing {operatorRemEuint16 as %} for euint16 global;\n/// @notice Performs the rem operation\nfunction operatorRemEuint16(euint16 lhs, euint16 rhs) pure returns (euint16) {\n    return FHE.rem(lhs, rhs);\n}\n\nusing {operatorRemEuint32 as %} for euint32 global;\n/// @notice Performs the rem operation\nfunction operatorRemEuint32(euint32 lhs, euint32 rhs) pure returns (euint32) {\n    return FHE.rem(lhs, rhs);\n}\n\n// ********** BINDING DEFS ************* //\n\nusing BindingsEbool for ebool global;\nlibrary BindingsEbool {\n    \n    /// @notice Performs the eq operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type ebool\n    /// @return the result of the eq\n    function eq(ebool lhs, ebool rhs) internal pure returns (ebool) {\n        return FHE.eq(lhs, rhs);\n    }\n    \n    /// @notice Performs the ne operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type ebool\n    /// @return the result of the ne\n    function ne(ebool lhs, ebool rhs) internal pure returns (ebool) {\n        return FHE.ne(lhs, rhs);\n    }\n    \n    /// @notice Performs the and operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type ebool\n    /// @return the result of the and\n    function and(ebool lhs, ebool rhs) internal pure returns (ebool) {\n        return FHE.and(lhs, rhs);\n    }\n    \n    /// @notice Performs the or operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type ebool\n    /// @return the result of the or\n    function or(ebool lhs, ebool rhs) internal pure returns (ebool) {\n        return FHE.or(lhs, rhs);\n    }\n    \n    /// @notice Performs the xor operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type ebool\n    /// @return the result of the xor\n    function xor(ebool lhs, ebool rhs) internal pure returns (ebool) {\n        return FHE.xor(lhs, rhs);\n    }\n    function toU8(ebool value) internal pure returns (euint8) {\n        return FHE.asEuint8(value);\n    }\n    function toU16(ebool value) internal pure returns (euint16) {\n        return FHE.asEuint16(value);\n    }\n    function toU32(ebool value) internal pure returns (euint32) {\n        return FHE.asEuint32(value);\n    }\n    function seal(ebool value, bytes32 publicKey) internal pure returns (bytes memory) {\n        return FHE.sealoutput(value, publicKey);\n    }\n}\n\nusing BindingsEuint8 for euint8 global;\nlibrary BindingsEuint8 {\n    \n    /// @notice Performs the add operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @return the result of the add\n    function add(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\n        return FHE.add(lhs, rhs);\n    }\n    \n    /// @notice Performs the mul operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @return the result of the mul\n    function mul(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\n        return FHE.mul(lhs, rhs);\n    }\n    \n    /// @notice Performs the div operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @return the result of the div\n    function div(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\n        return FHE.div(lhs, rhs);\n    }\n    \n    /// @notice Performs the sub operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @return the result of the sub\n    function sub(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\n        return FHE.sub(lhs, rhs);\n    }\n    \n    /// @notice Performs the eq operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @return the result of the eq\n    function eq(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\n        return FHE.eq(lhs, rhs);\n    }\n    \n    /// @notice Performs the ne operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @return the result of the ne\n    function ne(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\n        return FHE.ne(lhs, rhs);\n    }\n    \n    /// @notice Performs the and operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @return the result of the and\n    function and(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\n        return FHE.and(lhs, rhs);\n    }\n    \n    /// @notice Performs the or operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @return the result of the or\n    function or(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\n        return FHE.or(lhs, rhs);\n    }\n    \n    /// @notice Performs the xor operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @return the result of the xor\n    function xor(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\n        return FHE.xor(lhs, rhs);\n    }\n    \n    /// @notice Performs the gt operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @return the result of the gt\n    function gt(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\n        return FHE.gt(lhs, rhs);\n    }\n    \n    /// @notice Performs the gte operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @return the result of the gte\n    function gte(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\n        return FHE.gte(lhs, rhs);\n    }\n    \n    /// @notice Performs the lt operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @return the result of the lt\n    function lt(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\n        return FHE.lt(lhs, rhs);\n    }\n    \n    /// @notice Performs the lte operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @return the result of the lte\n    function lte(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\n        return FHE.lte(lhs, rhs);\n    }\n    \n    /// @notice Performs the rem operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @return the result of the rem\n    function rem(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\n        return FHE.rem(lhs, rhs);\n    }\n    \n    /// @notice Performs the max operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @return the result of the max\n    function max(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\n        return FHE.max(lhs, rhs);\n    }\n    \n    /// @notice Performs the min operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @return the result of the min\n    function min(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\n        return FHE.min(lhs, rhs);\n    }\n    \n    /// @notice Performs the shl operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @return the result of the shl\n    function shl(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\n        return FHE.shl(lhs, rhs);\n    }\n    \n    /// @notice Performs the shr operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint8\n    /// @return the result of the shr\n    function shr(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\n        return FHE.shr(lhs, rhs);\n    }\n    function toBool(euint8 value) internal pure returns (ebool) {\n        return FHE.asEbool(value);\n    }\n    function toU16(euint8 value) internal pure returns (euint16) {\n        return FHE.asEuint16(value);\n    }\n    function toU32(euint8 value) internal pure returns (euint32) {\n        return FHE.asEuint32(value);\n    }\n    function seal(euint8 value, bytes32 publicKey) internal pure returns (bytes memory) {\n        return FHE.sealoutput(value, publicKey);\n    }\n}\n\nusing BindingsEuint16 for euint16 global;\nlibrary BindingsEuint16 {\n    \n    /// @notice Performs the add operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @return the result of the add\n    function add(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\n        return FHE.add(lhs, rhs);\n    }\n    \n    /// @notice Performs the mul operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @return the result of the mul\n    function mul(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\n        return FHE.mul(lhs, rhs);\n    }\n    \n    /// @notice Performs the div operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @return the result of the div\n    function div(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\n        return FHE.div(lhs, rhs);\n    }\n    \n    /// @notice Performs the sub operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @return the result of the sub\n    function sub(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\n        return FHE.sub(lhs, rhs);\n    }\n    \n    /// @notice Performs the eq operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @return the result of the eq\n    function eq(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\n        return FHE.eq(lhs, rhs);\n    }\n    \n    /// @notice Performs the ne operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @return the result of the ne\n    function ne(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\n        return FHE.ne(lhs, rhs);\n    }\n    \n    /// @notice Performs the and operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @return the result of the and\n    function and(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\n        return FHE.and(lhs, rhs);\n    }\n    \n    /// @notice Performs the or operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @return the result of the or\n    function or(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\n        return FHE.or(lhs, rhs);\n    }\n    \n    /// @notice Performs the xor operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @return the result of the xor\n    function xor(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\n        return FHE.xor(lhs, rhs);\n    }\n    \n    /// @notice Performs the gt operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @return the result of the gt\n    function gt(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\n        return FHE.gt(lhs, rhs);\n    }\n    \n    /// @notice Performs the gte operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @return the result of the gte\n    function gte(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\n        return FHE.gte(lhs, rhs);\n    }\n    \n    /// @notice Performs the lt operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @return the result of the lt\n    function lt(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\n        return FHE.lt(lhs, rhs);\n    }\n    \n    /// @notice Performs the lte operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @return the result of the lte\n    function lte(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\n        return FHE.lte(lhs, rhs);\n    }\n    \n    /// @notice Performs the rem operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @return the result of the rem\n    function rem(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\n        return FHE.rem(lhs, rhs);\n    }\n    \n    /// @notice Performs the max operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @return the result of the max\n    function max(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\n        return FHE.max(lhs, rhs);\n    }\n    \n    /// @notice Performs the min operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @return the result of the min\n    function min(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\n        return FHE.min(lhs, rhs);\n    }\n    \n    /// @notice Performs the shl operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @return the result of the shl\n    function shl(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\n        return FHE.shl(lhs, rhs);\n    }\n    \n    /// @notice Performs the shr operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint16\n    /// @return the result of the shr\n    function shr(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\n        return FHE.shr(lhs, rhs);\n    }\n    function toBool(euint16 value) internal pure returns (ebool) {\n        return FHE.asEbool(value);\n    }\n    function toU8(euint16 value) internal pure returns (euint8) {\n        return FHE.asEuint8(value);\n    }\n    function toU32(euint16 value) internal pure returns (euint32) {\n        return FHE.asEuint32(value);\n    }\n    function seal(euint16 value, bytes32 publicKey) internal pure returns (bytes memory) {\n        return FHE.sealoutput(value, publicKey);\n    }\n}\n\nusing BindingsEuint32 for euint32 global;\nlibrary BindingsEuint32 {\n    \n    /// @notice Performs the add operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @return the result of the add\n    function add(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\n        return FHE.add(lhs, rhs);\n    }\n    \n    /// @notice Performs the mul operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @return the result of the mul\n    function mul(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\n        return FHE.mul(lhs, rhs);\n    }\n    \n    /// @notice Performs the div operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @return the result of the div\n    function div(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\n        return FHE.div(lhs, rhs);\n    }\n    \n    /// @notice Performs the sub operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @return the result of the sub\n    function sub(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\n        return FHE.sub(lhs, rhs);\n    }\n    \n    /// @notice Performs the eq operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @return the result of the eq\n    function eq(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\n        return FHE.eq(lhs, rhs);\n    }\n    \n    /// @notice Performs the ne operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @return the result of the ne\n    function ne(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\n        return FHE.ne(lhs, rhs);\n    }\n    \n    /// @notice Performs the and operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @return the result of the and\n    function and(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\n        return FHE.and(lhs, rhs);\n    }\n    \n    /// @notice Performs the or operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @return the result of the or\n    function or(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\n        return FHE.or(lhs, rhs);\n    }\n    \n    /// @notice Performs the xor operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @return the result of the xor\n    function xor(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\n        return FHE.xor(lhs, rhs);\n    }\n    \n    /// @notice Performs the gt operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @return the result of the gt\n    function gt(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\n        return FHE.gt(lhs, rhs);\n    }\n    \n    /// @notice Performs the gte operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @return the result of the gte\n    function gte(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\n        return FHE.gte(lhs, rhs);\n    }\n    \n    /// @notice Performs the lt operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @return the result of the lt\n    function lt(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\n        return FHE.lt(lhs, rhs);\n    }\n    \n    /// @notice Performs the lte operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @return the result of the lte\n    function lte(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\n        return FHE.lte(lhs, rhs);\n    }\n    \n    /// @notice Performs the rem operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @return the result of the rem\n    function rem(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\n        return FHE.rem(lhs, rhs);\n    }\n    \n    /// @notice Performs the max operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @return the result of the max\n    function max(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\n        return FHE.max(lhs, rhs);\n    }\n    \n    /// @notice Performs the min operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @return the result of the min\n    function min(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\n        return FHE.min(lhs, rhs);\n    }\n    \n    /// @notice Performs the shl operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @return the result of the shl\n    function shl(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\n        return FHE.shl(lhs, rhs);\n    }\n    \n    /// @notice Performs the shr operation\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\n    /// @param lhs input of type euint32\n    /// @return the result of the shr\n    function shr(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\n        return FHE.shr(lhs, rhs);\n    }\n    function toBool(euint32 value) internal pure returns (ebool) {\n        return FHE.asEbool(value);\n    }\n    function toU8(euint32 value) internal pure returns (euint8) {\n        return FHE.asEuint8(value);\n    }\n    function toU16(euint32 value) internal pure returns (euint16) {\n        return FHE.asEuint16(value);\n    }\n    function seal(euint32 value, bytes32 publicKey) internal pure returns (bytes memory) {\n        return FHE.sealoutput(value, publicKey);\n    }\n}"
    },
    "@fhenixprotocol/contracts/FheOS.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\n// solhint-disable one-contract-per-file\npragma solidity >=0.8.13 <0.9.0;\n\nlibrary Precompiles {\n    //solhint-disable const-name-snakecase\n    address public constant Fheos = address(128);\n}\n\ninterface FheOps {\n    function add(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\n    function verify(uint8 utype, bytes memory input) external pure returns (bytes memory);\n    function sealOutput(uint8 utype, bytes memory ctHash, bytes memory pk) external pure returns (bytes memory);\n    function decrypt(uint8 utype, bytes memory input) external pure returns (uint256);\n    function lte(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\n    function sub(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\n    function mul(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\n    function lt(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\n    function select(uint8 utype, bytes memory controlHash, bytes memory ifTrueHash, bytes memory ifFalseHash) external pure returns (bytes memory);\n    function req(uint8 utype, bytes memory input) external pure returns (bytes memory);\n    function cast(uint8 utype, bytes memory input, uint8 toType) external pure returns (bytes memory);\n    function trivialEncrypt(bytes memory input, uint8 toType) external pure returns (bytes memory);\n    function div(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\n    function gt(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\n    function gte(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\n    function rem(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\n    function and(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\n    function or(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\n    function xor(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\n    function eq(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\n    function ne(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\n    function min(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\n    function max(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\n    function shl(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\n    function shr(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\n    function not(uint8 utype, bytes memory value) external pure returns (bytes memory);\n    function getNetworkPublicKey() external pure returns (bytes memory);\n}"
    },
    "contracts/test/SimpleFHE.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.19;\n\nimport \"@fhenixprotocol/contracts/FHE.sol\";\n\ncontract SimpleFHE {\n    uint256 public x;\n\n    function changeValue(inEuint32 calldata _x) external {\n        euint32 y = FHE.asEuint32(_x);\n        x = x + FHE.decrypt(y);\n    } \n}"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}