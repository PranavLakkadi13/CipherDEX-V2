{
  "address": "0x06fcddF564232f9B8F06293969Fb0d947670A67c",
  "abi": [
    {
      "inputs": [],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            }
          ],
          "internalType": "struct inEuint32",
          "name": "_amount0",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            }
          ],
          "internalType": "struct inEuint32",
          "name": "_amount1",
          "type": "tuple"
        }
      ],
      "name": "addLiquidity",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "shares",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "balanceOf",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "factory",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_token0",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_token1",
          "type": "address"
        }
      ],
      "name": "initialize",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            }
          ],
          "internalType": "struct inEuint32",
          "name": "_shares",
          "type": "tuple"
        }
      ],
      "name": "removeLiquidity",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "amount0",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amount1",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "reserve0",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "reserve1",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_tokenIn",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            }
          ],
          "internalType": "struct inEuint32",
          "name": "_amountIn",
          "type": "tuple"
        }
      ],
      "name": "swap",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "amountOut",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "token0",
      "outputs": [
        {
          "internalType": "contract IERC20",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "token1",
      "outputs": [
        {
          "internalType": "contract IERC20",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "totalSupply",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x8e4a9ed00f6d525c4f8ff55526646f5af33c9ccdcf9a2c13fadb650a0885bfb7",
  "receipt": {
    "to": null,
    "from": "0x1B150538E943F00127929f7eeB65754f7beB0B6d",
    "contractAddress": "0x06fcddF564232f9B8F06293969Fb0d947670A67c",
    "transactionIndex": 1,
    "gasUsed": "1703308",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x81c45c9aecc1a6a19e420fdc69b4b429d7d5702a0857342ba61c68225c454652",
    "transactionHash": "0x8e4a9ed00f6d525c4f8ff55526646f5af33c9ccdcf9a2c13fadb650a0885bfb7",
    "logs": [],
    "blockNumber": 1097,
    "cumulativeGasUsed": "1703308",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 9,
  "solcInputHash": "3f17791f8ee282a674d5756575925934",
  "metadata": "{\"compiler\":{\"version\":\"0.8.19+commit.7dd6d404\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct inEuint32\",\"name\":\"_amount0\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct inEuint32\",\"name\":\"_amount1\",\"type\":\"tuple\"}],\"name\":\"addLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token1\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct inEuint32\",\"name\":\"_shares\",\"type\":\"tuple\"}],\"name\":\"removeLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserve0\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserve1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct inEuint32\",\"name\":\"_amountIn\",\"type\":\"tuple\"}],\"name\":\"swap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token0\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token1\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/PairFHE.sol\":\"Pair\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"@fhenixprotocol/contracts/FHE.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\n// solhint-disable one-contract-per-file\\n\\npragma solidity >=0.8.19 <0.9.0;\\n\\nimport {Precompiles, FheOps} from \\\"./FheOS.sol\\\";\\n\\ntype ebool is uint256;\\ntype euint8 is uint256;\\ntype euint16 is uint256;\\ntype euint32 is uint256;\\n\\nstruct inEbool {\\n    bytes data;\\n}\\nstruct inEuint8 {\\n    bytes data;\\n}\\nstruct inEuint16 {\\n    bytes data;\\n}\\nstruct inEuint32 {\\n    bytes data;\\n}\\n\\nlibrary Common {\\n    // Values used to communicate types to the runtime.\\n    uint8 internal constant EBOOL_TFHE_GO = 0;\\n    uint8 internal constant EUINT8_TFHE_GO = 0;\\n    uint8 internal constant EUINT16_TFHE_GO = 1;\\n    uint8 internal constant EUINT32_TFHE_GO = 2;\\n\\n    function bigIntToBool(uint256 i) internal pure returns (bool) {\\n        return (i > 0);\\n    }\\n\\n    function bigIntToUint8(uint256 i) internal pure returns (uint8) {\\n        return uint8(i);\\n    }\\n\\n    function bigIntToUint16(uint256 i) internal pure returns (uint16) {\\n        return uint16(i);\\n    }\\n\\n    function bigIntToUint32(uint256 i) internal pure returns (uint32) {\\n        return uint32(i);\\n    }\\n\\n    function bigIntToUint64(uint256 i) internal pure returns (uint64) {\\n        return uint64(i);\\n    }\\n\\n    function bigIntToUint128(uint256 i) internal pure returns (uint128) {\\n        return uint128(i);\\n    }\\n\\n    function bigIntToUint256(uint256 i) internal pure returns (uint256) {\\n        return i;\\n    }\\n    \\n    function toBytes(uint256 x) internal pure returns (bytes memory b) {\\n        b = new bytes(32);\\n        assembly { mstore(add(b, 32), x) }\\n    }\\n    \\n}\\n\\nlibrary Impl {\\n    function sealoutput(uint8 utype, uint256 ciphertext, bytes32 publicKey) internal pure returns (bytes memory reencrypted) {\\n        // Call the sealoutput precompile.\\n        reencrypted = FheOps(Precompiles.Fheos).sealOutput(utype, Common.toBytes(ciphertext), bytes.concat(publicKey));\\n\\n        return reencrypted;\\n    }\\n\\n    function verify(bytes memory _ciphertextBytes, uint8 _toType) internal pure returns (uint256 result) {\\n        bytes memory output;\\n\\n        // Call the verify precompile.\\n        output = FheOps(Precompiles.Fheos).verify(_toType, _ciphertextBytes);\\n        result = getValue(output);\\n    }\\n\\n    function cast(uint8 utype, uint256 ciphertext, uint8 toType) internal pure returns (uint256 result) {\\n        bytes memory output;\\n\\n        // Call the cast precompile.\\n        output = FheOps(Precompiles.Fheos).cast(utype, Common.toBytes(ciphertext), toType);\\n        result = getValue(output);\\n    }\\n\\n    function getValue(bytes memory a) internal pure returns (uint256 value) {\\n        assembly {\\n            value := mload(add(a, 0x20))\\n        }\\n    }\\n\\n    function trivialEncrypt(uint256 value, uint8 toType) internal pure returns (uint256 result) {\\n        bytes memory output;\\n\\n        // Call the trivialEncrypt precompile.\\n        output = FheOps(Precompiles.Fheos).trivialEncrypt(Common.toBytes(value), toType);\\n\\n        result = getValue(output);\\n    }\\n\\n    function select(uint8 utype, uint256 control, uint256 ifTrue, uint256 ifFalse) internal pure returns (uint256 result) {\\n        bytes memory output;\\n\\n        // Call the trivialEncrypt precompile.\\n        output = FheOps(Precompiles.Fheos).select(utype, Common.toBytes(control), Common.toBytes(ifTrue), Common.toBytes(ifFalse));\\n\\n        result = getValue(output);\\n    }\\n}\\n\\nlibrary FHE {\\n    euint8 public constant NIL8 = euint8.wrap(0);\\n    euint16 public constant NIL16 = euint16.wrap(0);\\n    euint32 public constant NIL32 = euint32.wrap(0);\\n\\n    // Return true if the encrypted integer is initialized and false otherwise.\\n    function isInitialized(ebool v) internal pure returns (bool) {\\n        return ebool.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the encrypted integer is initialized and false otherwise.\\n    function isInitialized(euint8 v) internal pure returns (bool) {\\n        return euint8.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the encrypted integer is initialized and false otherwise.\\n    function isInitialized(euint16 v) internal pure returns (bool) {\\n        return euint16.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the encrypted integer is initialized and false otherwise.\\n    function isInitialized(euint32 v) internal pure returns (bool) {\\n        return euint32.unwrap(v) != 0;\\n    }\\n\\n    function getValue(bytes memory a) private pure returns (uint256 value) {\\n        assembly {\\n            value := mload(add(a, 0x20))\\n        }\\n    }\\n    \\n    function mathHelper(\\n        uint8 utype,\\n        uint256 lhs,\\n        uint256 rhs,\\n        function(uint8, bytes memory, bytes memory) external pure returns (bytes memory) impl\\n    ) internal pure returns (uint256 result) {\\n        bytes memory output;\\n        output = impl(utype, Common.toBytes(lhs), Common.toBytes(rhs));\\n        result = getValue(output);\\n    }\\n    \\n    /// @notice This functions performs the add operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function add(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).add);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the add operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function add(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).add);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the add operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function add(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).add);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice performs the sealoutput function on a ebool ciphertext. This operation returns the plaintext value, sealed for the public key provided \\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param value Ciphertext to decrypt and seal\\n    /// @param publicKey Public Key that will receive the sealed plaintext\\n    /// @return Plaintext input, sealed for the owner of `publicKey`\\n    function sealoutput(ebool value, bytes32 publicKey) internal pure returns (bytes memory) {\\n        if (!isInitialized(value)) {\\n            value = asEbool(0);\\n        }\\n        uint256 unwrapped = ebool.unwrap(value);\\n\\n        return Impl.sealoutput(Common.EBOOL_TFHE_GO, unwrapped, publicKey);\\n    }\\n    /// @notice performs the sealoutput function on a euint8 ciphertext. This operation returns the plaintext value, sealed for the public key provided \\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param value Ciphertext to decrypt and seal\\n    /// @param publicKey Public Key that will receive the sealed plaintext\\n    /// @return Plaintext input, sealed for the owner of `publicKey`\\n    function sealoutput(euint8 value, bytes32 publicKey) internal pure returns (bytes memory) {\\n        if (!isInitialized(value)) {\\n            value = asEuint8(0);\\n        }\\n        uint256 unwrapped = euint8.unwrap(value);\\n\\n        return Impl.sealoutput(Common.EUINT8_TFHE_GO, unwrapped, publicKey);\\n    }\\n    /// @notice performs the sealoutput function on a euint16 ciphertext. This operation returns the plaintext value, sealed for the public key provided \\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param value Ciphertext to decrypt and seal\\n    /// @param publicKey Public Key that will receive the sealed plaintext\\n    /// @return Plaintext input, sealed for the owner of `publicKey`\\n    function sealoutput(euint16 value, bytes32 publicKey) internal pure returns (bytes memory) {\\n        if (!isInitialized(value)) {\\n            value = asEuint16(0);\\n        }\\n        uint256 unwrapped = euint16.unwrap(value);\\n\\n        return Impl.sealoutput(Common.EUINT16_TFHE_GO, unwrapped, publicKey);\\n    }\\n    /// @notice performs the sealoutput function on a euint32 ciphertext. This operation returns the plaintext value, sealed for the public key provided \\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param value Ciphertext to decrypt and seal\\n    /// @param publicKey Public Key that will receive the sealed plaintext\\n    /// @return Plaintext input, sealed for the owner of `publicKey`\\n    function sealoutput(euint32 value, bytes32 publicKey) internal pure returns (bytes memory) {\\n        if (!isInitialized(value)) {\\n            value = asEuint32(0);\\n        }\\n        uint256 unwrapped = euint32.unwrap(value);\\n\\n        return Impl.sealoutput(Common.EUINT32_TFHE_GO, unwrapped, publicKey);\\n    }\\n    /// @notice Performs the decrypt operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function decrypt(ebool input1) internal pure returns (bool) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEbool(0);\\n        }\\n        uint256 unwrappedInput1 = ebool.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        uint256 result = FheOps(Precompiles.Fheos).decrypt(Common.EBOOL_TFHE_GO, inputAsBytes);\\n        return Common.bigIntToBool(result);\\n    }\\n    /// @notice Performs the decrypt operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function decrypt(euint8 input1) internal pure returns (uint8) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        uint256 result = FheOps(Precompiles.Fheos).decrypt(Common.EUINT8_TFHE_GO, inputAsBytes);\\n        return Common.bigIntToUint8(result);\\n    }\\n    /// @notice Performs the decrypt operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function decrypt(euint16 input1) internal pure returns (uint16) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        uint256 result = FheOps(Precompiles.Fheos).decrypt(Common.EUINT16_TFHE_GO, inputAsBytes);\\n        return Common.bigIntToUint16(result);\\n    }\\n    /// @notice Performs the decrypt operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function decrypt(euint32 input1) internal pure returns (uint32) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        uint256 result = FheOps(Precompiles.Fheos).decrypt(Common.EUINT32_TFHE_GO, inputAsBytes);\\n        return Common.bigIntToUint32(result);\\n    }\\n    /// @notice This functions performs the lte operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function lte(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).lte);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the lte operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function lte(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).lte);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the lte operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function lte(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).lte);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the sub operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function sub(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).sub);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the sub operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function sub(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).sub);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the sub operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function sub(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).sub);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice This functions performs the mul operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function mul(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).mul);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the mul operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function mul(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).mul);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the mul operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function mul(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).mul);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice This functions performs the lt operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function lt(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).lt);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the lt operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function lt(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).lt);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the lt operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function lt(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).lt);\\n        return ebool.wrap(result);\\n    }\\n\\n    function select(ebool input1, ebool input2, ebool input3) internal pure returns (ebool) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEbool(0);\\n        }\\n        if (!isInitialized(input2)) {\\n            input2 = asEbool(0);\\n        }\\n        if (!isInitialized(input3)) {\\n            input3 = asEbool(0);\\n        }\\n\\n        uint256 unwrappedInput1 = ebool.unwrap(input1);\\n        uint256 unwrappedInput2 = ebool.unwrap(input2);\\n        uint256 unwrappedInput3 = ebool.unwrap(input3);\\n\\n        uint256 result = Impl.select(Common.EBOOL_TFHE_GO, unwrappedInput1, unwrappedInput2, unwrappedInput3);\\n        return ebool.wrap(result);\\n    }\\n\\n    function select(ebool input1, euint8 input2, euint8 input3) internal pure returns (euint8) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEbool(0);\\n        }\\n        if (!isInitialized(input2)) {\\n            input2 = asEuint8(0);\\n        }\\n        if (!isInitialized(input3)) {\\n            input3 = asEuint8(0);\\n        }\\n\\n        uint256 unwrappedInput1 = ebool.unwrap(input1);\\n        uint256 unwrappedInput2 = euint8.unwrap(input2);\\n        uint256 unwrappedInput3 = euint8.unwrap(input3);\\n\\n        uint256 result = Impl.select(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, unwrappedInput3);\\n        return euint8.wrap(result);\\n    }\\n\\n    function select(ebool input1, euint16 input2, euint16 input3) internal pure returns (euint16) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEbool(0);\\n        }\\n        if (!isInitialized(input2)) {\\n            input2 = asEuint16(0);\\n        }\\n        if (!isInitialized(input3)) {\\n            input3 = asEuint16(0);\\n        }\\n\\n        uint256 unwrappedInput1 = ebool.unwrap(input1);\\n        uint256 unwrappedInput2 = euint16.unwrap(input2);\\n        uint256 unwrappedInput3 = euint16.unwrap(input3);\\n\\n        uint256 result = Impl.select(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, unwrappedInput3);\\n        return euint16.wrap(result);\\n    }\\n\\n    function select(ebool input1, euint32 input2, euint32 input3) internal pure returns (euint32) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEbool(0);\\n        }\\n        if (!isInitialized(input2)) {\\n            input2 = asEuint32(0);\\n        }\\n        if (!isInitialized(input3)) {\\n            input3 = asEuint32(0);\\n        }\\n\\n        uint256 unwrappedInput1 = ebool.unwrap(input1);\\n        uint256 unwrappedInput2 = euint32.unwrap(input2);\\n        uint256 unwrappedInput3 = euint32.unwrap(input3);\\n\\n        uint256 result = Impl.select(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, unwrappedInput3);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice Performs the req operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function req(ebool input1) internal pure  {\\n        if (!isInitialized(input1)) {\\n            input1 = asEbool(0);\\n        }\\n        uint256 unwrappedInput1 = ebool.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        FheOps(Precompiles.Fheos).req(Common.EBOOL_TFHE_GO, inputAsBytes);\\n    }\\n    /// @notice Performs the req operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function req(euint8 input1) internal pure  {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        FheOps(Precompiles.Fheos).req(Common.EUINT8_TFHE_GO, inputAsBytes);\\n    }\\n    /// @notice Performs the req operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function req(euint16 input1) internal pure  {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        FheOps(Precompiles.Fheos).req(Common.EUINT16_TFHE_GO, inputAsBytes);\\n    }\\n    /// @notice Performs the req operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function req(euint32 input1) internal pure  {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        FheOps(Precompiles.Fheos).req(Common.EUINT32_TFHE_GO, inputAsBytes);\\n    }\\n    /// @notice This functions performs the div operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function div(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).div);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the div operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function div(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).div);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the div operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function div(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).div);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice This functions performs the gt operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function gt(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).gt);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the gt operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function gt(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).gt);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the gt operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function gt(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).gt);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the gte operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function gte(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).gte);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the gte operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function gte(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).gte);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the gte operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function gte(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).gte);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the rem operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function rem(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).rem);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the rem operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function rem(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).rem);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the rem operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function rem(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).rem);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice This functions performs the and operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function and(ebool lhs, ebool rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEbool(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEbool(0);\\n        }\\n        uint256 unwrappedInput1 = ebool.unwrap(lhs);\\n        uint256 unwrappedInput2 = ebool.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EBOOL_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).and);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the and operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function and(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).and);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the and operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function and(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).and);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the and operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function and(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).and);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice This functions performs the or operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function or(ebool lhs, ebool rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEbool(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEbool(0);\\n        }\\n        uint256 unwrappedInput1 = ebool.unwrap(lhs);\\n        uint256 unwrappedInput2 = ebool.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EBOOL_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).or);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the or operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function or(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).or);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the or operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function or(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).or);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the or operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function or(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).or);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice This functions performs the xor operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function xor(ebool lhs, ebool rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEbool(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEbool(0);\\n        }\\n        uint256 unwrappedInput1 = ebool.unwrap(lhs);\\n        uint256 unwrappedInput2 = ebool.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EBOOL_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).xor);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the xor operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function xor(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).xor);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the xor operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function xor(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).xor);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the xor operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function xor(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).xor);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice This functions performs the eq operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function eq(ebool lhs, ebool rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEbool(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEbool(0);\\n        }\\n        uint256 unwrappedInput1 = ebool.unwrap(lhs);\\n        uint256 unwrappedInput2 = ebool.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EBOOL_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).eq);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the eq operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function eq(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).eq);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the eq operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function eq(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).eq);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the eq operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function eq(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).eq);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the ne operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function ne(ebool lhs, ebool rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEbool(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEbool(0);\\n        }\\n        uint256 unwrappedInput1 = ebool.unwrap(lhs);\\n        uint256 unwrappedInput2 = ebool.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EBOOL_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).ne);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the ne operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function ne(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).ne);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the ne operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function ne(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).ne);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the ne operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function ne(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).ne);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the min operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function min(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).min);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the min operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function min(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).min);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the min operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function min(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).min);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice This functions performs the max operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function max(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).max);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the max operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function max(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).max);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the max operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function max(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).max);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice This functions performs the shl operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function shl(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).shl);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the shl operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function shl(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).shl);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the shl operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function shl(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).shl);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice This functions performs the shr operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function shr(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).shr);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the shr operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function shr(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).shr);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the shr operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function shr(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).shr);\\n        return euint32.wrap(result);\\n    }\\n\\n    /// @notice Performs the \\\"not\\\" for the ebool type\\n    /// @dev Implemented by a workaround due to ebool being a euint8 type behind the scenes, therefore xor is needed to assure that not(true) = false and vise-versa\\n    /// @param value input ebool ciphertext\\n    /// @return Result of the not operation on `value` \\n    function not(ebool value) internal pure returns (ebool) {\\n        return xor(value, asEbool(true));\\n    }\\n    /// @notice Performs the not operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function not(euint8 input1) internal pure returns (euint8) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        bytes memory b = FheOps(Precompiles.Fheos).not(Common.EUINT8_TFHE_GO, inputAsBytes);\\n        uint256 result = Impl.getValue(b);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice Performs the not operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function not(euint16 input1) internal pure returns (euint16) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        bytes memory b = FheOps(Precompiles.Fheos).not(Common.EUINT16_TFHE_GO, inputAsBytes);\\n        uint256 result = Impl.getValue(b);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice Performs the not operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function not(euint32 input1) internal pure returns (euint32) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        bytes memory b = FheOps(Precompiles.Fheos).not(Common.EUINT32_TFHE_GO, inputAsBytes);\\n        uint256 result = Impl.getValue(b);\\n        return euint32.wrap(result);\\n    }\\n\\n    // ********** TYPE CASTING ************* //\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an ebool\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEbool(inEbool memory value) internal pure returns (ebool) {\\n        return FHE.asEbool(value.data);\\n    }\\n    /// @notice Converts a ebool to an euint8\\n    function asEuint8(ebool value) internal pure returns (euint8) {\\n        return euint8.wrap(Impl.cast(Common.EBOOL_TFHE_GO, ebool.unwrap(value), Common.EUINT8_TFHE_GO));\\n    }\\n    /// @notice Converts a ebool to an euint16\\n    function asEuint16(ebool value) internal pure returns (euint16) {\\n        return euint16.wrap(Impl.cast(Common.EBOOL_TFHE_GO, ebool.unwrap(value), Common.EUINT16_TFHE_GO));\\n    }\\n    /// @notice Converts a ebool to an euint32\\n    function asEuint32(ebool value) internal pure returns (euint32) {\\n        return euint32.wrap(Impl.cast(Common.EBOOL_TFHE_GO, ebool.unwrap(value), Common.EUINT32_TFHE_GO));\\n    }\\n    \\n    /// @notice Converts a euint8 to an ebool\\n    function asEbool(euint8 value) internal pure returns (ebool) {\\n        return ne(value, asEuint8(0));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint8\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEuint8(inEuint8 memory value) internal pure returns (euint8) {\\n        return FHE.asEuint8(value.data);\\n    }\\n    /// @notice Converts a euint8 to an euint16\\n    function asEuint16(euint8 value) internal pure returns (euint16) {\\n        return euint16.wrap(Impl.cast(Common.EUINT8_TFHE_GO, euint8.unwrap(value), Common.EUINT16_TFHE_GO));\\n    }\\n    /// @notice Converts a euint8 to an euint32\\n    function asEuint32(euint8 value) internal pure returns (euint32) {\\n        return euint32.wrap(Impl.cast(Common.EUINT8_TFHE_GO, euint8.unwrap(value), Common.EUINT32_TFHE_GO));\\n    }\\n    \\n    /// @notice Converts a euint16 to an ebool\\n    function asEbool(euint16 value) internal pure returns (ebool) {\\n        return ne(value, asEuint16(0));\\n    }\\n    /// @notice Converts a euint16 to an euint8\\n    function asEuint8(euint16 value) internal pure returns (euint8) {\\n        return euint8.wrap(Impl.cast(Common.EUINT16_TFHE_GO, euint16.unwrap(value), Common.EUINT8_TFHE_GO));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint16\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEuint16(inEuint16 memory value) internal pure returns (euint16) {\\n        return FHE.asEuint16(value.data);\\n    }\\n    /// @notice Converts a euint16 to an euint32\\n    function asEuint32(euint16 value) internal pure returns (euint32) {\\n        return euint32.wrap(Impl.cast(Common.EUINT16_TFHE_GO, euint16.unwrap(value), Common.EUINT32_TFHE_GO));\\n    }\\n    \\n    /// @notice Converts a euint32 to an ebool\\n    function asEbool(euint32 value) internal pure returns (ebool) {\\n        return ne(value, asEuint32(0));\\n    }\\n    /// @notice Converts a euint32 to an euint8\\n    function asEuint8(euint32 value) internal pure returns (euint8) {\\n        return euint8.wrap(Impl.cast(Common.EUINT32_TFHE_GO, euint32.unwrap(value), Common.EUINT8_TFHE_GO));\\n    }\\n    /// @notice Converts a euint32 to an euint16\\n    function asEuint16(euint32 value) internal pure returns (euint16) {\\n        return euint16.wrap(Impl.cast(Common.EUINT32_TFHE_GO, euint32.unwrap(value), Common.EUINT16_TFHE_GO));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint32\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEuint32(inEuint32 memory value) internal pure returns (euint32) {\\n        return FHE.asEuint32(value.data);\\n    }\\n    /// @notice Converts a uint256 to an ebool\\n    function asEbool(uint256 value) internal pure returns (ebool) {\\n        return ebool.wrap(Impl.trivialEncrypt(value, Common.EBOOL_TFHE_GO));\\n    }\\n    /// @notice Converts a uint256 to an euint8\\n    function asEuint8(uint256 value) internal pure returns (euint8) {\\n        return euint8.wrap(Impl.trivialEncrypt(value, Common.EUINT8_TFHE_GO));\\n    }\\n    /// @notice Converts a uint256 to an euint16\\n    function asEuint16(uint256 value) internal pure returns (euint16) {\\n        return euint16.wrap(Impl.trivialEncrypt(value, Common.EUINT16_TFHE_GO));\\n    }\\n    /// @notice Converts a uint256 to an euint32\\n    function asEuint32(uint256 value) internal pure returns (euint32) {\\n        return euint32.wrap(Impl.trivialEncrypt(value, Common.EUINT32_TFHE_GO));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an ebool\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEbool(bytes memory value) internal pure returns (ebool) {\\n        return ebool.wrap(Impl.verify(value, Common.EBOOL_TFHE_GO));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint8\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEuint8(bytes memory value) internal pure returns (euint8) {\\n        return euint8.wrap(Impl.verify(value, Common.EUINT8_TFHE_GO));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint16\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEuint16(bytes memory value) internal pure returns (euint16) {\\n        return euint16.wrap(Impl.verify(value, Common.EUINT16_TFHE_GO));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint32\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEuint32(bytes memory value) internal pure returns (euint32) {\\n        return euint32.wrap(Impl.verify(value, Common.EUINT32_TFHE_GO));\\n    }\\n    /// @notice Converts a plaintext boolean value to a ciphertext ebool\\n    /// @dev Privacy: The input value is public, therefore the ciphertext should be considered public and should be used\\n    ///only for mathematical operations, not to represent data that should be private\\n    /// @return A ciphertext representation of the input \\n    function asEbool(bool value) internal pure returns (ebool) {\\n        uint256 sVal = 0;\\n        if (value) {\\n            sVal = 1;\\n        }\\n\\n        return asEbool(sVal);\\n    }\\n}\\n\\n// ********** OPERATOR OVERLOADING ************* //\\n\\nusing {operatorAddEuint8 as +} for euint8 global;\\n/// @notice Performs the add operation\\nfunction operatorAddEuint8(euint8 lhs, euint8 rhs) pure returns (euint8) {\\n    return FHE.add(lhs, rhs);\\n}\\n\\nusing {operatorAddEuint16 as +} for euint16 global;\\n/// @notice Performs the add operation\\nfunction operatorAddEuint16(euint16 lhs, euint16 rhs) pure returns (euint16) {\\n    return FHE.add(lhs, rhs);\\n}\\n\\nusing {operatorAddEuint32 as +} for euint32 global;\\n/// @notice Performs the add operation\\nfunction operatorAddEuint32(euint32 lhs, euint32 rhs) pure returns (euint32) {\\n    return FHE.add(lhs, rhs);\\n}\\n\\nusing {operatorSubEuint8 as -} for euint8 global;\\n/// @notice Performs the sub operation\\nfunction operatorSubEuint8(euint8 lhs, euint8 rhs) pure returns (euint8) {\\n    return FHE.sub(lhs, rhs);\\n}\\n\\nusing {operatorSubEuint16 as -} for euint16 global;\\n/// @notice Performs the sub operation\\nfunction operatorSubEuint16(euint16 lhs, euint16 rhs) pure returns (euint16) {\\n    return FHE.sub(lhs, rhs);\\n}\\n\\nusing {operatorSubEuint32 as -} for euint32 global;\\n/// @notice Performs the sub operation\\nfunction operatorSubEuint32(euint32 lhs, euint32 rhs) pure returns (euint32) {\\n    return FHE.sub(lhs, rhs);\\n}\\n\\nusing {operatorMulEuint8 as *} for euint8 global;\\n/// @notice Performs the mul operation\\nfunction operatorMulEuint8(euint8 lhs, euint8 rhs) pure returns (euint8) {\\n    return FHE.mul(lhs, rhs);\\n}\\n\\nusing {operatorMulEuint16 as *} for euint16 global;\\n/// @notice Performs the mul operation\\nfunction operatorMulEuint16(euint16 lhs, euint16 rhs) pure returns (euint16) {\\n    return FHE.mul(lhs, rhs);\\n}\\n\\nusing {operatorMulEuint32 as *} for euint32 global;\\n/// @notice Performs the mul operation\\nfunction operatorMulEuint32(euint32 lhs, euint32 rhs) pure returns (euint32) {\\n    return FHE.mul(lhs, rhs);\\n}\\n\\nusing {operatorDivEuint8 as /} for euint8 global;\\n/// @notice Performs the div operation\\nfunction operatorDivEuint8(euint8 lhs, euint8 rhs) pure returns (euint8) {\\n    return FHE.div(lhs, rhs);\\n}\\n\\nusing {operatorDivEuint16 as /} for euint16 global;\\n/// @notice Performs the div operation\\nfunction operatorDivEuint16(euint16 lhs, euint16 rhs) pure returns (euint16) {\\n    return FHE.div(lhs, rhs);\\n}\\n\\nusing {operatorDivEuint32 as /} for euint32 global;\\n/// @notice Performs the div operation\\nfunction operatorDivEuint32(euint32 lhs, euint32 rhs) pure returns (euint32) {\\n    return FHE.div(lhs, rhs);\\n}\\n\\nusing {operatorOrEbool as |} for ebool global;\\n/// @notice Performs the or operation\\nfunction operatorOrEbool(ebool lhs, ebool rhs) pure returns (ebool) {\\n    return FHE.or(lhs, rhs);\\n}\\n\\nusing {operatorOrEuint8 as |} for euint8 global;\\n/// @notice Performs the or operation\\nfunction operatorOrEuint8(euint8 lhs, euint8 rhs) pure returns (euint8) {\\n    return FHE.or(lhs, rhs);\\n}\\n\\nusing {operatorOrEuint16 as |} for euint16 global;\\n/// @notice Performs the or operation\\nfunction operatorOrEuint16(euint16 lhs, euint16 rhs) pure returns (euint16) {\\n    return FHE.or(lhs, rhs);\\n}\\n\\nusing {operatorOrEuint32 as |} for euint32 global;\\n/// @notice Performs the or operation\\nfunction operatorOrEuint32(euint32 lhs, euint32 rhs) pure returns (euint32) {\\n    return FHE.or(lhs, rhs);\\n}\\n\\nusing {operatorAndEbool as &} for ebool global;\\n/// @notice Performs the and operation\\nfunction operatorAndEbool(ebool lhs, ebool rhs) pure returns (ebool) {\\n    return FHE.and(lhs, rhs);\\n}\\n\\nusing {operatorAndEuint8 as &} for euint8 global;\\n/// @notice Performs the and operation\\nfunction operatorAndEuint8(euint8 lhs, euint8 rhs) pure returns (euint8) {\\n    return FHE.and(lhs, rhs);\\n}\\n\\nusing {operatorAndEuint16 as &} for euint16 global;\\n/// @notice Performs the and operation\\nfunction operatorAndEuint16(euint16 lhs, euint16 rhs) pure returns (euint16) {\\n    return FHE.and(lhs, rhs);\\n}\\n\\nusing {operatorAndEuint32 as &} for euint32 global;\\n/// @notice Performs the and operation\\nfunction operatorAndEuint32(euint32 lhs, euint32 rhs) pure returns (euint32) {\\n    return FHE.and(lhs, rhs);\\n}\\n\\nusing {operatorXorEbool as ^} for ebool global;\\n/// @notice Performs the xor operation\\nfunction operatorXorEbool(ebool lhs, ebool rhs) pure returns (ebool) {\\n    return FHE.xor(lhs, rhs);\\n}\\n\\nusing {operatorXorEuint8 as ^} for euint8 global;\\n/// @notice Performs the xor operation\\nfunction operatorXorEuint8(euint8 lhs, euint8 rhs) pure returns (euint8) {\\n    return FHE.xor(lhs, rhs);\\n}\\n\\nusing {operatorXorEuint16 as ^} for euint16 global;\\n/// @notice Performs the xor operation\\nfunction operatorXorEuint16(euint16 lhs, euint16 rhs) pure returns (euint16) {\\n    return FHE.xor(lhs, rhs);\\n}\\n\\nusing {operatorXorEuint32 as ^} for euint32 global;\\n/// @notice Performs the xor operation\\nfunction operatorXorEuint32(euint32 lhs, euint32 rhs) pure returns (euint32) {\\n    return FHE.xor(lhs, rhs);\\n}\\n\\nusing {operatorRemEuint8 as %} for euint8 global;\\n/// @notice Performs the rem operation\\nfunction operatorRemEuint8(euint8 lhs, euint8 rhs) pure returns (euint8) {\\n    return FHE.rem(lhs, rhs);\\n}\\n\\nusing {operatorRemEuint16 as %} for euint16 global;\\n/// @notice Performs the rem operation\\nfunction operatorRemEuint16(euint16 lhs, euint16 rhs) pure returns (euint16) {\\n    return FHE.rem(lhs, rhs);\\n}\\n\\nusing {operatorRemEuint32 as %} for euint32 global;\\n/// @notice Performs the rem operation\\nfunction operatorRemEuint32(euint32 lhs, euint32 rhs) pure returns (euint32) {\\n    return FHE.rem(lhs, rhs);\\n}\\n\\n// ********** BINDING DEFS ************* //\\n\\nusing BindingsEbool for ebool global;\\nlibrary BindingsEbool {\\n    \\n    /// @notice Performs the eq operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type ebool\\n    /// @return the result of the eq\\n    function eq(ebool lhs, ebool rhs) internal pure returns (ebool) {\\n        return FHE.eq(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the ne operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type ebool\\n    /// @return the result of the ne\\n    function ne(ebool lhs, ebool rhs) internal pure returns (ebool) {\\n        return FHE.ne(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the and operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type ebool\\n    /// @return the result of the and\\n    function and(ebool lhs, ebool rhs) internal pure returns (ebool) {\\n        return FHE.and(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the or operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type ebool\\n    /// @return the result of the or\\n    function or(ebool lhs, ebool rhs) internal pure returns (ebool) {\\n        return FHE.or(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the xor operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type ebool\\n    /// @return the result of the xor\\n    function xor(ebool lhs, ebool rhs) internal pure returns (ebool) {\\n        return FHE.xor(lhs, rhs);\\n    }\\n    function toU8(ebool value) internal pure returns (euint8) {\\n        return FHE.asEuint8(value);\\n    }\\n    function toU16(ebool value) internal pure returns (euint16) {\\n        return FHE.asEuint16(value);\\n    }\\n    function toU32(ebool value) internal pure returns (euint32) {\\n        return FHE.asEuint32(value);\\n    }\\n    function seal(ebool value, bytes32 publicKey) internal pure returns (bytes memory) {\\n        return FHE.sealoutput(value, publicKey);\\n    }\\n}\\n\\nusing BindingsEuint8 for euint8 global;\\nlibrary BindingsEuint8 {\\n    \\n    /// @notice Performs the add operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the add\\n    function add(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.add(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the mul operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the mul\\n    function mul(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.mul(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the div operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the div\\n    function div(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.div(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the sub operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the sub\\n    function sub(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.sub(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the eq operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the eq\\n    function eq(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        return FHE.eq(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the ne operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the ne\\n    function ne(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        return FHE.ne(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the and operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the and\\n    function and(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.and(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the or operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the or\\n    function or(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.or(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the xor operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the xor\\n    function xor(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.xor(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the gt operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the gt\\n    function gt(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        return FHE.gt(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the gte operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the gte\\n    function gte(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        return FHE.gte(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the lt operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the lt\\n    function lt(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        return FHE.lt(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the lte operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the lte\\n    function lte(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        return FHE.lte(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the rem operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the rem\\n    function rem(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.rem(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the max operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the max\\n    function max(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.max(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the min operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the min\\n    function min(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.min(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the shl operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the shl\\n    function shl(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.shl(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the shr operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the shr\\n    function shr(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.shr(lhs, rhs);\\n    }\\n    function toBool(euint8 value) internal pure returns (ebool) {\\n        return FHE.asEbool(value);\\n    }\\n    function toU16(euint8 value) internal pure returns (euint16) {\\n        return FHE.asEuint16(value);\\n    }\\n    function toU32(euint8 value) internal pure returns (euint32) {\\n        return FHE.asEuint32(value);\\n    }\\n    function seal(euint8 value, bytes32 publicKey) internal pure returns (bytes memory) {\\n        return FHE.sealoutput(value, publicKey);\\n    }\\n}\\n\\nusing BindingsEuint16 for euint16 global;\\nlibrary BindingsEuint16 {\\n    \\n    /// @notice Performs the add operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the add\\n    function add(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.add(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the mul operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the mul\\n    function mul(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.mul(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the div operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the div\\n    function div(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.div(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the sub operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the sub\\n    function sub(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.sub(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the eq operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the eq\\n    function eq(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        return FHE.eq(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the ne operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the ne\\n    function ne(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        return FHE.ne(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the and operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the and\\n    function and(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.and(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the or operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the or\\n    function or(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.or(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the xor operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the xor\\n    function xor(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.xor(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the gt operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the gt\\n    function gt(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        return FHE.gt(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the gte operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the gte\\n    function gte(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        return FHE.gte(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the lt operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the lt\\n    function lt(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        return FHE.lt(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the lte operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the lte\\n    function lte(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        return FHE.lte(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the rem operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the rem\\n    function rem(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.rem(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the max operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the max\\n    function max(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.max(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the min operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the min\\n    function min(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.min(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the shl operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the shl\\n    function shl(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.shl(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the shr operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the shr\\n    function shr(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.shr(lhs, rhs);\\n    }\\n    function toBool(euint16 value) internal pure returns (ebool) {\\n        return FHE.asEbool(value);\\n    }\\n    function toU8(euint16 value) internal pure returns (euint8) {\\n        return FHE.asEuint8(value);\\n    }\\n    function toU32(euint16 value) internal pure returns (euint32) {\\n        return FHE.asEuint32(value);\\n    }\\n    function seal(euint16 value, bytes32 publicKey) internal pure returns (bytes memory) {\\n        return FHE.sealoutput(value, publicKey);\\n    }\\n}\\n\\nusing BindingsEuint32 for euint32 global;\\nlibrary BindingsEuint32 {\\n    \\n    /// @notice Performs the add operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the add\\n    function add(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.add(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the mul operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the mul\\n    function mul(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.mul(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the div operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the div\\n    function div(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.div(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the sub operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the sub\\n    function sub(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.sub(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the eq operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the eq\\n    function eq(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        return FHE.eq(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the ne operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the ne\\n    function ne(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        return FHE.ne(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the and operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the and\\n    function and(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.and(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the or operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the or\\n    function or(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.or(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the xor operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the xor\\n    function xor(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.xor(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the gt operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the gt\\n    function gt(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        return FHE.gt(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the gte operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the gte\\n    function gte(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        return FHE.gte(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the lt operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the lt\\n    function lt(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        return FHE.lt(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the lte operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the lte\\n    function lte(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        return FHE.lte(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the rem operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the rem\\n    function rem(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.rem(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the max operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the max\\n    function max(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.max(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the min operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the min\\n    function min(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.min(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the shl operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the shl\\n    function shl(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.shl(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the shr operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the shr\\n    function shr(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.shr(lhs, rhs);\\n    }\\n    function toBool(euint32 value) internal pure returns (ebool) {\\n        return FHE.asEbool(value);\\n    }\\n    function toU8(euint32 value) internal pure returns (euint8) {\\n        return FHE.asEuint8(value);\\n    }\\n    function toU16(euint32 value) internal pure returns (euint16) {\\n        return FHE.asEuint16(value);\\n    }\\n    function seal(euint32 value, bytes32 publicKey) internal pure returns (bytes memory) {\\n        return FHE.sealoutput(value, publicKey);\\n    }\\n}\",\"keccak256\":\"0xcacb424fc161e575629898845524b6298a1fe1a5d91d6e382963aed549fe8030\",\"license\":\"BSD-3-Clause-Clear\"},\"@fhenixprotocol/contracts/FheOS.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\n// solhint-disable one-contract-per-file\\npragma solidity >=0.8.13 <0.9.0;\\n\\nlibrary Precompiles {\\n    //solhint-disable const-name-snakecase\\n    address public constant Fheos = address(128);\\n}\\n\\ninterface FheOps {\\n    function add(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function verify(uint8 utype, bytes memory input) external pure returns (bytes memory);\\n    function sealOutput(uint8 utype, bytes memory ctHash, bytes memory pk) external pure returns (bytes memory);\\n    function decrypt(uint8 utype, bytes memory input) external pure returns (uint256);\\n    function lte(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function sub(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function mul(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function lt(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function select(uint8 utype, bytes memory controlHash, bytes memory ifTrueHash, bytes memory ifFalseHash) external pure returns (bytes memory);\\n    function req(uint8 utype, bytes memory input) external pure returns (bytes memory);\\n    function cast(uint8 utype, bytes memory input, uint8 toType) external pure returns (bytes memory);\\n    function trivialEncrypt(bytes memory input, uint8 toType) external pure returns (bytes memory);\\n    function div(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function gt(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function gte(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function rem(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function and(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function or(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function xor(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function eq(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function ne(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function min(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function max(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function shl(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function shr(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function not(uint8 utype, bytes memory value) external pure returns (bytes memory);\\n    function getNetworkPublicKey() external pure returns (bytes memory);\\n}\",\"keccak256\":\"0xb78d3a9c2c7ef5864741ab6a27aceadced3bc624e13e4abe8c37342988014574\",\"license\":\"BSD-3-Clause-Clear\"},\"contracts/PairFHE.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport \\\"@fhenixprotocol/contracts/FHE.sol\\\";\\n\\ncontract Pair {\\n    IERC20 public token0;\\n    IERC20 public token1;\\n    address public immutable factory;\\n\\n    uint public reserve0;\\n    uint public reserve1;\\n\\n    uint public totalSupply;\\n    mapping(address => uint) public balanceOf;\\n\\n    constructor(){\\n        factory = msg.sender;\\n    }\\n\\n    // function BalanceOf(bytes32 publicKey,bytes calldata signature) public view \\n    // onlySignedPublicKey(publicKey,signature)\\n    // returns(bytes memory reencrypted) {\\n    //     // return TFHE.reencrypt(balanceOf[msg.sender], publicKey, 0);\\n    //     reencrypted = TFHE.reencrypt(balanceOf[msg.sender],publicKey,0);\\n    // }\\n\\n    function initialize(address _token0, address _token1) external {\\n        require(msg.sender == factory, 'FORBIDDEN'); // sufficient check\\n        token0 = IERC20(_token0);\\n        token1 = IERC20(_token1);\\n    }\\n\\n    function _mint(address _to, uint _amount) private {\\n        balanceOf[_to] += _amount;\\n        totalSupply += _amount;\\n    }\\n\\n    function _burn(address _from, uint _amount) private {\\n        balanceOf[_from] -= _amount;\\n        totalSupply -= _amount;\\n    }\\n\\n    function _update(uint _reserve0, uint _reserve1) private {\\n        reserve0 = _reserve0;\\n        reserve1 = _reserve1;\\n    }\\n\\n    function swap(address _tokenIn, inEuint32 memory _amountIn) external returns (uint amountOut) {\\n        euint32 x = FHE.asEuint32(_amountIn);\\n        uint32 amountIn = FHE.decrypt(x);\\n        require(\\n            _tokenIn == address(token0) || _tokenIn == address(token1),\\n            \\\"invalid token\\\"\\n        );\\n        require(uint256(amountIn) > 0, \\\"amount in = 0\\\");\\n\\n        bool isToken0 = _tokenIn == address(token0);\\n        (IERC20 tokenIn, IERC20 tokenOut, uint reserveIn, uint reserveOut) = isToken0\\n            ? (token0, token1, reserve0, reserve1)\\n            : (token1, token0, reserve1, reserve0);\\n\\n        tokenIn.transferFrom(msg.sender, address(this), uint256(amountIn));\\n\\n        uint amountInWithFee = (uint256(amountIn) * 997) / 1000;\\n        amountOut = (reserveOut * amountInWithFee) / (reserveIn + amountInWithFee);\\n\\n        tokenOut.transfer(msg.sender, uint256(amountOut));\\n\\n        _update(token0.balanceOf(address(this)), token1.balanceOf(address(this)));\\n    }\\n\\n    function addLiquidity(inEuint32 memory _amount0, inEuint32 memory _amount1) external returns (uint shares) {\\n        euint32 x = FHE.asEuint32(_amount0);\\n        euint32 y = FHE.asEuint32(_amount1);\\n        uint32 amount0 = FHE.decrypt(x);\\n        uint32 amount1 = FHE.decrypt(y);\\n        \\n        token0.transferFrom(msg.sender, address(this), uint256(amount0));\\n        token1.transferFrom(msg.sender, address(this), uint256(amount1));\\n\\n        if (reserve0 > 0 || reserve1 > 0) {\\n            require(reserve0 * uint(amount1) == reserve1 * uint(amount0), \\\"x / y != dx / dy\\\");\\n        }\\n\\n        if (totalSupply == 0) {\\n            shares = _sqrt(uint256(amount0) * uint256(amount1));\\n        } else {\\n            uint256 z = uint256(amount0) * totalSupply / reserve0;\\n            uint256 a = uint256(amount1) * totalSupply / reserve1;\\n            shares = _min(z , a);\\n        }\\n        require(shares > 0, \\\"shares = 0\\\");\\n        _mint(msg.sender, shares);\\n\\n        _update(token0.balanceOf(address(this)), token1.balanceOf(address(this)));\\n    }\\n\\n    function removeLiquidity(\\n        inEuint32 memory _shares\\n    ) external returns (uint amount0, uint amount1) {\\n        euint32 x = FHE.asEuint32(_shares);\\n\\n        uint32 shares = FHE.decrypt(x);\\n        uint bal0 = token0.balanceOf(address(this));\\n        uint bal1 = token1.balanceOf(address(this));\\n\\n        amount0 = (uint256(shares) * bal0) / totalSupply;\\n        amount1 = (uint256(shares) * bal1) / totalSupply;\\n        require(amount0 > 0 && amount1 > 0, \\\"amount0 or amount1 = 0\\\");\\n\\n        _burn(msg.sender, shares);\\n        _update(bal0 - amount0, bal1 - amount1);\\n\\n        token0.transfer(msg.sender, uint256(amount0));\\n        token1.transfer(msg.sender, uint256(amount1));\\n    }\\n\\n    function _sqrt(uint y) private pure returns (uint z) {\\n        if (y > 3) {\\n            z = y;\\n            uint x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n\\n    function _min(uint x, uint y) private pure returns (uint) {\\n        return x <= y ? x : y;\\n    }\\n}\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint);\\n\\n    function balanceOf(address account) external view returns (uint);\\n\\n    function transfer(address recipient, uint amount) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint amount);\\n    event Approval(address indexed owner, address indexed spender, uint amount);\\n}\",\"keccak256\":\"0x403e9186fa121c6250ca0d2ad7e6f5ef4127f63600cd2e9566569d4e3fe55cc5\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60a060405234801561001057600080fd5b503373ffffffffffffffffffffffffffffffffffffffff1660808173ffffffffffffffffffffffffffffffffffffffff168152505060805161202561006760003960008181610271015261101301526120256000f3fe608060405234801561001057600080fd5b50600436106100a95760003560e01c80635a76f25e116100715780635a76f25e146101545780635b18de5f1461017257806370a08231146101a357806374bfd999146101d3578063c45a015514610203578063d21220a714610221576100a9565b80630dfe1681146100ae57806318160ddd146100cc578063443cb4bc146100ea578063485cc9551461010857806352dc029114610124575b600080fd5b6100b661023f565b6040516100c39190611525565b60405180910390f35b6100d4610263565b6040516100e19190611559565b60405180910390f35b6100f2610269565b6040516100ff9190611559565b60405180910390f35b610122600480360381019061011d91906115c6565b61026f565b005b61013e600480360381019061013991906117ae565b610382565b60405161014b9190611559565b60405180910390f35b61015c6107a7565b6040516101699190611559565b60405180910390f35b61018c60048036038101906101879190611826565b6107ad565b60405161019a92919061186f565b60405180910390f35b6101bd60048036038101906101b89190611898565b610b13565b6040516101ca9190611559565b60405180910390f35b6101ed60048036038101906101e891906118c5565b610b2b565b6040516101fa9190611559565b60405180910390f35b61020b611011565b6040516102189190611930565b60405180910390f35b610229611035565b6040516102369190611525565b60405180910390f35b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b60045481565b60025481565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146102fd576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016102f4906119a8565b60405180910390fd5b816000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555080600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505050565b60008061038e8461105b565b9050600061039b8461105b565b905060006103a883611071565b905060006103b583611071565b905060008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166323b872dd33308563ffffffff166040518463ffffffff1660e01b815260040161041a939291906119c8565b6020604051808303816000875af1158015610439573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061045d9190611a37565b50600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166323b872dd33308463ffffffff166040518463ffffffff1660e01b81526004016104c3939291906119c8565b6020604051808303816000875af11580156104e2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105069190611a37565b506000600254118061051a57506000600354115b15610588578163ffffffff166003546105339190611a93565b8163ffffffff166002546105479190611a93565b14610587576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161057e90611b21565b60405180910390fd5b5b6000600454036105b9576105b28163ffffffff168363ffffffff166105ad9190611a93565b611134565b9450610612565b60006002546004548463ffffffff166105d29190611a93565b6105dc9190611b70565b905060006003546004548463ffffffff166105f79190611a93565b6106019190611b70565b905061060d82826111ae565b965050505b60008511610655576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161064c90611bed565b60405180910390fd5b61065f33866111c8565b61079d60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b81526004016106bb9190611930565b602060405180830381865afa1580156106d8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106fc9190611c39565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b81526004016107579190611930565b602060405180830381865afa158015610774573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107989190611c39565b61123b565b5050505092915050565b60035481565b60008060006107bb8461105b565b905060006107c882611071565b905060008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b81526004016108269190611930565b602060405180830381865afa158015610843573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108679190611c39565b90506000600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b81526004016108c69190611930565b602060405180830381865afa1580156108e3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109079190611c39565b9050600454828463ffffffff1661091e9190611a93565b6109289190611b70565b9550600454818463ffffffff1661093f9190611a93565b6109499190611b70565b945060008611801561095b5750600085115b61099a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161099190611cb2565b60405180910390fd5b6109aa338463ffffffff1661124d565b6109ca86836109b99190611cd2565b86836109c59190611cd2565b61123b565b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a9059cbb33886040518363ffffffff1660e01b8152600401610a25929190611d06565b6020604051808303816000875af1158015610a44573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a689190611a37565b50600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a9059cbb33876040518363ffffffff1660e01b8152600401610ac6929190611d06565b6020604051808303816000875af1158015610ae5573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b099190611a37565b5050505050915091565b60056020528060005260406000206000915090505481565b600080610b378361105b565b90506000610b4482611071565b905060008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff161480610bed5750600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff16145b610c2c576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610c2390611d7b565b60405180910390fd5b60008163ffffffff1611610c75576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610c6c90611de7565b60405180910390fd5b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168673ffffffffffffffffffffffffffffffffffffffff1614905060008060008084610d2357600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1660008054906101000a900473ffffffffffffffffffffffffffffffffffffffff16600354600254610d6e565b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff16600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff166002546003545b93509350935093508373ffffffffffffffffffffffffffffffffffffffff166323b872dd33308963ffffffff166040518463ffffffff1660e01b8152600401610db9939291906119c8565b6020604051808303816000875af1158015610dd8573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610dfc9190611a37565b5060006103e86103e58863ffffffff16610e169190611a93565b610e209190611b70565b90508083610e2e9190611e07565b8183610e3a9190611a93565b610e449190611b70565b98508373ffffffffffffffffffffffffffffffffffffffff1663a9059cbb338b6040518363ffffffff1660e01b8152600401610e81929190611d06565b6020604051808303816000875af1158015610ea0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ec49190611a37565b5061100360008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b8152600401610f219190611930565b602060405180830381865afa158015610f3e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f629190611c39565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b8152600401610fbd9190611930565b602060405180830381865afa158015610fda573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ffe9190611c39565b61123b565b505050505050505092915050565b7f000000000000000000000000000000000000000000000000000000000000000081565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b600061106a82600001516112c0565b9050919050565b600061107c826112d4565b61108d5761108a60006112e1565b91505b6000829050600061109d826112f5565b90506000608073ffffffffffffffffffffffffffffffffffffffff166373cc01546002846040518363ffffffff1660e01b81526004016110de929190611ed6565b602060405180830381865afa1580156110fb573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061111f9190611c39565b905061112a81611352565b9350505050919050565b6000600382111561119b57819050600060016002846111539190611b70565b61115d9190611e07565b90505b8181101561119557809150600281828561117a9190611b70565b6111849190611e07565b61118e9190611b70565b9050611160565b506111a9565b600082146111a857600190505b5b919050565b6000818311156111be57816111c0565b825b905092915050565b80600560008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546112179190611e07565b9250508190555080600460008282546112309190611e07565b925050819055505050565b81600281905550806003819055505050565b80600560008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825461129c9190611cd2565b9250508190555080600460008282546112b59190611cd2565b925050819055505050565b60006112cd82600261135c565b9050919050565b6000808214159050919050565b60006112ee8260026113f6565b9050919050565b6060602067ffffffffffffffff8111156113125761131161161c565b5b6040519080825280601f01601f1916602001820160405280156113445781602001600182028036833780820191505090505b509050816020820152919050565b6000819050919050565b60006060608073ffffffffffffffffffffffffffffffffffffffff16635fa55ca784866040518363ffffffff1660e01b815260040161139c929190611ed6565b600060405180830381865afa1580156113b9573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f820116820180604052508101906113e29190611f76565b90506113ed81611498565b91505092915050565b60006060608073ffffffffffffffffffffffffffffffffffffffff166319e1c5c4611420866112f5565b856040518363ffffffff1660e01b815260040161143e929190611fbf565b600060405180830381865afa15801561145b573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f820116820180604052508101906114849190611f76565b905061148f81611498565b91505092915050565b600060208201519050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000819050919050565b60006114eb6114e66114e1846114a6565b6114c6565b6114a6565b9050919050565b60006114fd826114d0565b9050919050565b600061150f826114f2565b9050919050565b61151f81611504565b82525050565b600060208201905061153a6000830184611516565b92915050565b6000819050919050565b61155381611540565b82525050565b600060208201905061156e600083018461154a565b92915050565b6000604051905090565b600080fd5b600080fd5b6000611593826114a6565b9050919050565b6115a381611588565b81146115ae57600080fd5b50565b6000813590506115c08161159a565b92915050565b600080604083850312156115dd576115dc61157e565b5b60006115eb858286016115b1565b92505060206115fc858286016115b1565b9150509250929050565b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6116548261160b565b810181811067ffffffffffffffff821117156116735761167261161c565b5b80604052505050565b6000611686611574565b9050611692828261164b565b919050565b600080fd5b600080fd5b600080fd5b600067ffffffffffffffff8211156116c1576116c061161c565b5b6116ca8261160b565b9050602081019050919050565b82818337600083830152505050565b60006116f96116f4846116a6565b61167c565b905082815260208101848484011115611715576117146116a1565b5b6117208482856116d7565b509392505050565b600082601f83011261173d5761173c61169c565b5b813561174d8482602086016116e6565b91505092915050565b60006020828403121561176c5761176b611606565b5b611776602061167c565b9050600082013567ffffffffffffffff81111561179657611795611697565b5b6117a284828501611728565b60008301525092915050565b600080604083850312156117c5576117c461157e565b5b600083013567ffffffffffffffff8111156117e3576117e2611583565b5b6117ef85828601611756565b925050602083013567ffffffffffffffff8111156118105761180f611583565b5b61181c85828601611756565b9150509250929050565b60006020828403121561183c5761183b61157e565b5b600082013567ffffffffffffffff81111561185a57611859611583565b5b61186684828501611756565b91505092915050565b6000604082019050611884600083018561154a565b611891602083018461154a565b9392505050565b6000602082840312156118ae576118ad61157e565b5b60006118bc848285016115b1565b91505092915050565b600080604083850312156118dc576118db61157e565b5b60006118ea858286016115b1565b925050602083013567ffffffffffffffff81111561190b5761190a611583565b5b61191785828601611756565b9150509250929050565b61192a81611588565b82525050565b60006020820190506119456000830184611921565b92915050565b600082825260208201905092915050565b7f464f5242494444454e0000000000000000000000000000000000000000000000600082015250565b600061199260098361194b565b915061199d8261195c565b602082019050919050565b600060208201905081810360008301526119c181611985565b9050919050565b60006060820190506119dd6000830186611921565b6119ea6020830185611921565b6119f7604083018461154a565b949350505050565b60008115159050919050565b611a14816119ff565b8114611a1f57600080fd5b50565b600081519050611a3181611a0b565b92915050565b600060208284031215611a4d57611a4c61157e565b5b6000611a5b84828501611a22565b91505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000611a9e82611540565b9150611aa983611540565b9250828202611ab781611540565b91508282048414831517611ace57611acd611a64565b5b5092915050565b7f78202f207920213d206478202f20647900000000000000000000000000000000600082015250565b6000611b0b60108361194b565b9150611b1682611ad5565b602082019050919050565b60006020820190508181036000830152611b3a81611afe565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b6000611b7b82611540565b9150611b8683611540565b925082611b9657611b95611b41565b5b828204905092915050565b7f736861726573203d203000000000000000000000000000000000000000000000600082015250565b6000611bd7600a8361194b565b9150611be282611ba1565b602082019050919050565b60006020820190508181036000830152611c0681611bca565b9050919050565b611c1681611540565b8114611c2157600080fd5b50565b600081519050611c3381611c0d565b92915050565b600060208284031215611c4f57611c4e61157e565b5b6000611c5d84828501611c24565b91505092915050565b7f616d6f756e7430206f7220616d6f756e7431203d203000000000000000000000600082015250565b6000611c9c60168361194b565b9150611ca782611c66565b602082019050919050565b60006020820190508181036000830152611ccb81611c8f565b9050919050565b6000611cdd82611540565b9150611ce883611540565b9250828203905081811115611d0057611cff611a64565b5b92915050565b6000604082019050611d1b6000830185611921565b611d28602083018461154a565b9392505050565b7f696e76616c696420746f6b656e00000000000000000000000000000000000000600082015250565b6000611d65600d8361194b565b9150611d7082611d2f565b602082019050919050565b60006020820190508181036000830152611d9481611d58565b9050919050565b7f616d6f756e7420696e203d203000000000000000000000000000000000000000600082015250565b6000611dd1600d8361194b565b9150611ddc82611d9b565b602082019050919050565b60006020820190508181036000830152611e0081611dc4565b9050919050565b6000611e1282611540565b9150611e1d83611540565b9250828201905080821115611e3557611e34611a64565b5b92915050565b600060ff82169050919050565b611e5181611e3b565b82525050565b600081519050919050565b600082825260208201905092915050565b60005b83811015611e91578082015181840152602081019050611e76565b60008484015250505050565b6000611ea882611e57565b611eb28185611e62565b9350611ec2818560208601611e73565b611ecb8161160b565b840191505092915050565b6000604082019050611eeb6000830185611e48565b8181036020830152611efd8184611e9d565b90509392505050565b6000611f19611f14846116a6565b61167c565b905082815260208101848484011115611f3557611f346116a1565b5b611f40848285611e73565b509392505050565b600082601f830112611f5d57611f5c61169c565b5b8151611f6d848260208601611f06565b91505092915050565b600060208284031215611f8c57611f8b61157e565b5b600082015167ffffffffffffffff811115611faa57611fa9611583565b5b611fb684828501611f48565b91505092915050565b60006040820190508181036000830152611fd98185611e9d565b9050611fe86020830184611e48565b939250505056fea2646970667358221220556c56bfe7470e41029bd2d120d5744164daae382ebc15478d81f72443079fda64736f6c63430008130033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100a95760003560e01c80635a76f25e116100715780635a76f25e146101545780635b18de5f1461017257806370a08231146101a357806374bfd999146101d3578063c45a015514610203578063d21220a714610221576100a9565b80630dfe1681146100ae57806318160ddd146100cc578063443cb4bc146100ea578063485cc9551461010857806352dc029114610124575b600080fd5b6100b661023f565b6040516100c39190611525565b60405180910390f35b6100d4610263565b6040516100e19190611559565b60405180910390f35b6100f2610269565b6040516100ff9190611559565b60405180910390f35b610122600480360381019061011d91906115c6565b61026f565b005b61013e600480360381019061013991906117ae565b610382565b60405161014b9190611559565b60405180910390f35b61015c6107a7565b6040516101699190611559565b60405180910390f35b61018c60048036038101906101879190611826565b6107ad565b60405161019a92919061186f565b60405180910390f35b6101bd60048036038101906101b89190611898565b610b13565b6040516101ca9190611559565b60405180910390f35b6101ed60048036038101906101e891906118c5565b610b2b565b6040516101fa9190611559565b60405180910390f35b61020b611011565b6040516102189190611930565b60405180910390f35b610229611035565b6040516102369190611525565b60405180910390f35b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b60045481565b60025481565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146102fd576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016102f4906119a8565b60405180910390fd5b816000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555080600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505050565b60008061038e8461105b565b9050600061039b8461105b565b905060006103a883611071565b905060006103b583611071565b905060008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166323b872dd33308563ffffffff166040518463ffffffff1660e01b815260040161041a939291906119c8565b6020604051808303816000875af1158015610439573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061045d9190611a37565b50600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166323b872dd33308463ffffffff166040518463ffffffff1660e01b81526004016104c3939291906119c8565b6020604051808303816000875af11580156104e2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105069190611a37565b506000600254118061051a57506000600354115b15610588578163ffffffff166003546105339190611a93565b8163ffffffff166002546105479190611a93565b14610587576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161057e90611b21565b60405180910390fd5b5b6000600454036105b9576105b28163ffffffff168363ffffffff166105ad9190611a93565b611134565b9450610612565b60006002546004548463ffffffff166105d29190611a93565b6105dc9190611b70565b905060006003546004548463ffffffff166105f79190611a93565b6106019190611b70565b905061060d82826111ae565b965050505b60008511610655576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161064c90611bed565b60405180910390fd5b61065f33866111c8565b61079d60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b81526004016106bb9190611930565b602060405180830381865afa1580156106d8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106fc9190611c39565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b81526004016107579190611930565b602060405180830381865afa158015610774573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107989190611c39565b61123b565b5050505092915050565b60035481565b60008060006107bb8461105b565b905060006107c882611071565b905060008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b81526004016108269190611930565b602060405180830381865afa158015610843573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108679190611c39565b90506000600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b81526004016108c69190611930565b602060405180830381865afa1580156108e3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109079190611c39565b9050600454828463ffffffff1661091e9190611a93565b6109289190611b70565b9550600454818463ffffffff1661093f9190611a93565b6109499190611b70565b945060008611801561095b5750600085115b61099a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161099190611cb2565b60405180910390fd5b6109aa338463ffffffff1661124d565b6109ca86836109b99190611cd2565b86836109c59190611cd2565b61123b565b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a9059cbb33886040518363ffffffff1660e01b8152600401610a25929190611d06565b6020604051808303816000875af1158015610a44573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a689190611a37565b50600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a9059cbb33876040518363ffffffff1660e01b8152600401610ac6929190611d06565b6020604051808303816000875af1158015610ae5573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b099190611a37565b5050505050915091565b60056020528060005260406000206000915090505481565b600080610b378361105b565b90506000610b4482611071565b905060008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff161480610bed5750600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff16145b610c2c576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610c2390611d7b565b60405180910390fd5b60008163ffffffff1611610c75576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610c6c90611de7565b60405180910390fd5b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168673ffffffffffffffffffffffffffffffffffffffff1614905060008060008084610d2357600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1660008054906101000a900473ffffffffffffffffffffffffffffffffffffffff16600354600254610d6e565b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff16600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff166002546003545b93509350935093508373ffffffffffffffffffffffffffffffffffffffff166323b872dd33308963ffffffff166040518463ffffffff1660e01b8152600401610db9939291906119c8565b6020604051808303816000875af1158015610dd8573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610dfc9190611a37565b5060006103e86103e58863ffffffff16610e169190611a93565b610e209190611b70565b90508083610e2e9190611e07565b8183610e3a9190611a93565b610e449190611b70565b98508373ffffffffffffffffffffffffffffffffffffffff1663a9059cbb338b6040518363ffffffff1660e01b8152600401610e81929190611d06565b6020604051808303816000875af1158015610ea0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ec49190611a37565b5061100360008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b8152600401610f219190611930565b602060405180830381865afa158015610f3e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f629190611c39565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b8152600401610fbd9190611930565b602060405180830381865afa158015610fda573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ffe9190611c39565b61123b565b505050505050505092915050565b7f000000000000000000000000000000000000000000000000000000000000000081565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b600061106a82600001516112c0565b9050919050565b600061107c826112d4565b61108d5761108a60006112e1565b91505b6000829050600061109d826112f5565b90506000608073ffffffffffffffffffffffffffffffffffffffff166373cc01546002846040518363ffffffff1660e01b81526004016110de929190611ed6565b602060405180830381865afa1580156110fb573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061111f9190611c39565b905061112a81611352565b9350505050919050565b6000600382111561119b57819050600060016002846111539190611b70565b61115d9190611e07565b90505b8181101561119557809150600281828561117a9190611b70565b6111849190611e07565b61118e9190611b70565b9050611160565b506111a9565b600082146111a857600190505b5b919050565b6000818311156111be57816111c0565b825b905092915050565b80600560008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546112179190611e07565b9250508190555080600460008282546112309190611e07565b925050819055505050565b81600281905550806003819055505050565b80600560008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825461129c9190611cd2565b9250508190555080600460008282546112b59190611cd2565b925050819055505050565b60006112cd82600261135c565b9050919050565b6000808214159050919050565b60006112ee8260026113f6565b9050919050565b6060602067ffffffffffffffff8111156113125761131161161c565b5b6040519080825280601f01601f1916602001820160405280156113445781602001600182028036833780820191505090505b509050816020820152919050565b6000819050919050565b60006060608073ffffffffffffffffffffffffffffffffffffffff16635fa55ca784866040518363ffffffff1660e01b815260040161139c929190611ed6565b600060405180830381865afa1580156113b9573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f820116820180604052508101906113e29190611f76565b90506113ed81611498565b91505092915050565b60006060608073ffffffffffffffffffffffffffffffffffffffff166319e1c5c4611420866112f5565b856040518363ffffffff1660e01b815260040161143e929190611fbf565b600060405180830381865afa15801561145b573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f820116820180604052508101906114849190611f76565b905061148f81611498565b91505092915050565b600060208201519050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000819050919050565b60006114eb6114e66114e1846114a6565b6114c6565b6114a6565b9050919050565b60006114fd826114d0565b9050919050565b600061150f826114f2565b9050919050565b61151f81611504565b82525050565b600060208201905061153a6000830184611516565b92915050565b6000819050919050565b61155381611540565b82525050565b600060208201905061156e600083018461154a565b92915050565b6000604051905090565b600080fd5b600080fd5b6000611593826114a6565b9050919050565b6115a381611588565b81146115ae57600080fd5b50565b6000813590506115c08161159a565b92915050565b600080604083850312156115dd576115dc61157e565b5b60006115eb858286016115b1565b92505060206115fc858286016115b1565b9150509250929050565b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6116548261160b565b810181811067ffffffffffffffff821117156116735761167261161c565b5b80604052505050565b6000611686611574565b9050611692828261164b565b919050565b600080fd5b600080fd5b600080fd5b600067ffffffffffffffff8211156116c1576116c061161c565b5b6116ca8261160b565b9050602081019050919050565b82818337600083830152505050565b60006116f96116f4846116a6565b61167c565b905082815260208101848484011115611715576117146116a1565b5b6117208482856116d7565b509392505050565b600082601f83011261173d5761173c61169c565b5b813561174d8482602086016116e6565b91505092915050565b60006020828403121561176c5761176b611606565b5b611776602061167c565b9050600082013567ffffffffffffffff81111561179657611795611697565b5b6117a284828501611728565b60008301525092915050565b600080604083850312156117c5576117c461157e565b5b600083013567ffffffffffffffff8111156117e3576117e2611583565b5b6117ef85828601611756565b925050602083013567ffffffffffffffff8111156118105761180f611583565b5b61181c85828601611756565b9150509250929050565b60006020828403121561183c5761183b61157e565b5b600082013567ffffffffffffffff81111561185a57611859611583565b5b61186684828501611756565b91505092915050565b6000604082019050611884600083018561154a565b611891602083018461154a565b9392505050565b6000602082840312156118ae576118ad61157e565b5b60006118bc848285016115b1565b91505092915050565b600080604083850312156118dc576118db61157e565b5b60006118ea858286016115b1565b925050602083013567ffffffffffffffff81111561190b5761190a611583565b5b61191785828601611756565b9150509250929050565b61192a81611588565b82525050565b60006020820190506119456000830184611921565b92915050565b600082825260208201905092915050565b7f464f5242494444454e0000000000000000000000000000000000000000000000600082015250565b600061199260098361194b565b915061199d8261195c565b602082019050919050565b600060208201905081810360008301526119c181611985565b9050919050565b60006060820190506119dd6000830186611921565b6119ea6020830185611921565b6119f7604083018461154a565b949350505050565b60008115159050919050565b611a14816119ff565b8114611a1f57600080fd5b50565b600081519050611a3181611a0b565b92915050565b600060208284031215611a4d57611a4c61157e565b5b6000611a5b84828501611a22565b91505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000611a9e82611540565b9150611aa983611540565b9250828202611ab781611540565b91508282048414831517611ace57611acd611a64565b5b5092915050565b7f78202f207920213d206478202f20647900000000000000000000000000000000600082015250565b6000611b0b60108361194b565b9150611b1682611ad5565b602082019050919050565b60006020820190508181036000830152611b3a81611afe565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b6000611b7b82611540565b9150611b8683611540565b925082611b9657611b95611b41565b5b828204905092915050565b7f736861726573203d203000000000000000000000000000000000000000000000600082015250565b6000611bd7600a8361194b565b9150611be282611ba1565b602082019050919050565b60006020820190508181036000830152611c0681611bca565b9050919050565b611c1681611540565b8114611c2157600080fd5b50565b600081519050611c3381611c0d565b92915050565b600060208284031215611c4f57611c4e61157e565b5b6000611c5d84828501611c24565b91505092915050565b7f616d6f756e7430206f7220616d6f756e7431203d203000000000000000000000600082015250565b6000611c9c60168361194b565b9150611ca782611c66565b602082019050919050565b60006020820190508181036000830152611ccb81611c8f565b9050919050565b6000611cdd82611540565b9150611ce883611540565b9250828203905081811115611d0057611cff611a64565b5b92915050565b6000604082019050611d1b6000830185611921565b611d28602083018461154a565b9392505050565b7f696e76616c696420746f6b656e00000000000000000000000000000000000000600082015250565b6000611d65600d8361194b565b9150611d7082611d2f565b602082019050919050565b60006020820190508181036000830152611d9481611d58565b9050919050565b7f616d6f756e7420696e203d203000000000000000000000000000000000000000600082015250565b6000611dd1600d8361194b565b9150611ddc82611d9b565b602082019050919050565b60006020820190508181036000830152611e0081611dc4565b9050919050565b6000611e1282611540565b9150611e1d83611540565b9250828201905080821115611e3557611e34611a64565b5b92915050565b600060ff82169050919050565b611e5181611e3b565b82525050565b600081519050919050565b600082825260208201905092915050565b60005b83811015611e91578082015181840152602081019050611e76565b60008484015250505050565b6000611ea882611e57565b611eb28185611e62565b9350611ec2818560208601611e73565b611ecb8161160b565b840191505092915050565b6000604082019050611eeb6000830185611e48565b8181036020830152611efd8184611e9d565b90509392505050565b6000611f19611f14846116a6565b61167c565b905082815260208101848484011115611f3557611f346116a1565b5b611f40848285611e73565b509392505050565b600082601f830112611f5d57611f5c61169c565b5b8151611f6d848260208601611f06565b91505092915050565b600060208284031215611f8c57611f8b61157e565b5b600082015167ffffffffffffffff811115611faa57611fa9611583565b5b611fb684828501611f48565b91505092915050565b60006040820190508181036000830152611fd98185611e9d565b9050611fe86020830184611e48565b939250505056fea2646970667358221220556c56bfe7470e41029bd2d120d5744164daae382ebc15478d81f72443079fda64736f6c63430008130033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 12933,
        "contract": "contracts/PairFHE.sol:Pair",
        "label": "token0",
        "offset": 0,
        "slot": "0",
        "type": "t_contract(IERC20)13623"
      },
      {
        "astId": 12936,
        "contract": "contracts/PairFHE.sol:Pair",
        "label": "token1",
        "offset": 0,
        "slot": "1",
        "type": "t_contract(IERC20)13623"
      },
      {
        "astId": 12940,
        "contract": "contracts/PairFHE.sol:Pair",
        "label": "reserve0",
        "offset": 0,
        "slot": "2",
        "type": "t_uint256"
      },
      {
        "astId": 12942,
        "contract": "contracts/PairFHE.sol:Pair",
        "label": "reserve1",
        "offset": 0,
        "slot": "3",
        "type": "t_uint256"
      },
      {
        "astId": 12944,
        "contract": "contracts/PairFHE.sol:Pair",
        "label": "totalSupply",
        "offset": 0,
        "slot": "4",
        "type": "t_uint256"
      },
      {
        "astId": 12948,
        "contract": "contracts/PairFHE.sol:Pair",
        "label": "balanceOf",
        "offset": 0,
        "slot": "5",
        "type": "t_mapping(t_address,t_uint256)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_contract(IERC20)13623": {
        "encoding": "inplace",
        "label": "contract IERC20",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}