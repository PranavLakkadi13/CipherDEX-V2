{
  "address": "0xfb48ca7eCD23A2DfCfeadDEC578Aedf509435E15",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "token0",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "token1",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "pair",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "PairCreated",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "allPairs",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "allPairsLength",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "tokenA",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "tokenB",
          "type": "address"
        }
      ],
      "name": "createPair",
      "outputs": [
        {
          "internalType": "address",
          "name": "pair",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "getPair",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x834ddd2e2f27d2ca3f1da8ffa98e514ed9539ba40d3e3a2ed1734e0c51a53752",
  "receipt": {
    "to": null,
    "from": "0x1B150538E943F00127929f7eeB65754f7beB0B6d",
    "contractAddress": "0xfb48ca7eCD23A2DfCfeadDEC578Aedf509435E15",
    "transactionIndex": 1,
    "gasUsed": "2453852",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xff2f649600136ac8d332dd3582a0213bf1fd44a574579bb0810813fc598eba03",
    "transactionHash": "0x834ddd2e2f27d2ca3f1da8ffa98e514ed9539ba40d3e3a2ed1734e0c51a53752",
    "logs": [],
    "blockNumber": 845,
    "cumulativeGasUsed": "2453852",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 14,
  "solcInputHash": "293cf2bb65d63b54b25f3b0b9ed05bed",
  "metadata": "{\"compiler\":{\"version\":\"0.8.19+commit.7dd6d404\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"PairCreated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allPairs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allPairsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"createPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"getPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/Factory.sol\":\"FactoryFHE\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"@fhenixprotocol/contracts/FHE.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\n// solhint-disable one-contract-per-file\\n\\npragma solidity >=0.8.19 <0.9.0;\\n\\nimport {Precompiles, FheOps} from \\\"./FheOS.sol\\\";\\n\\ntype ebool is uint256;\\ntype euint8 is uint256;\\ntype euint16 is uint256;\\ntype euint32 is uint256;\\n\\nstruct inEbool {\\n    bytes data;\\n}\\nstruct inEuint8 {\\n    bytes data;\\n}\\nstruct inEuint16 {\\n    bytes data;\\n}\\nstruct inEuint32 {\\n    bytes data;\\n}\\n\\nlibrary Common {\\n    // Values used to communicate types to the runtime.\\n    uint8 internal constant EBOOL_TFHE_GO = 0;\\n    uint8 internal constant EUINT8_TFHE_GO = 0;\\n    uint8 internal constant EUINT16_TFHE_GO = 1;\\n    uint8 internal constant EUINT32_TFHE_GO = 2;\\n\\n    function bigIntToBool(uint256 i) internal pure returns (bool) {\\n        return (i > 0);\\n    }\\n\\n    function bigIntToUint8(uint256 i) internal pure returns (uint8) {\\n        return uint8(i);\\n    }\\n\\n    function bigIntToUint16(uint256 i) internal pure returns (uint16) {\\n        return uint16(i);\\n    }\\n\\n    function bigIntToUint32(uint256 i) internal pure returns (uint32) {\\n        return uint32(i);\\n    }\\n\\n    function bigIntToUint64(uint256 i) internal pure returns (uint64) {\\n        return uint64(i);\\n    }\\n\\n    function bigIntToUint128(uint256 i) internal pure returns (uint128) {\\n        return uint128(i);\\n    }\\n\\n    function bigIntToUint256(uint256 i) internal pure returns (uint256) {\\n        return i;\\n    }\\n    \\n    function toBytes(uint256 x) internal pure returns (bytes memory b) {\\n        b = new bytes(32);\\n        assembly { mstore(add(b, 32), x) }\\n    }\\n    \\n}\\n\\nlibrary Impl {\\n    function sealoutput(uint8 utype, uint256 ciphertext, bytes32 publicKey) internal pure returns (bytes memory reencrypted) {\\n        // Call the sealoutput precompile.\\n        reencrypted = FheOps(Precompiles.Fheos).sealOutput(utype, Common.toBytes(ciphertext), bytes.concat(publicKey));\\n\\n        return reencrypted;\\n    }\\n\\n    function verify(bytes memory _ciphertextBytes, uint8 _toType) internal pure returns (uint256 result) {\\n        bytes memory output;\\n\\n        // Call the verify precompile.\\n        output = FheOps(Precompiles.Fheos).verify(_toType, _ciphertextBytes);\\n        result = getValue(output);\\n    }\\n\\n    function cast(uint8 utype, uint256 ciphertext, uint8 toType) internal pure returns (uint256 result) {\\n        bytes memory output;\\n\\n        // Call the cast precompile.\\n        output = FheOps(Precompiles.Fheos).cast(utype, Common.toBytes(ciphertext), toType);\\n        result = getValue(output);\\n    }\\n\\n    function getValue(bytes memory a) internal pure returns (uint256 value) {\\n        assembly {\\n            value := mload(add(a, 0x20))\\n        }\\n    }\\n\\n    function trivialEncrypt(uint256 value, uint8 toType) internal pure returns (uint256 result) {\\n        bytes memory output;\\n\\n        // Call the trivialEncrypt precompile.\\n        output = FheOps(Precompiles.Fheos).trivialEncrypt(Common.toBytes(value), toType);\\n\\n        result = getValue(output);\\n    }\\n\\n    function select(uint8 utype, uint256 control, uint256 ifTrue, uint256 ifFalse) internal pure returns (uint256 result) {\\n        bytes memory output;\\n\\n        // Call the trivialEncrypt precompile.\\n        output = FheOps(Precompiles.Fheos).select(utype, Common.toBytes(control), Common.toBytes(ifTrue), Common.toBytes(ifFalse));\\n\\n        result = getValue(output);\\n    }\\n}\\n\\nlibrary FHE {\\n    euint8 public constant NIL8 = euint8.wrap(0);\\n    euint16 public constant NIL16 = euint16.wrap(0);\\n    euint32 public constant NIL32 = euint32.wrap(0);\\n\\n    // Return true if the encrypted integer is initialized and false otherwise.\\n    function isInitialized(ebool v) internal pure returns (bool) {\\n        return ebool.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the encrypted integer is initialized and false otherwise.\\n    function isInitialized(euint8 v) internal pure returns (bool) {\\n        return euint8.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the encrypted integer is initialized and false otherwise.\\n    function isInitialized(euint16 v) internal pure returns (bool) {\\n        return euint16.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the encrypted integer is initialized and false otherwise.\\n    function isInitialized(euint32 v) internal pure returns (bool) {\\n        return euint32.unwrap(v) != 0;\\n    }\\n\\n    function getValue(bytes memory a) private pure returns (uint256 value) {\\n        assembly {\\n            value := mload(add(a, 0x20))\\n        }\\n    }\\n    \\n    function mathHelper(\\n        uint8 utype,\\n        uint256 lhs,\\n        uint256 rhs,\\n        function(uint8, bytes memory, bytes memory) external pure returns (bytes memory) impl\\n    ) internal pure returns (uint256 result) {\\n        bytes memory output;\\n        output = impl(utype, Common.toBytes(lhs), Common.toBytes(rhs));\\n        result = getValue(output);\\n    }\\n    \\n    /// @notice This functions performs the add operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function add(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).add);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the add operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function add(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).add);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the add operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function add(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).add);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice performs the sealoutput function on a ebool ciphertext. This operation returns the plaintext value, sealed for the public key provided \\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param value Ciphertext to decrypt and seal\\n    /// @param publicKey Public Key that will receive the sealed plaintext\\n    /// @return Plaintext input, sealed for the owner of `publicKey`\\n    function sealoutput(ebool value, bytes32 publicKey) internal pure returns (bytes memory) {\\n        if (!isInitialized(value)) {\\n            value = asEbool(0);\\n        }\\n        uint256 unwrapped = ebool.unwrap(value);\\n\\n        return Impl.sealoutput(Common.EBOOL_TFHE_GO, unwrapped, publicKey);\\n    }\\n    /// @notice performs the sealoutput function on a euint8 ciphertext. This operation returns the plaintext value, sealed for the public key provided \\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param value Ciphertext to decrypt and seal\\n    /// @param publicKey Public Key that will receive the sealed plaintext\\n    /// @return Plaintext input, sealed for the owner of `publicKey`\\n    function sealoutput(euint8 value, bytes32 publicKey) internal pure returns (bytes memory) {\\n        if (!isInitialized(value)) {\\n            value = asEuint8(0);\\n        }\\n        uint256 unwrapped = euint8.unwrap(value);\\n\\n        return Impl.sealoutput(Common.EUINT8_TFHE_GO, unwrapped, publicKey);\\n    }\\n    /// @notice performs the sealoutput function on a euint16 ciphertext. This operation returns the plaintext value, sealed for the public key provided \\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param value Ciphertext to decrypt and seal\\n    /// @param publicKey Public Key that will receive the sealed plaintext\\n    /// @return Plaintext input, sealed for the owner of `publicKey`\\n    function sealoutput(euint16 value, bytes32 publicKey) internal pure returns (bytes memory) {\\n        if (!isInitialized(value)) {\\n            value = asEuint16(0);\\n        }\\n        uint256 unwrapped = euint16.unwrap(value);\\n\\n        return Impl.sealoutput(Common.EUINT16_TFHE_GO, unwrapped, publicKey);\\n    }\\n    /// @notice performs the sealoutput function on a euint32 ciphertext. This operation returns the plaintext value, sealed for the public key provided \\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param value Ciphertext to decrypt and seal\\n    /// @param publicKey Public Key that will receive the sealed plaintext\\n    /// @return Plaintext input, sealed for the owner of `publicKey`\\n    function sealoutput(euint32 value, bytes32 publicKey) internal pure returns (bytes memory) {\\n        if (!isInitialized(value)) {\\n            value = asEuint32(0);\\n        }\\n        uint256 unwrapped = euint32.unwrap(value);\\n\\n        return Impl.sealoutput(Common.EUINT32_TFHE_GO, unwrapped, publicKey);\\n    }\\n    /// @notice Performs the decrypt operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function decrypt(ebool input1) internal pure returns (bool) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEbool(0);\\n        }\\n        uint256 unwrappedInput1 = ebool.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        uint256 result = FheOps(Precompiles.Fheos).decrypt(Common.EBOOL_TFHE_GO, inputAsBytes);\\n        return Common.bigIntToBool(result);\\n    }\\n    /// @notice Performs the decrypt operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function decrypt(euint8 input1) internal pure returns (uint8) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        uint256 result = FheOps(Precompiles.Fheos).decrypt(Common.EUINT8_TFHE_GO, inputAsBytes);\\n        return Common.bigIntToUint8(result);\\n    }\\n    /// @notice Performs the decrypt operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function decrypt(euint16 input1) internal pure returns (uint16) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        uint256 result = FheOps(Precompiles.Fheos).decrypt(Common.EUINT16_TFHE_GO, inputAsBytes);\\n        return Common.bigIntToUint16(result);\\n    }\\n    /// @notice Performs the decrypt operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function decrypt(euint32 input1) internal pure returns (uint32) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        uint256 result = FheOps(Precompiles.Fheos).decrypt(Common.EUINT32_TFHE_GO, inputAsBytes);\\n        return Common.bigIntToUint32(result);\\n    }\\n    /// @notice This functions performs the lte operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function lte(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).lte);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the lte operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function lte(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).lte);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the lte operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function lte(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).lte);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the sub operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function sub(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).sub);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the sub operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function sub(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).sub);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the sub operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function sub(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).sub);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice This functions performs the mul operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function mul(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).mul);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the mul operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function mul(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).mul);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the mul operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function mul(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).mul);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice This functions performs the lt operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function lt(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).lt);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the lt operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function lt(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).lt);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the lt operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function lt(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).lt);\\n        return ebool.wrap(result);\\n    }\\n\\n    function select(ebool input1, ebool input2, ebool input3) internal pure returns (ebool) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEbool(0);\\n        }\\n        if (!isInitialized(input2)) {\\n            input2 = asEbool(0);\\n        }\\n        if (!isInitialized(input3)) {\\n            input3 = asEbool(0);\\n        }\\n\\n        uint256 unwrappedInput1 = ebool.unwrap(input1);\\n        uint256 unwrappedInput2 = ebool.unwrap(input2);\\n        uint256 unwrappedInput3 = ebool.unwrap(input3);\\n\\n        uint256 result = Impl.select(Common.EBOOL_TFHE_GO, unwrappedInput1, unwrappedInput2, unwrappedInput3);\\n        return ebool.wrap(result);\\n    }\\n\\n    function select(ebool input1, euint8 input2, euint8 input3) internal pure returns (euint8) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEbool(0);\\n        }\\n        if (!isInitialized(input2)) {\\n            input2 = asEuint8(0);\\n        }\\n        if (!isInitialized(input3)) {\\n            input3 = asEuint8(0);\\n        }\\n\\n        uint256 unwrappedInput1 = ebool.unwrap(input1);\\n        uint256 unwrappedInput2 = euint8.unwrap(input2);\\n        uint256 unwrappedInput3 = euint8.unwrap(input3);\\n\\n        uint256 result = Impl.select(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, unwrappedInput3);\\n        return euint8.wrap(result);\\n    }\\n\\n    function select(ebool input1, euint16 input2, euint16 input3) internal pure returns (euint16) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEbool(0);\\n        }\\n        if (!isInitialized(input2)) {\\n            input2 = asEuint16(0);\\n        }\\n        if (!isInitialized(input3)) {\\n            input3 = asEuint16(0);\\n        }\\n\\n        uint256 unwrappedInput1 = ebool.unwrap(input1);\\n        uint256 unwrappedInput2 = euint16.unwrap(input2);\\n        uint256 unwrappedInput3 = euint16.unwrap(input3);\\n\\n        uint256 result = Impl.select(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, unwrappedInput3);\\n        return euint16.wrap(result);\\n    }\\n\\n    function select(ebool input1, euint32 input2, euint32 input3) internal pure returns (euint32) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEbool(0);\\n        }\\n        if (!isInitialized(input2)) {\\n            input2 = asEuint32(0);\\n        }\\n        if (!isInitialized(input3)) {\\n            input3 = asEuint32(0);\\n        }\\n\\n        uint256 unwrappedInput1 = ebool.unwrap(input1);\\n        uint256 unwrappedInput2 = euint32.unwrap(input2);\\n        uint256 unwrappedInput3 = euint32.unwrap(input3);\\n\\n        uint256 result = Impl.select(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, unwrappedInput3);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice Performs the req operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function req(ebool input1) internal pure  {\\n        if (!isInitialized(input1)) {\\n            input1 = asEbool(0);\\n        }\\n        uint256 unwrappedInput1 = ebool.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        FheOps(Precompiles.Fheos).req(Common.EBOOL_TFHE_GO, inputAsBytes);\\n    }\\n    /// @notice Performs the req operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function req(euint8 input1) internal pure  {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        FheOps(Precompiles.Fheos).req(Common.EUINT8_TFHE_GO, inputAsBytes);\\n    }\\n    /// @notice Performs the req operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function req(euint16 input1) internal pure  {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        FheOps(Precompiles.Fheos).req(Common.EUINT16_TFHE_GO, inputAsBytes);\\n    }\\n    /// @notice Performs the req operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function req(euint32 input1) internal pure  {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        FheOps(Precompiles.Fheos).req(Common.EUINT32_TFHE_GO, inputAsBytes);\\n    }\\n    /// @notice This functions performs the div operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function div(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).div);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the div operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function div(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).div);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the div operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function div(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).div);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice This functions performs the gt operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function gt(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).gt);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the gt operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function gt(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).gt);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the gt operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function gt(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).gt);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the gte operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function gte(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).gte);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the gte operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function gte(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).gte);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the gte operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function gte(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).gte);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the rem operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function rem(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).rem);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the rem operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function rem(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).rem);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the rem operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function rem(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).rem);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice This functions performs the and operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function and(ebool lhs, ebool rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEbool(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEbool(0);\\n        }\\n        uint256 unwrappedInput1 = ebool.unwrap(lhs);\\n        uint256 unwrappedInput2 = ebool.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EBOOL_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).and);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the and operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function and(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).and);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the and operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function and(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).and);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the and operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function and(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).and);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice This functions performs the or operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function or(ebool lhs, ebool rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEbool(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEbool(0);\\n        }\\n        uint256 unwrappedInput1 = ebool.unwrap(lhs);\\n        uint256 unwrappedInput2 = ebool.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EBOOL_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).or);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the or operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function or(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).or);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the or operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function or(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).or);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the or operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function or(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).or);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice This functions performs the xor operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function xor(ebool lhs, ebool rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEbool(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEbool(0);\\n        }\\n        uint256 unwrappedInput1 = ebool.unwrap(lhs);\\n        uint256 unwrappedInput2 = ebool.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EBOOL_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).xor);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the xor operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function xor(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).xor);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the xor operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function xor(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).xor);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the xor operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function xor(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).xor);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice This functions performs the eq operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function eq(ebool lhs, ebool rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEbool(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEbool(0);\\n        }\\n        uint256 unwrappedInput1 = ebool.unwrap(lhs);\\n        uint256 unwrappedInput2 = ebool.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EBOOL_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).eq);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the eq operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function eq(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).eq);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the eq operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function eq(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).eq);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the eq operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function eq(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).eq);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the ne operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function ne(ebool lhs, ebool rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEbool(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEbool(0);\\n        }\\n        uint256 unwrappedInput1 = ebool.unwrap(lhs);\\n        uint256 unwrappedInput2 = ebool.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EBOOL_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).ne);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the ne operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function ne(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).ne);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the ne operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function ne(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).ne);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the ne operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function ne(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).ne);\\n        return ebool.wrap(result);\\n    }\\n    /// @notice This functions performs the min operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function min(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).min);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the min operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function min(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).min);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the min operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function min(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).min);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice This functions performs the max operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function max(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).max);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the max operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function max(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).max);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the max operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function max(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).max);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice This functions performs the shl operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function shl(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).shl);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the shl operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function shl(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).shl);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the shl operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function shl(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).shl);\\n        return euint32.wrap(result);\\n    }\\n    /// @notice This functions performs the shr operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function shr(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint8(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint8.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT8_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).shr);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice This functions performs the shr operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function shr(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint16(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint16.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT16_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).shr);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice This functions performs the shr operation\\n    /// @dev If any of the inputs are expected to be a ciphertext, it verifies that the value matches a valid ciphertext\\n    ///Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs The first input \\n    /// @param rhs The second input\\n    /// @return The result of the operation\\n    function shr(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        if (!isInitialized(lhs)) {\\n            lhs = asEuint32(0);\\n        }\\n        if (!isInitialized(rhs)) {\\n            rhs = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(lhs);\\n        uint256 unwrappedInput2 = euint32.unwrap(rhs);\\n\\n        uint256 result = mathHelper(Common.EUINT32_TFHE_GO, unwrappedInput1, unwrappedInput2, FheOps(Precompiles.Fheos).shr);\\n        return euint32.wrap(result);\\n    }\\n\\n    /// @notice Performs the \\\"not\\\" for the ebool type\\n    /// @dev Implemented by a workaround due to ebool being a euint8 type behind the scenes, therefore xor is needed to assure that not(true) = false and vise-versa\\n    /// @param value input ebool ciphertext\\n    /// @return Result of the not operation on `value` \\n    function not(ebool value) internal pure returns (ebool) {\\n        return xor(value, asEbool(true));\\n    }\\n    /// @notice Performs the not operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function not(euint8 input1) internal pure returns (euint8) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint8(0);\\n        }\\n        uint256 unwrappedInput1 = euint8.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        bytes memory b = FheOps(Precompiles.Fheos).not(Common.EUINT8_TFHE_GO, inputAsBytes);\\n        uint256 result = Impl.getValue(b);\\n        return euint8.wrap(result);\\n    }\\n    /// @notice Performs the not operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function not(euint16 input1) internal pure returns (euint16) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint16(0);\\n        }\\n        uint256 unwrappedInput1 = euint16.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        bytes memory b = FheOps(Precompiles.Fheos).not(Common.EUINT16_TFHE_GO, inputAsBytes);\\n        uint256 result = Impl.getValue(b);\\n        return euint16.wrap(result);\\n    }\\n    /// @notice Performs the not operation on a ciphertext\\n    /// @dev Verifies that the input value matches a valid ciphertext. Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param input1 the input ciphertext\\n    function not(euint32 input1) internal pure returns (euint32) {\\n        if (!isInitialized(input1)) {\\n            input1 = asEuint32(0);\\n        }\\n        uint256 unwrappedInput1 = euint32.unwrap(input1);\\n        bytes memory inputAsBytes = Common.toBytes(unwrappedInput1);\\n        bytes memory b = FheOps(Precompiles.Fheos).not(Common.EUINT32_TFHE_GO, inputAsBytes);\\n        uint256 result = Impl.getValue(b);\\n        return euint32.wrap(result);\\n    }\\n\\n    // ********** TYPE CASTING ************* //\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an ebool\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEbool(inEbool memory value) internal pure returns (ebool) {\\n        return FHE.asEbool(value.data);\\n    }\\n    /// @notice Converts a ebool to an euint8\\n    function asEuint8(ebool value) internal pure returns (euint8) {\\n        return euint8.wrap(Impl.cast(Common.EBOOL_TFHE_GO, ebool.unwrap(value), Common.EUINT8_TFHE_GO));\\n    }\\n    /// @notice Converts a ebool to an euint16\\n    function asEuint16(ebool value) internal pure returns (euint16) {\\n        return euint16.wrap(Impl.cast(Common.EBOOL_TFHE_GO, ebool.unwrap(value), Common.EUINT16_TFHE_GO));\\n    }\\n    /// @notice Converts a ebool to an euint32\\n    function asEuint32(ebool value) internal pure returns (euint32) {\\n        return euint32.wrap(Impl.cast(Common.EBOOL_TFHE_GO, ebool.unwrap(value), Common.EUINT32_TFHE_GO));\\n    }\\n    \\n    /// @notice Converts a euint8 to an ebool\\n    function asEbool(euint8 value) internal pure returns (ebool) {\\n        return ne(value, asEuint8(0));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint8\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEuint8(inEuint8 memory value) internal pure returns (euint8) {\\n        return FHE.asEuint8(value.data);\\n    }\\n    /// @notice Converts a euint8 to an euint16\\n    function asEuint16(euint8 value) internal pure returns (euint16) {\\n        return euint16.wrap(Impl.cast(Common.EUINT8_TFHE_GO, euint8.unwrap(value), Common.EUINT16_TFHE_GO));\\n    }\\n    /// @notice Converts a euint8 to an euint32\\n    function asEuint32(euint8 value) internal pure returns (euint32) {\\n        return euint32.wrap(Impl.cast(Common.EUINT8_TFHE_GO, euint8.unwrap(value), Common.EUINT32_TFHE_GO));\\n    }\\n    \\n    /// @notice Converts a euint16 to an ebool\\n    function asEbool(euint16 value) internal pure returns (ebool) {\\n        return ne(value, asEuint16(0));\\n    }\\n    /// @notice Converts a euint16 to an euint8\\n    function asEuint8(euint16 value) internal pure returns (euint8) {\\n        return euint8.wrap(Impl.cast(Common.EUINT16_TFHE_GO, euint16.unwrap(value), Common.EUINT8_TFHE_GO));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint16\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEuint16(inEuint16 memory value) internal pure returns (euint16) {\\n        return FHE.asEuint16(value.data);\\n    }\\n    /// @notice Converts a euint16 to an euint32\\n    function asEuint32(euint16 value) internal pure returns (euint32) {\\n        return euint32.wrap(Impl.cast(Common.EUINT16_TFHE_GO, euint16.unwrap(value), Common.EUINT32_TFHE_GO));\\n    }\\n    \\n    /// @notice Converts a euint32 to an ebool\\n    function asEbool(euint32 value) internal pure returns (ebool) {\\n        return ne(value, asEuint32(0));\\n    }\\n    /// @notice Converts a euint32 to an euint8\\n    function asEuint8(euint32 value) internal pure returns (euint8) {\\n        return euint8.wrap(Impl.cast(Common.EUINT32_TFHE_GO, euint32.unwrap(value), Common.EUINT8_TFHE_GO));\\n    }\\n    /// @notice Converts a euint32 to an euint16\\n    function asEuint16(euint32 value) internal pure returns (euint16) {\\n        return euint16.wrap(Impl.cast(Common.EUINT32_TFHE_GO, euint32.unwrap(value), Common.EUINT16_TFHE_GO));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint32\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEuint32(inEuint32 memory value) internal pure returns (euint32) {\\n        return FHE.asEuint32(value.data);\\n    }\\n    /// @notice Converts a uint256 to an ebool\\n    function asEbool(uint256 value) internal pure returns (ebool) {\\n        return ebool.wrap(Impl.trivialEncrypt(value, Common.EBOOL_TFHE_GO));\\n    }\\n    /// @notice Converts a uint256 to an euint8\\n    function asEuint8(uint256 value) internal pure returns (euint8) {\\n        return euint8.wrap(Impl.trivialEncrypt(value, Common.EUINT8_TFHE_GO));\\n    }\\n    /// @notice Converts a uint256 to an euint16\\n    function asEuint16(uint256 value) internal pure returns (euint16) {\\n        return euint16.wrap(Impl.trivialEncrypt(value, Common.EUINT16_TFHE_GO));\\n    }\\n    /// @notice Converts a uint256 to an euint32\\n    function asEuint32(uint256 value) internal pure returns (euint32) {\\n        return euint32.wrap(Impl.trivialEncrypt(value, Common.EUINT32_TFHE_GO));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an ebool\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEbool(bytes memory value) internal pure returns (ebool) {\\n        return ebool.wrap(Impl.verify(value, Common.EBOOL_TFHE_GO));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint8\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEuint8(bytes memory value) internal pure returns (euint8) {\\n        return euint8.wrap(Impl.verify(value, Common.EUINT8_TFHE_GO));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint16\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEuint16(bytes memory value) internal pure returns (euint16) {\\n        return euint16.wrap(Impl.verify(value, Common.EUINT16_TFHE_GO));\\n    }\\n    /// @notice Parses input ciphertexts from the user. Converts from encrypted raw bytes to an euint32\\n    /// @dev Also performs validation that the ciphertext is valid and has been encrypted using the network encryption key\\n    /// @return a ciphertext representation of the input\\n    function asEuint32(bytes memory value) internal pure returns (euint32) {\\n        return euint32.wrap(Impl.verify(value, Common.EUINT32_TFHE_GO));\\n    }\\n    /// @notice Converts a plaintext boolean value to a ciphertext ebool\\n    /// @dev Privacy: The input value is public, therefore the ciphertext should be considered public and should be used\\n    ///only for mathematical operations, not to represent data that should be private\\n    /// @return A ciphertext representation of the input \\n    function asEbool(bool value) internal pure returns (ebool) {\\n        uint256 sVal = 0;\\n        if (value) {\\n            sVal = 1;\\n        }\\n\\n        return asEbool(sVal);\\n    }\\n}\\n\\n// ********** OPERATOR OVERLOADING ************* //\\n\\nusing {operatorAddEuint8 as +} for euint8 global;\\n/// @notice Performs the add operation\\nfunction operatorAddEuint8(euint8 lhs, euint8 rhs) pure returns (euint8) {\\n    return FHE.add(lhs, rhs);\\n}\\n\\nusing {operatorAddEuint16 as +} for euint16 global;\\n/// @notice Performs the add operation\\nfunction operatorAddEuint16(euint16 lhs, euint16 rhs) pure returns (euint16) {\\n    return FHE.add(lhs, rhs);\\n}\\n\\nusing {operatorAddEuint32 as +} for euint32 global;\\n/// @notice Performs the add operation\\nfunction operatorAddEuint32(euint32 lhs, euint32 rhs) pure returns (euint32) {\\n    return FHE.add(lhs, rhs);\\n}\\n\\nusing {operatorSubEuint8 as -} for euint8 global;\\n/// @notice Performs the sub operation\\nfunction operatorSubEuint8(euint8 lhs, euint8 rhs) pure returns (euint8) {\\n    return FHE.sub(lhs, rhs);\\n}\\n\\nusing {operatorSubEuint16 as -} for euint16 global;\\n/// @notice Performs the sub operation\\nfunction operatorSubEuint16(euint16 lhs, euint16 rhs) pure returns (euint16) {\\n    return FHE.sub(lhs, rhs);\\n}\\n\\nusing {operatorSubEuint32 as -} for euint32 global;\\n/// @notice Performs the sub operation\\nfunction operatorSubEuint32(euint32 lhs, euint32 rhs) pure returns (euint32) {\\n    return FHE.sub(lhs, rhs);\\n}\\n\\nusing {operatorMulEuint8 as *} for euint8 global;\\n/// @notice Performs the mul operation\\nfunction operatorMulEuint8(euint8 lhs, euint8 rhs) pure returns (euint8) {\\n    return FHE.mul(lhs, rhs);\\n}\\n\\nusing {operatorMulEuint16 as *} for euint16 global;\\n/// @notice Performs the mul operation\\nfunction operatorMulEuint16(euint16 lhs, euint16 rhs) pure returns (euint16) {\\n    return FHE.mul(lhs, rhs);\\n}\\n\\nusing {operatorMulEuint32 as *} for euint32 global;\\n/// @notice Performs the mul operation\\nfunction operatorMulEuint32(euint32 lhs, euint32 rhs) pure returns (euint32) {\\n    return FHE.mul(lhs, rhs);\\n}\\n\\nusing {operatorDivEuint8 as /} for euint8 global;\\n/// @notice Performs the div operation\\nfunction operatorDivEuint8(euint8 lhs, euint8 rhs) pure returns (euint8) {\\n    return FHE.div(lhs, rhs);\\n}\\n\\nusing {operatorDivEuint16 as /} for euint16 global;\\n/// @notice Performs the div operation\\nfunction operatorDivEuint16(euint16 lhs, euint16 rhs) pure returns (euint16) {\\n    return FHE.div(lhs, rhs);\\n}\\n\\nusing {operatorDivEuint32 as /} for euint32 global;\\n/// @notice Performs the div operation\\nfunction operatorDivEuint32(euint32 lhs, euint32 rhs) pure returns (euint32) {\\n    return FHE.div(lhs, rhs);\\n}\\n\\nusing {operatorOrEbool as |} for ebool global;\\n/// @notice Performs the or operation\\nfunction operatorOrEbool(ebool lhs, ebool rhs) pure returns (ebool) {\\n    return FHE.or(lhs, rhs);\\n}\\n\\nusing {operatorOrEuint8 as |} for euint8 global;\\n/// @notice Performs the or operation\\nfunction operatorOrEuint8(euint8 lhs, euint8 rhs) pure returns (euint8) {\\n    return FHE.or(lhs, rhs);\\n}\\n\\nusing {operatorOrEuint16 as |} for euint16 global;\\n/// @notice Performs the or operation\\nfunction operatorOrEuint16(euint16 lhs, euint16 rhs) pure returns (euint16) {\\n    return FHE.or(lhs, rhs);\\n}\\n\\nusing {operatorOrEuint32 as |} for euint32 global;\\n/// @notice Performs the or operation\\nfunction operatorOrEuint32(euint32 lhs, euint32 rhs) pure returns (euint32) {\\n    return FHE.or(lhs, rhs);\\n}\\n\\nusing {operatorAndEbool as &} for ebool global;\\n/// @notice Performs the and operation\\nfunction operatorAndEbool(ebool lhs, ebool rhs) pure returns (ebool) {\\n    return FHE.and(lhs, rhs);\\n}\\n\\nusing {operatorAndEuint8 as &} for euint8 global;\\n/// @notice Performs the and operation\\nfunction operatorAndEuint8(euint8 lhs, euint8 rhs) pure returns (euint8) {\\n    return FHE.and(lhs, rhs);\\n}\\n\\nusing {operatorAndEuint16 as &} for euint16 global;\\n/// @notice Performs the and operation\\nfunction operatorAndEuint16(euint16 lhs, euint16 rhs) pure returns (euint16) {\\n    return FHE.and(lhs, rhs);\\n}\\n\\nusing {operatorAndEuint32 as &} for euint32 global;\\n/// @notice Performs the and operation\\nfunction operatorAndEuint32(euint32 lhs, euint32 rhs) pure returns (euint32) {\\n    return FHE.and(lhs, rhs);\\n}\\n\\nusing {operatorXorEbool as ^} for ebool global;\\n/// @notice Performs the xor operation\\nfunction operatorXorEbool(ebool lhs, ebool rhs) pure returns (ebool) {\\n    return FHE.xor(lhs, rhs);\\n}\\n\\nusing {operatorXorEuint8 as ^} for euint8 global;\\n/// @notice Performs the xor operation\\nfunction operatorXorEuint8(euint8 lhs, euint8 rhs) pure returns (euint8) {\\n    return FHE.xor(lhs, rhs);\\n}\\n\\nusing {operatorXorEuint16 as ^} for euint16 global;\\n/// @notice Performs the xor operation\\nfunction operatorXorEuint16(euint16 lhs, euint16 rhs) pure returns (euint16) {\\n    return FHE.xor(lhs, rhs);\\n}\\n\\nusing {operatorXorEuint32 as ^} for euint32 global;\\n/// @notice Performs the xor operation\\nfunction operatorXorEuint32(euint32 lhs, euint32 rhs) pure returns (euint32) {\\n    return FHE.xor(lhs, rhs);\\n}\\n\\nusing {operatorRemEuint8 as %} for euint8 global;\\n/// @notice Performs the rem operation\\nfunction operatorRemEuint8(euint8 lhs, euint8 rhs) pure returns (euint8) {\\n    return FHE.rem(lhs, rhs);\\n}\\n\\nusing {operatorRemEuint16 as %} for euint16 global;\\n/// @notice Performs the rem operation\\nfunction operatorRemEuint16(euint16 lhs, euint16 rhs) pure returns (euint16) {\\n    return FHE.rem(lhs, rhs);\\n}\\n\\nusing {operatorRemEuint32 as %} for euint32 global;\\n/// @notice Performs the rem operation\\nfunction operatorRemEuint32(euint32 lhs, euint32 rhs) pure returns (euint32) {\\n    return FHE.rem(lhs, rhs);\\n}\\n\\n// ********** BINDING DEFS ************* //\\n\\nusing BindingsEbool for ebool global;\\nlibrary BindingsEbool {\\n    \\n    /// @notice Performs the eq operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type ebool\\n    /// @return the result of the eq\\n    function eq(ebool lhs, ebool rhs) internal pure returns (ebool) {\\n        return FHE.eq(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the ne operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type ebool\\n    /// @return the result of the ne\\n    function ne(ebool lhs, ebool rhs) internal pure returns (ebool) {\\n        return FHE.ne(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the and operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type ebool\\n    /// @return the result of the and\\n    function and(ebool lhs, ebool rhs) internal pure returns (ebool) {\\n        return FHE.and(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the or operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type ebool\\n    /// @return the result of the or\\n    function or(ebool lhs, ebool rhs) internal pure returns (ebool) {\\n        return FHE.or(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the xor operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type ebool\\n    /// @return the result of the xor\\n    function xor(ebool lhs, ebool rhs) internal pure returns (ebool) {\\n        return FHE.xor(lhs, rhs);\\n    }\\n    function toU8(ebool value) internal pure returns (euint8) {\\n        return FHE.asEuint8(value);\\n    }\\n    function toU16(ebool value) internal pure returns (euint16) {\\n        return FHE.asEuint16(value);\\n    }\\n    function toU32(ebool value) internal pure returns (euint32) {\\n        return FHE.asEuint32(value);\\n    }\\n    function seal(ebool value, bytes32 publicKey) internal pure returns (bytes memory) {\\n        return FHE.sealoutput(value, publicKey);\\n    }\\n}\\n\\nusing BindingsEuint8 for euint8 global;\\nlibrary BindingsEuint8 {\\n    \\n    /// @notice Performs the add operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the add\\n    function add(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.add(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the mul operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the mul\\n    function mul(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.mul(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the div operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the div\\n    function div(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.div(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the sub operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the sub\\n    function sub(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.sub(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the eq operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the eq\\n    function eq(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        return FHE.eq(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the ne operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the ne\\n    function ne(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        return FHE.ne(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the and operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the and\\n    function and(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.and(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the or operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the or\\n    function or(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.or(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the xor operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the xor\\n    function xor(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.xor(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the gt operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the gt\\n    function gt(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        return FHE.gt(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the gte operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the gte\\n    function gte(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        return FHE.gte(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the lt operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the lt\\n    function lt(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        return FHE.lt(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the lte operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the lte\\n    function lte(euint8 lhs, euint8 rhs) internal pure returns (ebool) {\\n        return FHE.lte(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the rem operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the rem\\n    function rem(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.rem(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the max operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the max\\n    function max(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.max(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the min operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the min\\n    function min(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.min(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the shl operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the shl\\n    function shl(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.shl(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the shr operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint8\\n    /// @return the result of the shr\\n    function shr(euint8 lhs, euint8 rhs) internal pure returns (euint8) {\\n        return FHE.shr(lhs, rhs);\\n    }\\n    function toBool(euint8 value) internal pure returns (ebool) {\\n        return FHE.asEbool(value);\\n    }\\n    function toU16(euint8 value) internal pure returns (euint16) {\\n        return FHE.asEuint16(value);\\n    }\\n    function toU32(euint8 value) internal pure returns (euint32) {\\n        return FHE.asEuint32(value);\\n    }\\n    function seal(euint8 value, bytes32 publicKey) internal pure returns (bytes memory) {\\n        return FHE.sealoutput(value, publicKey);\\n    }\\n}\\n\\nusing BindingsEuint16 for euint16 global;\\nlibrary BindingsEuint16 {\\n    \\n    /// @notice Performs the add operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the add\\n    function add(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.add(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the mul operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the mul\\n    function mul(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.mul(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the div operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the div\\n    function div(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.div(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the sub operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the sub\\n    function sub(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.sub(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the eq operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the eq\\n    function eq(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        return FHE.eq(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the ne operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the ne\\n    function ne(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        return FHE.ne(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the and operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the and\\n    function and(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.and(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the or operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the or\\n    function or(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.or(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the xor operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the xor\\n    function xor(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.xor(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the gt operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the gt\\n    function gt(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        return FHE.gt(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the gte operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the gte\\n    function gte(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        return FHE.gte(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the lt operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the lt\\n    function lt(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        return FHE.lt(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the lte operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the lte\\n    function lte(euint16 lhs, euint16 rhs) internal pure returns (ebool) {\\n        return FHE.lte(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the rem operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the rem\\n    function rem(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.rem(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the max operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the max\\n    function max(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.max(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the min operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the min\\n    function min(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.min(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the shl operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the shl\\n    function shl(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.shl(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the shr operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint16\\n    /// @return the result of the shr\\n    function shr(euint16 lhs, euint16 rhs) internal pure returns (euint16) {\\n        return FHE.shr(lhs, rhs);\\n    }\\n    function toBool(euint16 value) internal pure returns (ebool) {\\n        return FHE.asEbool(value);\\n    }\\n    function toU8(euint16 value) internal pure returns (euint8) {\\n        return FHE.asEuint8(value);\\n    }\\n    function toU32(euint16 value) internal pure returns (euint32) {\\n        return FHE.asEuint32(value);\\n    }\\n    function seal(euint16 value, bytes32 publicKey) internal pure returns (bytes memory) {\\n        return FHE.sealoutput(value, publicKey);\\n    }\\n}\\n\\nusing BindingsEuint32 for euint32 global;\\nlibrary BindingsEuint32 {\\n    \\n    /// @notice Performs the add operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the add\\n    function add(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.add(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the mul operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the mul\\n    function mul(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.mul(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the div operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the div\\n    function div(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.div(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the sub operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the sub\\n    function sub(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.sub(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the eq operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the eq\\n    function eq(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        return FHE.eq(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the ne operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the ne\\n    function ne(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        return FHE.ne(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the and operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the and\\n    function and(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.and(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the or operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the or\\n    function or(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.or(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the xor operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the xor\\n    function xor(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.xor(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the gt operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the gt\\n    function gt(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        return FHE.gt(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the gte operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the gte\\n    function gte(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        return FHE.gte(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the lt operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the lt\\n    function lt(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        return FHE.lt(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the lte operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the lte\\n    function lte(euint32 lhs, euint32 rhs) internal pure returns (ebool) {\\n        return FHE.lte(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the rem operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the rem\\n    function rem(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.rem(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the max operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the max\\n    function max(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.max(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the min operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the min\\n    function min(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.min(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the shl operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the shl\\n    function shl(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.shl(lhs, rhs);\\n    }\\n    \\n    /// @notice Performs the shr operation\\n    /// @dev Pure in this function is marked as a hack/workaround - note that this function is NOT pure as fetches of ciphertexts require state access\\n    /// @param lhs input of type euint32\\n    /// @return the result of the shr\\n    function shr(euint32 lhs, euint32 rhs) internal pure returns (euint32) {\\n        return FHE.shr(lhs, rhs);\\n    }\\n    function toBool(euint32 value) internal pure returns (ebool) {\\n        return FHE.asEbool(value);\\n    }\\n    function toU8(euint32 value) internal pure returns (euint8) {\\n        return FHE.asEuint8(value);\\n    }\\n    function toU16(euint32 value) internal pure returns (euint16) {\\n        return FHE.asEuint16(value);\\n    }\\n    function seal(euint32 value, bytes32 publicKey) internal pure returns (bytes memory) {\\n        return FHE.sealoutput(value, publicKey);\\n    }\\n}\",\"keccak256\":\"0xcacb424fc161e575629898845524b6298a1fe1a5d91d6e382963aed549fe8030\",\"license\":\"BSD-3-Clause-Clear\"},\"@fhenixprotocol/contracts/FheOS.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\n// solhint-disable one-contract-per-file\\npragma solidity >=0.8.13 <0.9.0;\\n\\nlibrary Precompiles {\\n    //solhint-disable const-name-snakecase\\n    address public constant Fheos = address(128);\\n}\\n\\ninterface FheOps {\\n    function add(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function verify(uint8 utype, bytes memory input) external pure returns (bytes memory);\\n    function sealOutput(uint8 utype, bytes memory ctHash, bytes memory pk) external pure returns (bytes memory);\\n    function decrypt(uint8 utype, bytes memory input) external pure returns (uint256);\\n    function lte(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function sub(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function mul(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function lt(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function select(uint8 utype, bytes memory controlHash, bytes memory ifTrueHash, bytes memory ifFalseHash) external pure returns (bytes memory);\\n    function req(uint8 utype, bytes memory input) external pure returns (bytes memory);\\n    function cast(uint8 utype, bytes memory input, uint8 toType) external pure returns (bytes memory);\\n    function trivialEncrypt(bytes memory input, uint8 toType) external pure returns (bytes memory);\\n    function div(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function gt(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function gte(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function rem(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function and(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function or(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function xor(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function eq(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function ne(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function min(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function max(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function shl(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function shr(uint8 utype, bytes memory lhsHash, bytes memory rhsHash) external pure returns (bytes memory);\\n    function not(uint8 utype, bytes memory value) external pure returns (bytes memory);\\n    function getNetworkPublicKey() external pure returns (bytes memory);\\n}\",\"keccak256\":\"0xb78d3a9c2c7ef5864741ab6a27aceadced3bc624e13e4abe8c37342988014574\",\"license\":\"BSD-3-Clause-Clear\"},\"contracts/EncryptedPairFHE.sol\":{\"content\":\"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\\npragma solidity ^0.8.19;\\n\\nimport \\\"@fhenixprotocol/contracts/FHE.sol\\\";\\nimport \\\"./interfaces/IERC20.sol\\\";\\n\\ncontract Pair {\\n\\n    IERC20 public token0;\\n    IERC20 public token1;\\n    address public  factory;\\n\\n    uint public reserve0;\\n    uint public reserve1;\\n\\n    uint public totalSupply;\\n    mapping(address => uint) public balanceOf;\\n\\n    constructor() {\\n        factory = msg.sender;\\n    }\\n\\n    function initialize(address _token0, address _token1) external {\\n        require(msg.sender == factory, 'Only Factory can call this'); // sufficient check\\n        token0 = IERC20(_token0);\\n        token1 = IERC20(_token1);\\n    }\\n\\n    function _mint(address _to, uint _amount) private {\\n        balanceOf[_to] += _amount;\\n        totalSupply += _amount;\\n    }\\n\\n    function _burn(address _from, uint _amount) private {\\n        balanceOf[_from] -= _amount;\\n        totalSupply -= _amount;\\n    }\\n\\n    function _update(uint _reserve0, uint _reserve1) private {\\n        reserve0 = _reserve0;\\n        reserve1 = _reserve1;\\n    }\\n\\n    function swap(address _tokenIn, inEuint32 calldata _amountIn) external returns (uint amountOut) {\\n        // euint32 x = TFHE.asEuint32(_amountIn);\\n        // uint32 amountIn = TFHE.decrypt(x);\\n        euint32 x = FHE.asEuint32(_amountIn);\\n        uint256 amountIn = FHE.decrypt(x);\\n        require(\\n            _tokenIn == address(token0) || _tokenIn == address(token1),\\n            \\\"invalid token\\\"\\n        );\\n        require(uint256(amountIn) > 0, \\\"amount in = 0\\\");\\n\\n        bool isToken0 = _tokenIn == address(token0);\\n        (IERC20 tokenIn, IERC20 tokenOut, uint reserveIn, uint reserveOut) = isToken0\\n            ? (token0, token1, reserve0, reserve1)\\n            : (token1, token0, reserve1, reserve0);\\n\\n        tokenIn.transferFrom(msg.sender, address(this), uint256(amountIn));\\n\\n        uint amountInWithFee = (uint256(amountIn) * 997) / 1000;\\n        amountOut = (reserveOut * amountInWithFee) / (reserveIn + amountInWithFee);\\n\\n        tokenOut.transfer(msg.sender, uint256(amountOut));\\n\\n        _update(token0.balanceOf(address(this)), token1.balanceOf(address(this)));\\n    }\\n\\n    function addLiquidity(inEuint32 calldata _amount0, inEuint32 calldata _amount1) external returns (uint shares) {\\n        // euint32 x = TFHE.asEuint32(_amount0);\\n        // euint32 y = TFHE.asEuint32(_amount1);\\n        // uint32 amount0 = TFHE.decrypt(x);\\n        // uint32 amount1 = TFHE.decrypt(y);\\n\\n        euint32 x = FHE.asEuint32(_amount0);\\n        euint32 y = FHE.asEuint32(_amount1);\\n        uint32 amount0 = FHE.decrypt(x);\\n        uint32 amount1 = FHE.decrypt(y);\\n        \\n        bool t = token0.transferFrom(msg.sender, address(this), uint256(amount0));\\n        bool tt = token1.transferFrom(msg.sender, address(this), uint256(amount1));\\n        require(t && tt);\\n\\n        if (reserve0 > 0 || reserve1 > 0) {\\n            require(reserve0 * uint256(amount1) == reserve1 * uint256(amount0), \\\"x / y != dx / dy\\\");\\n        }\\n\\n        if (totalSupply == 0) {\\n            shares = _sqrt(uint256(amount0) * uint256(amount1));\\n        } else {\\n            shares = _min(\\n                (uint256(amount0) * totalSupply) / reserve0,\\n                (uint256(amount1) * totalSupply) / reserve1\\n            );\\n        }\\n        require(shares > 0, \\\"shares = 0\\\");\\n        _mint(msg.sender, shares);\\n\\n        _update(token0.balanceOf(address(this)), token1.balanceOf(address(this)));\\n    }\\n\\n    function removeLiquidity(\\n        inEuint32 calldata _shares\\n    ) external returns (uint amount0, uint amount1) {\\n        \\n        euint32 x = FHE.asEuint32(_shares);\\n\\n        uint32 shares = FHE.decrypt(x);\\n        uint bal0 = token0.balanceOf(address(this));\\n        uint bal1 = token1.balanceOf(address(this));\\n\\n        amount0 = (uint256(shares) * bal0) / totalSupply;\\n        amount1 = (uint256(shares) * bal1) / totalSupply;\\n        require(amount0 > 0 && amount1 > 0, \\\"amount0 or amount1 = 0\\\");\\n\\n        _burn(msg.sender, shares);\\n        _update(bal0 - amount0, bal1 - amount1);\\n\\n        token0.transfer(msg.sender, uint256(amount0));\\n        token1.transfer(msg.sender, uint256(amount1));\\n    }\\n\\n    function _sqrt(uint y) private pure returns (uint z) {\\n        if (y > 3) {\\n            z = y;\\n            uint x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n\\n    function _min(uint x, uint y) private pure returns (uint) {\\n        return x <= y ? x : y;\\n    }\\n}\",\"keccak256\":\"0xa822807b4d0370aaab13e38b45fab7274bb40087387629c16bc25e278f0aca2f\",\"license\":\"SEE LICENSE IN LICENSE\"},\"contracts/Factory.sol\":{\"content\":\"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\\npragma solidity 0.8.19;\\n\\nimport \\\"./EncryptedPairFHE.sol\\\";\\n\\nimport \\\"hardhat/console.sol\\\";\\n\\ncontract FactoryFHE {\\n\\n    mapping(address => mapping(address => address)) public getPair;\\n\\n    address[] public allPairs;\\n\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function allPairsLength() external view returns (uint) {\\n        return allPairs.length;\\n    }\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair) {\\n        console.log(\\\"done\\\");\\n        require(tokenA != tokenB, 'IDENTICAL_ADDRESSES');\\n        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\n        console.log(\\\"The address of token0 \\\", token0);\\n        require(token0 != address(0), 'ZERO_ADDRESS');\\n        require(getPair[token0][token1] == address(0), 'PAIR_EXISTS'); // single check is sufficient\\n        bytes memory bytecode = type(Pair).creationCode;\\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1,msg.sender));\\n        assembly {\\n            pair := create2(0xff, add(bytecode, 32), mload(bytecode), salt)\\n        }\\n        // require(pair != address(0),\\\"Pair not created\\\");\\n        if (pair == address(0)) {\\n            revert();\\n        }\\n        Pair(pair).initialize(token0, token1);\\n        getPair[token0][token1] = pair;\\n        getPair[token1][token0] = pair; // populate mapping in the reverse direction\\n        allPairs.push(pair);\\n        emit PairCreated(token0, token1, pair, allPairs.length);\\n        return pair;\\n    }\\n}\\n\",\"keccak256\":\"0xb9f1d37fb73f5ba339a92a2e5bc77791ff0aef34ddb727c302a590394681dd15\",\"license\":\"SEE LICENSE IN LICENSE\"},\"contracts/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT \\npragma solidity 0.8.19;\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint);\\n\\n    function balanceOf(address account) external view returns (uint);\\n\\n    function transfer(address recipient, uint amount) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint amount);\\n    event Approval(address indexed owner, address indexed spender, uint amount);\\n}\",\"keccak256\":\"0xae058ace57820dbff0fcf74f417f6ffb33f6462967b919913a80673b177bd613\",\"license\":\"MIT\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\n\\nlibrary console {\\n    address constant CONSOLE_ADDRESS =\\n        0x000000000000000000636F6e736F6c652e6c6f67;\\n\\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\\n        address consoleAddress = CONSOLE_ADDRESS;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            pop(\\n                staticcall(\\n                    gas(),\\n                    consoleAddress,\\n                    add(payload, 32),\\n                    mload(payload),\\n                    0,\\n                    0\\n                )\\n            )\\n        }\\n    }\\n\\n    function _castToPure(\\n      function(bytes memory) internal view fnIn\\n    ) internal pure returns (function(bytes memory) pure fnOut) {\\n        assembly {\\n            fnOut := fnIn\\n        }\\n    }\\n\\n    function _sendLogPayload(bytes memory payload) internal pure {\\n        _castToPure(_sendLogPayloadImplementation)(payload);\\n    }\\n\\n    function log() internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n    }\\n    function logInt(int256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n    }\\n\\n    function logUint(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function logString(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function logBool(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function logAddress(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function logBytes(bytes memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n    }\\n\\n    function logBytes1(bytes1 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n    }\\n\\n    function logBytes2(bytes2 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n    }\\n\\n    function logBytes3(bytes3 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n    }\\n\\n    function logBytes4(bytes4 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n    }\\n\\n    function logBytes5(bytes5 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n    }\\n\\n    function logBytes6(bytes6 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n    }\\n\\n    function logBytes7(bytes7 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n    }\\n\\n    function logBytes8(bytes8 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n    }\\n\\n    function logBytes9(bytes9 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n    }\\n\\n    function logBytes10(bytes10 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n    }\\n\\n    function logBytes11(bytes11 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n    }\\n\\n    function logBytes12(bytes12 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n    }\\n\\n    function logBytes13(bytes13 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n    }\\n\\n    function logBytes14(bytes14 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n    }\\n\\n    function logBytes15(bytes15 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n    }\\n\\n    function logBytes16(bytes16 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n    }\\n\\n    function logBytes17(bytes17 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n    }\\n\\n    function logBytes18(bytes18 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n    }\\n\\n    function logBytes19(bytes19 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n    }\\n\\n    function logBytes20(bytes20 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n    }\\n\\n    function logBytes21(bytes21 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n    }\\n\\n    function logBytes22(bytes22 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n    }\\n\\n    function logBytes23(bytes23 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n    }\\n\\n    function logBytes24(bytes24 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n    }\\n\\n    function logBytes25(bytes25 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n    }\\n\\n    function logBytes26(bytes26 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n    }\\n\\n    function logBytes27(bytes27 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n    }\\n\\n    function logBytes28(bytes28 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n    }\\n\\n    function logBytes29(bytes29 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n    }\\n\\n    function logBytes30(bytes30 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n    }\\n\\n    function logBytes31(bytes31 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n    }\\n\\n    function logBytes32(bytes32 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n    }\\n\\n    function log(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function log(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function log(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function log(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function log(uint256 p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n}\\n\",\"keccak256\":\"0x7434453e6d3b7d0e5d0eb7846ffdbc27f0ccf3b163591263739b628074dc103a\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50612ec4806100206000396000f3fe608060405234801561001057600080fd5b506004361061004c5760003560e01c80631e3dd18b14610051578063574f2ba314610081578063c9c653961461009f578063e6a43905146100cf575b600080fd5b61006b6004803603810190610066919061095a565b6100ff565b60405161007891906109c8565b60405180910390f35b61008961013e565b60405161009691906109f2565b60405180910390f35b6100b960048036038101906100b49190610a39565b61014b565b6040516100c691906109c8565b60405180910390f35b6100e960048036038101906100e49190610a39565b61074b565b6040516100f691906109c8565b60405180910390f35b6001818154811061010f57600080fd5b906000526020600020016000915054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6000600180549050905090565b600061018b6040518060400160405280600481526020017f646f6e650000000000000000000000000000000000000000000000000000000081525061078d565b8173ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff16036101f9576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016101f090610ad6565b60405180910390fd5b6000808373ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff1610610236578385610239565b84845b9150915061027c6040518060400160405280601681526020017f5468652061646472657373206f6620746f6b656e30200000000000000000000081525083610826565b600073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16036102eb576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016102e290610b42565b60405180910390fd5b600073ffffffffffffffffffffffffffffffffffffffff166000808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16146103f5576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016103ec90610bae565b60405180910390fd5b60006040518060200161040790610908565b6020820181038252601f19601f820116604052509050600083833360405160200161043493929190610c16565b6040516020818303038152906040528051906020012090508082516020840160fff59450600073ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff160361049157600080fd5b8473ffffffffffffffffffffffffffffffffffffffff1663485cc95585856040518363ffffffff1660e01b81526004016104cc929190610c53565b600060405180830381600087803b1580156104e657600080fd5b505af11580156104fa573d6000803e3d6000fd5b50505050846000808673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550846000808573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506001859080600181540180825580915050600190039060005260206000200160009091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff167f0d3648bd0f6ba80134a33ba9275ac585d9d315f0ad8355cddefde31afa28d0e987600180549050604051610739929190610c7c565b60405180910390a35050505092915050565b60006020528160005260406000206020528060005260406000206000915091509054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b610823816040516024016107a19190610d24565b6040516020818303038152906040527f41304fac000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff83818316178352505050506108c2565b50565b6108be828260405160240161083c929190610d46565b6040516020818303038152906040527f319af333000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff83818316178352505050506108c2565b5050565b6108d9816108d16108dc6108fd565b63ffffffff16565b50565b60006a636f6e736f6c652e6c6f679050600080835160208501845afa505050565b610915819050919050565b6120e980610da683390190565b61091d610d76565b565b600080fd5b6000819050919050565b61093781610924565b811461094257600080fd5b50565b6000813590506109548161092e565b92915050565b6000602082840312156109705761096f61091f565b5b600061097e84828501610945565b91505092915050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006109b282610987565b9050919050565b6109c2816109a7565b82525050565b60006020820190506109dd60008301846109b9565b92915050565b6109ec81610924565b82525050565b6000602082019050610a0760008301846109e3565b92915050565b610a16816109a7565b8114610a2157600080fd5b50565b600081359050610a3381610a0d565b92915050565b60008060408385031215610a5057610a4f61091f565b5b6000610a5e85828601610a24565b9250506020610a6f85828601610a24565b9150509250929050565b600082825260208201905092915050565b7f4944454e544943414c5f41444452455353455300000000000000000000000000600082015250565b6000610ac0601383610a79565b9150610acb82610a8a565b602082019050919050565b60006020820190508181036000830152610aef81610ab3565b9050919050565b7f5a45524f5f414444524553530000000000000000000000000000000000000000600082015250565b6000610b2c600c83610a79565b9150610b3782610af6565b602082019050919050565b60006020820190508181036000830152610b5b81610b1f565b9050919050565b7f504149525f455849535453000000000000000000000000000000000000000000600082015250565b6000610b98600b83610a79565b9150610ba382610b62565b602082019050919050565b60006020820190508181036000830152610bc781610b8b565b9050919050565b60008160601b9050919050565b6000610be682610bce565b9050919050565b6000610bf882610bdb565b9050919050565b610c10610c0b826109a7565b610bed565b82525050565b6000610c228286610bff565b601482019150610c328285610bff565b601482019150610c428284610bff565b601482019150819050949350505050565b6000604082019050610c6860008301856109b9565b610c7560208301846109b9565b9392505050565b6000604082019050610c9160008301856109b9565b610c9e60208301846109e3565b9392505050565b600081519050919050565b60005b83811015610cce578082015181840152602081019050610cb3565b60008484015250505050565b6000601f19601f8301169050919050565b6000610cf682610ca5565b610d008185610a79565b9350610d10818560208601610cb0565b610d1981610cda565b840191505092915050565b60006020820190508181036000830152610d3e8184610ceb565b905092915050565b60006040820190508181036000830152610d608185610ceb565b9050610d6f60208301846109b9565b9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052605160045260246000fdfe608060405234801561001057600080fd5b5033600260006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550612088806100616000396000f3fe608060405234801561001057600080fd5b50600436106100a95760003560e01c80635a76f25e116100715780635a76f25e146101545780635b18de5f1461017257806370a08231146101a357806374bfd999146101d3578063c45a015514610203578063d21220a714610221576100a9565b80630dfe1681146100ae57806318160ddd146100cc578063443cb4bc146100ea578063485cc9551461010857806352dc029114610124575b600080fd5b6100b661023f565b6040516100c39190611551565b60405180910390f35b6100d4610263565b6040516100e19190611585565b60405180910390f35b6100f2610269565b6040516100ff9190611585565b60405180910390f35b610122600480360381019061011d91906115f2565b61026f565b005b61013e60048036038101906101399190611656565b610384565b60405161014b9190611585565b60405180910390f35b61015c6107cb565b6040516101699190611585565b60405180910390f35b61018c600480360381019061018791906116ce565b6107d1565b60405161019a929190611717565b60405180910390f35b6101bd60048036038101906101b89190611740565b610b40565b6040516101ca9190611585565b60405180910390f35b6101ed60048036038101906101e8919061176d565b610b58565b6040516101fa9190611585565b60405180910390f35b61020b61103b565b60405161021891906117d8565b60405180910390f35b610229611061565b6040516102369190611551565b60405180910390f35b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b60055481565b60035481565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146102ff576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016102f690611850565b60405180910390fd5b816000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555080600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505050565b6000806103998461039490611a18565b611087565b905060006103af846103aa90611a18565b611087565b905060006103bc8361109d565b905060006103c98361109d565b905060008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166323b872dd33308663ffffffff166040518463ffffffff1660e01b815260040161043193929190611a2b565b6020604051808303816000875af1158015610450573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104749190611a9a565b90506000600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166323b872dd33308663ffffffff166040518463ffffffff1660e01b81526004016104dd93929190611a2b565b6020604051808303816000875af11580156104fc573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105209190611a9a565b905081801561052c5750805b61053557600080fd5b6000600354118061054857506000600454115b156105b6578363ffffffff166004546105619190611af6565b8363ffffffff166003546105759190611af6565b146105b5576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016105ac90611b84565b60405180910390fd5b5b6000600554036105e7576105e08363ffffffff168563ffffffff166105db9190611af6565b611160565b9650610634565b6106316003546005548663ffffffff166106019190611af6565b61060b9190611bd3565b6004546005548663ffffffff166106229190611af6565b61062c9190611bd3565b6111da565b96505b60008711610677576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161066e90611c50565b60405180910390fd5b61068133886111f4565b6107bf60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b81526004016106dd91906117d8565b602060405180830381865afa1580156106fa573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061071e9190611c9c565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b815260040161077991906117d8565b602060405180830381865afa158015610796573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107ba9190611c9c565b611267565b50505050505092915050565b60045481565b60008060006107e8846107e390611a18565b611087565b905060006107f58261109d565b905060008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b815260040161085391906117d8565b602060405180830381865afa158015610870573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108949190611c9c565b90506000600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b81526004016108f391906117d8565b602060405180830381865afa158015610910573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109349190611c9c565b9050600554828463ffffffff1661094b9190611af6565b6109559190611bd3565b9550600554818463ffffffff1661096c9190611af6565b6109769190611bd3565b94506000861180156109885750600085115b6109c7576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016109be90611d15565b60405180910390fd5b6109d7338463ffffffff16611279565b6109f786836109e69190611d35565b86836109f29190611d35565b611267565b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a9059cbb33886040518363ffffffff1660e01b8152600401610a52929190611d69565b6020604051808303816000875af1158015610a71573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a959190611a9a565b50600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a9059cbb33876040518363ffffffff1660e01b8152600401610af3929190611d69565b6020604051808303816000875af1158015610b12573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b369190611a9a565b5050505050915091565b60066020528060005260406000206000915090505481565b600080610b6d83610b6890611a18565b611087565b90506000610b7a8261109d565b63ffffffff16905060008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff161480610c295750600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff16145b610c68576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610c5f90611dde565b60405180910390fd5b60008111610cab576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610ca290611e4a565b60405180910390fd5b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168673ffffffffffffffffffffffffffffffffffffffff1614905060008060008084610d5957600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1660008054906101000a900473ffffffffffffffffffffffffffffffffffffffff16600454600354610da4565b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff16600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff166003546004545b93509350935093508373ffffffffffffffffffffffffffffffffffffffff166323b872dd3330896040518463ffffffff1660e01b8152600401610de993929190611a2b565b6020604051808303816000875af1158015610e08573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e2c9190611a9a565b5060006103e86103e588610e409190611af6565b610e4a9190611bd3565b90508083610e589190611e6a565b8183610e649190611af6565b610e6e9190611bd3565b98508373ffffffffffffffffffffffffffffffffffffffff1663a9059cbb338b6040518363ffffffff1660e01b8152600401610eab929190611d69565b6020604051808303816000875af1158015610eca573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610eee9190611a9a565b5061102d60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b8152600401610f4b91906117d8565b602060405180830381865afa158015610f68573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f8c9190611c9c565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b8152600401610fe791906117d8565b602060405180830381865afa158015611004573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110289190611c9c565b611267565b505050505050505092915050565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b600061109682600001516112ec565b9050919050565b60006110a882611300565b6110b9576110b6600061130d565b91505b600082905060006110c982611321565b90506000608073ffffffffffffffffffffffffffffffffffffffff166373cc01546002846040518363ffffffff1660e01b815260040161110a929190611f39565b602060405180830381865afa158015611127573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061114b9190611c9c565b90506111568161137e565b9350505050919050565b600060038211156111c7578190506000600160028461117f9190611bd3565b6111899190611e6a565b90505b818110156111c15780915060028182856111a69190611bd3565b6111b09190611e6a565b6111ba9190611bd3565b905061118c565b506111d5565b600082146111d457600190505b5b919050565b6000818311156111ea57816111ec565b825b905092915050565b80600660008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546112439190611e6a565b92505081905550806005600082825461125c9190611e6a565b925050819055505050565b81600381905550806004819055505050565b80600660008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546112c89190611d35565b9250508190555080600560008282546112e19190611d35565b925050819055505050565b60006112f9826002611388565b9050919050565b6000808214159050919050565b600061131a826002611422565b9050919050565b6060602067ffffffffffffffff81111561133e5761133d611886565b5b6040519080825280601f01601f1916602001820160405280156113705781602001600182028036833780820191505090505b509050816020820152919050565b6000819050919050565b60006060608073ffffffffffffffffffffffffffffffffffffffff16635fa55ca784866040518363ffffffff1660e01b81526004016113c8929190611f39565b600060405180830381865afa1580156113e5573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f8201168201806040525081019061140e9190611fd9565b9050611419816114c4565b91505092915050565b60006060608073ffffffffffffffffffffffffffffffffffffffff166319e1c5c461144c86611321565b856040518363ffffffff1660e01b815260040161146a929190612022565b600060405180830381865afa158015611487573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f820116820180604052508101906114b09190611fd9565b90506114bb816114c4565b91505092915050565b600060208201519050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000819050919050565b600061151761151261150d846114d2565b6114f2565b6114d2565b9050919050565b6000611529826114fc565b9050919050565b600061153b8261151e565b9050919050565b61154b81611530565b82525050565b60006020820190506115666000830184611542565b92915050565b6000819050919050565b61157f8161156c565b82525050565b600060208201905061159a6000830184611576565b92915050565b6000604051905090565b600080fd5b600080fd5b60006115bf826114d2565b9050919050565b6115cf816115b4565b81146115da57600080fd5b50565b6000813590506115ec816115c6565b92915050565b60008060408385031215611609576116086115aa565b5b6000611617858286016115dd565b9250506020611628858286016115dd565b9150509250929050565b600080fd5b60006020828403121561164d5761164c611632565b5b81905092915050565b6000806040838503121561166d5761166c6115aa565b5b600083013567ffffffffffffffff81111561168b5761168a6115af565b5b61169785828601611637565b925050602083013567ffffffffffffffff8111156116b8576116b76115af565b5b6116c485828601611637565b9150509250929050565b6000602082840312156116e4576116e36115aa565b5b600082013567ffffffffffffffff811115611702576117016115af565b5b61170e84828501611637565b91505092915050565b600060408201905061172c6000830185611576565b6117396020830184611576565b9392505050565b600060208284031215611756576117556115aa565b5b6000611764848285016115dd565b91505092915050565b60008060408385031215611784576117836115aa565b5b6000611792858286016115dd565b925050602083013567ffffffffffffffff8111156117b3576117b26115af565b5b6117bf85828601611637565b9150509250929050565b6117d2816115b4565b82525050565b60006020820190506117ed60008301846117c9565b92915050565b600082825260208201905092915050565b7f4f6e6c7920466163746f72792063616e2063616c6c2074686973000000000000600082015250565b600061183a601a836117f3565b915061184582611804565b602082019050919050565b600060208201905081810360008301526118698161182d565b9050919050565b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6118be82611875565b810181811067ffffffffffffffff821117156118dd576118dc611886565b5b80604052505050565b60006118f06115a0565b90506118fc82826118b5565b919050565b600080fd5b600080fd5b600080fd5b600067ffffffffffffffff82111561192b5761192a611886565b5b61193482611875565b9050602081019050919050565b82818337600083830152505050565b600061196361195e84611910565b6118e6565b90508281526020810184848401111561197f5761197e61190b565b5b61198a848285611941565b509392505050565b600082601f8301126119a7576119a6611906565b5b81356119b7848260208601611950565b91505092915050565b6000602082840312156119d6576119d5611870565b5b6119e060206118e6565b9050600082013567ffffffffffffffff811115611a00576119ff611901565b5b611a0c84828501611992565b60008301525092915050565b6000611a2436836119c0565b9050919050565b6000606082019050611a4060008301866117c9565b611a4d60208301856117c9565b611a5a6040830184611576565b949350505050565b60008115159050919050565b611a7781611a62565b8114611a8257600080fd5b50565b600081519050611a9481611a6e565b92915050565b600060208284031215611ab057611aaf6115aa565b5b6000611abe84828501611a85565b91505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000611b018261156c565b9150611b0c8361156c565b9250828202611b1a8161156c565b91508282048414831517611b3157611b30611ac7565b5b5092915050565b7f78202f207920213d206478202f20647900000000000000000000000000000000600082015250565b6000611b6e6010836117f3565b9150611b7982611b38565b602082019050919050565b60006020820190508181036000830152611b9d81611b61565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b6000611bde8261156c565b9150611be98361156c565b925082611bf957611bf8611ba4565b5b828204905092915050565b7f736861726573203d203000000000000000000000000000000000000000000000600082015250565b6000611c3a600a836117f3565b9150611c4582611c04565b602082019050919050565b60006020820190508181036000830152611c6981611c2d565b9050919050565b611c798161156c565b8114611c8457600080fd5b50565b600081519050611c9681611c70565b92915050565b600060208284031215611cb257611cb16115aa565b5b6000611cc084828501611c87565b91505092915050565b7f616d6f756e7430206f7220616d6f756e7431203d203000000000000000000000600082015250565b6000611cff6016836117f3565b9150611d0a82611cc9565b602082019050919050565b60006020820190508181036000830152611d2e81611cf2565b9050919050565b6000611d408261156c565b9150611d4b8361156c565b9250828203905081811115611d6357611d62611ac7565b5b92915050565b6000604082019050611d7e60008301856117c9565b611d8b6020830184611576565b9392505050565b7f696e76616c696420746f6b656e00000000000000000000000000000000000000600082015250565b6000611dc8600d836117f3565b9150611dd382611d92565b602082019050919050565b60006020820190508181036000830152611df781611dbb565b9050919050565b7f616d6f756e7420696e203d203000000000000000000000000000000000000000600082015250565b6000611e34600d836117f3565b9150611e3f82611dfe565b602082019050919050565b60006020820190508181036000830152611e6381611e27565b9050919050565b6000611e758261156c565b9150611e808361156c565b9250828201905080821115611e9857611e97611ac7565b5b92915050565b600060ff82169050919050565b611eb481611e9e565b82525050565b600081519050919050565b600082825260208201905092915050565b60005b83811015611ef4578082015181840152602081019050611ed9565b60008484015250505050565b6000611f0b82611eba565b611f158185611ec5565b9350611f25818560208601611ed6565b611f2e81611875565b840191505092915050565b6000604082019050611f4e6000830185611eab565b8181036020830152611f608184611f00565b90509392505050565b6000611f7c611f7784611910565b6118e6565b905082815260208101848484011115611f9857611f9761190b565b5b611fa3848285611ed6565b509392505050565b600082601f830112611fc057611fbf611906565b5b8151611fd0848260208601611f69565b91505092915050565b600060208284031215611fef57611fee6115aa565b5b600082015167ffffffffffffffff81111561200d5761200c6115af565b5b61201984828501611fab565b91505092915050565b6000604082019050818103600083015261203c8185611f00565b905061204b6020830184611eab565b939250505056fea2646970667358221220ef4216e02eebffd77dac78146a84a37ad7c74c8dc59d6583f5718556ec78ea5464736f6c63430008130033a26469706673582212200267f019a596fd8e1b6c889519a082ef2c14820a6957e454ea2c60ca3499462464736f6c63430008130033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061004c5760003560e01c80631e3dd18b14610051578063574f2ba314610081578063c9c653961461009f578063e6a43905146100cf575b600080fd5b61006b6004803603810190610066919061095a565b6100ff565b60405161007891906109c8565b60405180910390f35b61008961013e565b60405161009691906109f2565b60405180910390f35b6100b960048036038101906100b49190610a39565b61014b565b6040516100c691906109c8565b60405180910390f35b6100e960048036038101906100e49190610a39565b61074b565b6040516100f691906109c8565b60405180910390f35b6001818154811061010f57600080fd5b906000526020600020016000915054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6000600180549050905090565b600061018b6040518060400160405280600481526020017f646f6e650000000000000000000000000000000000000000000000000000000081525061078d565b8173ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff16036101f9576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016101f090610ad6565b60405180910390fd5b6000808373ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff1610610236578385610239565b84845b9150915061027c6040518060400160405280601681526020017f5468652061646472657373206f6620746f6b656e30200000000000000000000081525083610826565b600073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16036102eb576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016102e290610b42565b60405180910390fd5b600073ffffffffffffffffffffffffffffffffffffffff166000808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16146103f5576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016103ec90610bae565b60405180910390fd5b60006040518060200161040790610908565b6020820181038252601f19601f820116604052509050600083833360405160200161043493929190610c16565b6040516020818303038152906040528051906020012090508082516020840160fff59450600073ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff160361049157600080fd5b8473ffffffffffffffffffffffffffffffffffffffff1663485cc95585856040518363ffffffff1660e01b81526004016104cc929190610c53565b600060405180830381600087803b1580156104e657600080fd5b505af11580156104fa573d6000803e3d6000fd5b50505050846000808673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550846000808573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506001859080600181540180825580915050600190039060005260206000200160009091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff167f0d3648bd0f6ba80134a33ba9275ac585d9d315f0ad8355cddefde31afa28d0e987600180549050604051610739929190610c7c565b60405180910390a35050505092915050565b60006020528160005260406000206020528060005260406000206000915091509054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b610823816040516024016107a19190610d24565b6040516020818303038152906040527f41304fac000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff83818316178352505050506108c2565b50565b6108be828260405160240161083c929190610d46565b6040516020818303038152906040527f319af333000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff83818316178352505050506108c2565b5050565b6108d9816108d16108dc6108fd565b63ffffffff16565b50565b60006a636f6e736f6c652e6c6f679050600080835160208501845afa505050565b610915819050919050565b6120e980610da683390190565b61091d610d76565b565b600080fd5b6000819050919050565b61093781610924565b811461094257600080fd5b50565b6000813590506109548161092e565b92915050565b6000602082840312156109705761096f61091f565b5b600061097e84828501610945565b91505092915050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006109b282610987565b9050919050565b6109c2816109a7565b82525050565b60006020820190506109dd60008301846109b9565b92915050565b6109ec81610924565b82525050565b6000602082019050610a0760008301846109e3565b92915050565b610a16816109a7565b8114610a2157600080fd5b50565b600081359050610a3381610a0d565b92915050565b60008060408385031215610a5057610a4f61091f565b5b6000610a5e85828601610a24565b9250506020610a6f85828601610a24565b9150509250929050565b600082825260208201905092915050565b7f4944454e544943414c5f41444452455353455300000000000000000000000000600082015250565b6000610ac0601383610a79565b9150610acb82610a8a565b602082019050919050565b60006020820190508181036000830152610aef81610ab3565b9050919050565b7f5a45524f5f414444524553530000000000000000000000000000000000000000600082015250565b6000610b2c600c83610a79565b9150610b3782610af6565b602082019050919050565b60006020820190508181036000830152610b5b81610b1f565b9050919050565b7f504149525f455849535453000000000000000000000000000000000000000000600082015250565b6000610b98600b83610a79565b9150610ba382610b62565b602082019050919050565b60006020820190508181036000830152610bc781610b8b565b9050919050565b60008160601b9050919050565b6000610be682610bce565b9050919050565b6000610bf882610bdb565b9050919050565b610c10610c0b826109a7565b610bed565b82525050565b6000610c228286610bff565b601482019150610c328285610bff565b601482019150610c428284610bff565b601482019150819050949350505050565b6000604082019050610c6860008301856109b9565b610c7560208301846109b9565b9392505050565b6000604082019050610c9160008301856109b9565b610c9e60208301846109e3565b9392505050565b600081519050919050565b60005b83811015610cce578082015181840152602081019050610cb3565b60008484015250505050565b6000601f19601f8301169050919050565b6000610cf682610ca5565b610d008185610a79565b9350610d10818560208601610cb0565b610d1981610cda565b840191505092915050565b60006020820190508181036000830152610d3e8184610ceb565b905092915050565b60006040820190508181036000830152610d608185610ceb565b9050610d6f60208301846109b9565b9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052605160045260246000fdfe608060405234801561001057600080fd5b5033600260006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550612088806100616000396000f3fe608060405234801561001057600080fd5b50600436106100a95760003560e01c80635a76f25e116100715780635a76f25e146101545780635b18de5f1461017257806370a08231146101a357806374bfd999146101d3578063c45a015514610203578063d21220a714610221576100a9565b80630dfe1681146100ae57806318160ddd146100cc578063443cb4bc146100ea578063485cc9551461010857806352dc029114610124575b600080fd5b6100b661023f565b6040516100c39190611551565b60405180910390f35b6100d4610263565b6040516100e19190611585565b60405180910390f35b6100f2610269565b6040516100ff9190611585565b60405180910390f35b610122600480360381019061011d91906115f2565b61026f565b005b61013e60048036038101906101399190611656565b610384565b60405161014b9190611585565b60405180910390f35b61015c6107cb565b6040516101699190611585565b60405180910390f35b61018c600480360381019061018791906116ce565b6107d1565b60405161019a929190611717565b60405180910390f35b6101bd60048036038101906101b89190611740565b610b40565b6040516101ca9190611585565b60405180910390f35b6101ed60048036038101906101e8919061176d565b610b58565b6040516101fa9190611585565b60405180910390f35b61020b61103b565b60405161021891906117d8565b60405180910390f35b610229611061565b6040516102369190611551565b60405180910390f35b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b60055481565b60035481565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146102ff576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016102f690611850565b60405180910390fd5b816000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555080600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505050565b6000806103998461039490611a18565b611087565b905060006103af846103aa90611a18565b611087565b905060006103bc8361109d565b905060006103c98361109d565b905060008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166323b872dd33308663ffffffff166040518463ffffffff1660e01b815260040161043193929190611a2b565b6020604051808303816000875af1158015610450573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104749190611a9a565b90506000600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166323b872dd33308663ffffffff166040518463ffffffff1660e01b81526004016104dd93929190611a2b565b6020604051808303816000875af11580156104fc573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105209190611a9a565b905081801561052c5750805b61053557600080fd5b6000600354118061054857506000600454115b156105b6578363ffffffff166004546105619190611af6565b8363ffffffff166003546105759190611af6565b146105b5576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016105ac90611b84565b60405180910390fd5b5b6000600554036105e7576105e08363ffffffff168563ffffffff166105db9190611af6565b611160565b9650610634565b6106316003546005548663ffffffff166106019190611af6565b61060b9190611bd3565b6004546005548663ffffffff166106229190611af6565b61062c9190611bd3565b6111da565b96505b60008711610677576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161066e90611c50565b60405180910390fd5b61068133886111f4565b6107bf60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b81526004016106dd91906117d8565b602060405180830381865afa1580156106fa573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061071e9190611c9c565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b815260040161077991906117d8565b602060405180830381865afa158015610796573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107ba9190611c9c565b611267565b50505050505092915050565b60045481565b60008060006107e8846107e390611a18565b611087565b905060006107f58261109d565b905060008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b815260040161085391906117d8565b602060405180830381865afa158015610870573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108949190611c9c565b90506000600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b81526004016108f391906117d8565b602060405180830381865afa158015610910573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109349190611c9c565b9050600554828463ffffffff1661094b9190611af6565b6109559190611bd3565b9550600554818463ffffffff1661096c9190611af6565b6109769190611bd3565b94506000861180156109885750600085115b6109c7576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016109be90611d15565b60405180910390fd5b6109d7338463ffffffff16611279565b6109f786836109e69190611d35565b86836109f29190611d35565b611267565b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a9059cbb33886040518363ffffffff1660e01b8152600401610a52929190611d69565b6020604051808303816000875af1158015610a71573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a959190611a9a565b50600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a9059cbb33876040518363ffffffff1660e01b8152600401610af3929190611d69565b6020604051808303816000875af1158015610b12573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b369190611a9a565b5050505050915091565b60066020528060005260406000206000915090505481565b600080610b6d83610b6890611a18565b611087565b90506000610b7a8261109d565b63ffffffff16905060008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff161480610c295750600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff16145b610c68576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610c5f90611dde565b60405180910390fd5b60008111610cab576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610ca290611e4a565b60405180910390fd5b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168673ffffffffffffffffffffffffffffffffffffffff1614905060008060008084610d5957600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1660008054906101000a900473ffffffffffffffffffffffffffffffffffffffff16600454600354610da4565b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff16600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff166003546004545b93509350935093508373ffffffffffffffffffffffffffffffffffffffff166323b872dd3330896040518463ffffffff1660e01b8152600401610de993929190611a2b565b6020604051808303816000875af1158015610e08573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e2c9190611a9a565b5060006103e86103e588610e409190611af6565b610e4a9190611bd3565b90508083610e589190611e6a565b8183610e649190611af6565b610e6e9190611bd3565b98508373ffffffffffffffffffffffffffffffffffffffff1663a9059cbb338b6040518363ffffffff1660e01b8152600401610eab929190611d69565b6020604051808303816000875af1158015610eca573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610eee9190611a9a565b5061102d60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b8152600401610f4b91906117d8565b602060405180830381865afa158015610f68573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f8c9190611c9c565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b8152600401610fe791906117d8565b602060405180830381865afa158015611004573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110289190611c9c565b611267565b505050505050505092915050565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b600061109682600001516112ec565b9050919050565b60006110a882611300565b6110b9576110b6600061130d565b91505b600082905060006110c982611321565b90506000608073ffffffffffffffffffffffffffffffffffffffff166373cc01546002846040518363ffffffff1660e01b815260040161110a929190611f39565b602060405180830381865afa158015611127573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061114b9190611c9c565b90506111568161137e565b9350505050919050565b600060038211156111c7578190506000600160028461117f9190611bd3565b6111899190611e6a565b90505b818110156111c15780915060028182856111a69190611bd3565b6111b09190611e6a565b6111ba9190611bd3565b905061118c565b506111d5565b600082146111d457600190505b5b919050565b6000818311156111ea57816111ec565b825b905092915050565b80600660008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546112439190611e6a565b92505081905550806005600082825461125c9190611e6a565b925050819055505050565b81600381905550806004819055505050565b80600660008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546112c89190611d35565b9250508190555080600560008282546112e19190611d35565b925050819055505050565b60006112f9826002611388565b9050919050565b6000808214159050919050565b600061131a826002611422565b9050919050565b6060602067ffffffffffffffff81111561133e5761133d611886565b5b6040519080825280601f01601f1916602001820160405280156113705781602001600182028036833780820191505090505b509050816020820152919050565b6000819050919050565b60006060608073ffffffffffffffffffffffffffffffffffffffff16635fa55ca784866040518363ffffffff1660e01b81526004016113c8929190611f39565b600060405180830381865afa1580156113e5573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f8201168201806040525081019061140e9190611fd9565b9050611419816114c4565b91505092915050565b60006060608073ffffffffffffffffffffffffffffffffffffffff166319e1c5c461144c86611321565b856040518363ffffffff1660e01b815260040161146a929190612022565b600060405180830381865afa158015611487573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f820116820180604052508101906114b09190611fd9565b90506114bb816114c4565b91505092915050565b600060208201519050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000819050919050565b600061151761151261150d846114d2565b6114f2565b6114d2565b9050919050565b6000611529826114fc565b9050919050565b600061153b8261151e565b9050919050565b61154b81611530565b82525050565b60006020820190506115666000830184611542565b92915050565b6000819050919050565b61157f8161156c565b82525050565b600060208201905061159a6000830184611576565b92915050565b6000604051905090565b600080fd5b600080fd5b60006115bf826114d2565b9050919050565b6115cf816115b4565b81146115da57600080fd5b50565b6000813590506115ec816115c6565b92915050565b60008060408385031215611609576116086115aa565b5b6000611617858286016115dd565b9250506020611628858286016115dd565b9150509250929050565b600080fd5b60006020828403121561164d5761164c611632565b5b81905092915050565b6000806040838503121561166d5761166c6115aa565b5b600083013567ffffffffffffffff81111561168b5761168a6115af565b5b61169785828601611637565b925050602083013567ffffffffffffffff8111156116b8576116b76115af565b5b6116c485828601611637565b9150509250929050565b6000602082840312156116e4576116e36115aa565b5b600082013567ffffffffffffffff811115611702576117016115af565b5b61170e84828501611637565b91505092915050565b600060408201905061172c6000830185611576565b6117396020830184611576565b9392505050565b600060208284031215611756576117556115aa565b5b6000611764848285016115dd565b91505092915050565b60008060408385031215611784576117836115aa565b5b6000611792858286016115dd565b925050602083013567ffffffffffffffff8111156117b3576117b26115af565b5b6117bf85828601611637565b9150509250929050565b6117d2816115b4565b82525050565b60006020820190506117ed60008301846117c9565b92915050565b600082825260208201905092915050565b7f4f6e6c7920466163746f72792063616e2063616c6c2074686973000000000000600082015250565b600061183a601a836117f3565b915061184582611804565b602082019050919050565b600060208201905081810360008301526118698161182d565b9050919050565b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6118be82611875565b810181811067ffffffffffffffff821117156118dd576118dc611886565b5b80604052505050565b60006118f06115a0565b90506118fc82826118b5565b919050565b600080fd5b600080fd5b600080fd5b600067ffffffffffffffff82111561192b5761192a611886565b5b61193482611875565b9050602081019050919050565b82818337600083830152505050565b600061196361195e84611910565b6118e6565b90508281526020810184848401111561197f5761197e61190b565b5b61198a848285611941565b509392505050565b600082601f8301126119a7576119a6611906565b5b81356119b7848260208601611950565b91505092915050565b6000602082840312156119d6576119d5611870565b5b6119e060206118e6565b9050600082013567ffffffffffffffff811115611a00576119ff611901565b5b611a0c84828501611992565b60008301525092915050565b6000611a2436836119c0565b9050919050565b6000606082019050611a4060008301866117c9565b611a4d60208301856117c9565b611a5a6040830184611576565b949350505050565b60008115159050919050565b611a7781611a62565b8114611a8257600080fd5b50565b600081519050611a9481611a6e565b92915050565b600060208284031215611ab057611aaf6115aa565b5b6000611abe84828501611a85565b91505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000611b018261156c565b9150611b0c8361156c565b9250828202611b1a8161156c565b91508282048414831517611b3157611b30611ac7565b5b5092915050565b7f78202f207920213d206478202f20647900000000000000000000000000000000600082015250565b6000611b6e6010836117f3565b9150611b7982611b38565b602082019050919050565b60006020820190508181036000830152611b9d81611b61565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b6000611bde8261156c565b9150611be98361156c565b925082611bf957611bf8611ba4565b5b828204905092915050565b7f736861726573203d203000000000000000000000000000000000000000000000600082015250565b6000611c3a600a836117f3565b9150611c4582611c04565b602082019050919050565b60006020820190508181036000830152611c6981611c2d565b9050919050565b611c798161156c565b8114611c8457600080fd5b50565b600081519050611c9681611c70565b92915050565b600060208284031215611cb257611cb16115aa565b5b6000611cc084828501611c87565b91505092915050565b7f616d6f756e7430206f7220616d6f756e7431203d203000000000000000000000600082015250565b6000611cff6016836117f3565b9150611d0a82611cc9565b602082019050919050565b60006020820190508181036000830152611d2e81611cf2565b9050919050565b6000611d408261156c565b9150611d4b8361156c565b9250828203905081811115611d6357611d62611ac7565b5b92915050565b6000604082019050611d7e60008301856117c9565b611d8b6020830184611576565b9392505050565b7f696e76616c696420746f6b656e00000000000000000000000000000000000000600082015250565b6000611dc8600d836117f3565b9150611dd382611d92565b602082019050919050565b60006020820190508181036000830152611df781611dbb565b9050919050565b7f616d6f756e7420696e203d203000000000000000000000000000000000000000600082015250565b6000611e34600d836117f3565b9150611e3f82611dfe565b602082019050919050565b60006020820190508181036000830152611e6381611e27565b9050919050565b6000611e758261156c565b9150611e808361156c565b9250828201905080821115611e9857611e97611ac7565b5b92915050565b600060ff82169050919050565b611eb481611e9e565b82525050565b600081519050919050565b600082825260208201905092915050565b60005b83811015611ef4578082015181840152602081019050611ed9565b60008484015250505050565b6000611f0b82611eba565b611f158185611ec5565b9350611f25818560208601611ed6565b611f2e81611875565b840191505092915050565b6000604082019050611f4e6000830185611eab565b8181036020830152611f608184611f00565b90509392505050565b6000611f7c611f7784611910565b6118e6565b905082815260208101848484011115611f9857611f9761190b565b5b611fa3848285611ed6565b509392505050565b600082601f830112611fc057611fbf611906565b5b8151611fd0848260208601611f69565b91505092915050565b600060208284031215611fef57611fee6115aa565b5b600082015167ffffffffffffffff81111561200d5761200c6115af565b5b61201984828501611fab565b91505092915050565b6000604082019050818103600083015261203c8185611f00565b905061204b6020830184611eab565b939250505056fea2646970667358221220ef4216e02eebffd77dac78146a84a37ad7c74c8dc59d6583f5718556ec78ea5464736f6c63430008130033a26469706673582212200267f019a596fd8e1b6c889519a082ef2c14820a6957e454ea2c60ca3499462464736f6c63430008130033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 9332,
        "contract": "contracts/Factory.sol:FactoryFHE",
        "label": "getPair",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_address,t_mapping(t_address,t_address))"
      },
      {
        "astId": 9335,
        "contract": "contracts/Factory.sol:FactoryFHE",
        "label": "allPairs",
        "offset": 0,
        "slot": "1",
        "type": "t_array(t_address)dyn_storage"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_address)dyn_storage": {
        "base": "t_address",
        "encoding": "dynamic_array",
        "label": "address[]",
        "numberOfBytes": "32"
      },
      "t_mapping(t_address,t_address)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      },
      "t_mapping(t_address,t_mapping(t_address,t_address))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(address => address))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_address)"
      }
    }
  }
}