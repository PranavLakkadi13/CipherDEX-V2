{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/interfaces/IERC5267.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC5267.sol)\n\npragma solidity ^0.8.0;\n\ninterface IERC5267 {\n    /**\n     * @dev MAY be emitted to signal that the domain could have changed.\n     */\n    event EIP712DomainChanged();\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     */\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, \"\\x19\\x01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\n     * `validator` and `data` according to the version 0 of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x00\", validator, data));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.8;\n\nimport \"./ECDSA.sol\";\nimport \"../ShortStrings.sol\";\nimport \"../../interfaces/IERC5267.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\n * separator of the implementation contract. This will cause the `_domainSeparatorV4` function to always rebuild the\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\n *\n * _Available since v3.4._\n *\n * @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n */\nabstract contract EIP712 is IERC5267 {\n    using ShortStrings for *;\n\n    bytes32 private constant _TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _cachedDomainSeparator;\n    uint256 private immutable _cachedChainId;\n    address private immutable _cachedThis;\n\n    bytes32 private immutable _hashedName;\n    bytes32 private immutable _hashedVersion;\n\n    ShortString private immutable _name;\n    ShortString private immutable _version;\n    string private _nameFallback;\n    string private _versionFallback;\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        _name = name.toShortStringWithFallback(_nameFallback);\n        _version = version.toShortStringWithFallback(_versionFallback);\n        _hashedName = keccak256(bytes(name));\n        _hashedVersion = keccak256(bytes(version));\n\n        _cachedChainId = block.chainid;\n        _cachedDomainSeparator = _buildDomainSeparator();\n        _cachedThis = address(this);\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {\n            return _cachedDomainSeparator;\n        } else {\n            return _buildDomainSeparator();\n        }\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(_TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev See {EIP-5267}.\n     *\n     * _Available since v4.9._\n     */\n    function eip712Domain()\n        public\n        view\n        virtual\n        override\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        return (\n            hex\"0f\", // 01111\n            _name.toStringWithFallback(_nameFallback),\n            _version.toStringWithFallback(_versionFallback),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ShortStrings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/ShortStrings.sol)\n\npragma solidity ^0.8.8;\n\nimport \"./StorageSlot.sol\";\n\n// | string  | 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA   |\n// | length  | 0x                                                              BB |\ntype ShortString is bytes32;\n\n/**\n * @dev This library provides functions to convert short memory strings\n * into a `ShortString` type that can be used as an immutable variable.\n *\n * Strings of arbitrary length can be optimized using this library if\n * they are short enough (up to 31 bytes) by packing them with their\n * length (1 byte) in a single EVM word (32 bytes). Additionally, a\n * fallback mechanism can be used for every other case.\n *\n * Usage example:\n *\n * ```solidity\n * contract Named {\n *     using ShortStrings for *;\n *\n *     ShortString private immutable _name;\n *     string private _nameFallback;\n *\n *     constructor(string memory contractName) {\n *         _name = contractName.toShortStringWithFallback(_nameFallback);\n *     }\n *\n *     function name() external view returns (string memory) {\n *         return _name.toStringWithFallback(_nameFallback);\n *     }\n * }\n * ```\n */\nlibrary ShortStrings {\n    // Used as an identifier for strings longer than 31 bytes.\n    bytes32 private constant _FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;\n\n    error StringTooLong(string str);\n    error InvalidShortString();\n\n    /**\n     * @dev Encode a string of at most 31 chars into a `ShortString`.\n     *\n     * This will trigger a `StringTooLong` error is the input string is too long.\n     */\n    function toShortString(string memory str) internal pure returns (ShortString) {\n        bytes memory bstr = bytes(str);\n        if (bstr.length > 31) {\n            revert StringTooLong(str);\n        }\n        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\n    }\n\n    /**\n     * @dev Decode a `ShortString` back to a \"normal\" string.\n     */\n    function toString(ShortString sstr) internal pure returns (string memory) {\n        uint256 len = byteLength(sstr);\n        // using `new string(len)` would work locally but is not memory safe.\n        string memory str = new string(32);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(str, len)\n            mstore(add(str, 0x20), sstr)\n        }\n        return str;\n    }\n\n    /**\n     * @dev Return the length of a `ShortString`.\n     */\n    function byteLength(ShortString sstr) internal pure returns (uint256) {\n        uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\n        if (result > 31) {\n            revert InvalidShortString();\n        }\n        return result;\n    }\n\n    /**\n     * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.\n     */\n    function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {\n        if (bytes(value).length < 32) {\n            return toShortString(value);\n        } else {\n            StorageSlot.getStringSlot(store).value = value;\n            return ShortString.wrap(_FALLBACK_SENTINEL);\n        }\n    }\n\n    /**\n     * @dev Decode a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\n     */\n    function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {\n        if (ShortString.unwrap(value) != _FALLBACK_SENTINEL) {\n            return toString(value);\n        } else {\n            return store;\n        }\n    }\n\n    /**\n     * @dev Return the length of a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\n     *\n     * WARNING: This will return the \"byte length\" of the string. This may not reflect the actual length in terms of\n     * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.\n     */\n    function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {\n        if (ShortString.unwrap(value) != _FALLBACK_SENTINEL) {\n            return byteLength(value);\n        } else {\n            return bytes(store).length;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\n * _Available since v4.9 for `string`, `bytes`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "contracts/EncryptedPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport \"fhevm/abstracts/EIP712WithModifier.sol\";\nimport \"fhevm/lib/TFHE.sol\";\nimport \"./interfaces/IERC20.sol\";\n\ncontract Pair is EIP712WithModifier {\n    IERC20 public token0;\n    IERC20 public token1;\n    address public immutable factory;\n\n    uint public reserve0;\n    uint public reserve1;\n\n    uint public totalSupply;\n    mapping(address => uint) public balanceOf;\n\n    constructor() EIP712WithModifier(\"Auth_ERC20\", \"1\"){\n        factory = msg.sender;\n    }\n\n    // function BalanceOf(bytes32 publicKey,bytes calldata signature) public view \n    // onlySignedPublicKey(publicKey,signature)\n    // returns(bytes memory reencrypted) {\n    //     // return TFHE.reencrypt(balanceOf[msg.sender], publicKey, 0);\n    //     reencrypted = TFHE.reencrypt(balanceOf[msg.sender],publicKey,0);\n    // }\n\n    function initialize(address _token0, address _token1) external {\n        require(msg.sender == factory, 'FORBIDDEN'); // sufficient check\n        token0 = IERC20(_token0);\n        token1 = IERC20(_token1);\n    }\n\n    function _mint(address _to, uint _amount) private {\n        balanceOf[_to] += _amount;\n        totalSupply += _amount;\n    }\n\n    function _burn(address _from, uint _amount) private {\n        balanceOf[_from] -= _amount;\n        totalSupply -= _amount;\n    }\n\n    function _update(uint _reserve0, uint _reserve1) private {\n        reserve0 = _reserve0;\n        reserve1 = _reserve1;\n    }\n\n    function swap(address _tokenIn, bytes memory _amountIn) external returns (uint amountOut) {\n        uint32 amountIn = TFHE.decrypt(TFHE.asEuint32(_amountIn));\n        require(\n            _tokenIn == address(token0) || _tokenIn == address(token1),\n            \"invalid token\"\n        );\n        require(uint256(amountIn) > 0, \"amount in = 0\");\n\n        bool isToken0 = _tokenIn == address(token0);\n        (IERC20 tokenIn, IERC20 tokenOut, uint reserveIn, uint reserveOut) = isToken0\n            ? (token0, token1, reserve0, reserve1)\n            : (token1, token0, reserve1, reserve0);\n\n        tokenIn.transferFrom(msg.sender, address(this), uint256(amountIn));\n\n        uint amountInWithFee = (uint256(amountIn) * 997) / 1000;\n        amountOut = (reserveOut * amountInWithFee) / (reserveIn + amountInWithFee);\n\n        tokenOut.transfer(msg.sender, uint256(amountOut));\n\n        _update(token0.balanceOf(address(this)), token1.balanceOf(address(this)));\n    }\n\n    function addLiquidity(bytes memory _amount0, bytes memory _amount1) external returns (uint shares) {\n        uint32 amount0 = TFHE.decrypt(TFHE.asEuint32(_amount0));\n        uint32 amount1 = TFHE.decrypt(TFHE.asEuint32(_amount1));\n        \n        token0.transferFrom(msg.sender, address(this), uint256(amount0));\n        token1.transferFrom(msg.sender, address(this), uint256(amount1));\n\n        if (reserve0 > 0 || reserve1 > 0) {\n            require(reserve0 * uint(amount1) == reserve1 * uint(amount0), \"x / y != dx / dy\");\n        }\n\n        if (totalSupply == 0) {\n            shares = _sqrt(uint256(amount0) * uint256(amount1));\n        } else {\n            shares = _min(\n                (uint256(amount0) * totalSupply) / reserve0,\n                (uint256(amount1) * totalSupply) / reserve1\n            );\n        }\n        require(shares > 0, \"shares = 0\");\n        _mint(msg.sender, shares);\n\n        _update(token0.balanceOf(address(this)), token1.balanceOf(address(this)));\n    }\n\n    function removeLiquidity(\n        bytes memory _shares\n    ) external returns (uint amount0, uint amount1) {\n    \n        uint32 shares = TFHE.decrypt(TFHE.asEuint32(_shares));\n        uint bal0 = token0.balanceOf(address(this));\n        uint bal1 = token1.balanceOf(address(this));\n\n        amount0 = (uint256(shares) * bal0) / totalSupply;\n        amount1 = (uint256(shares) * bal1) / totalSupply;\n        require(amount0 > 0 && amount1 > 0, \"amount0 or amount1 = 0\");\n\n        _burn(msg.sender, shares);\n        _update(bal0 - amount0, bal1 - amount1);\n\n        token0.transfer(msg.sender, uint256(amount0));\n        token1.transfer(msg.sender, uint256(amount1));\n    }\n\n    function _sqrt(uint y) private pure returns (uint z) {\n        if (y > 3) {\n            z = y;\n            uint x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    function _min(uint x, uint y) private pure returns (uint) {\n        return x <= y ? x : y;\n    }\n}"
    },
    "contracts/Factory.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.19;\n\nimport {Pair} from \"./EncryptedPair.sol\";\n\ncontract FactoryFHE {\n\n    mapping(address => mapping(address => address)) public getPair;\n\n    address[] public allPairs;\n\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function allPairsLength() external view returns (uint) {\n        return allPairs.length;\n    }\n\n    function createPair(address tokenA, address tokenB) external returns (address pair) {\n        require(tokenA != tokenB, 'IDENTICAL_ADDRESSES');\n        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), 'ZERO_ADDRESS');\n        require(getPair[token0][token1] == address(0), 'UniswapV2: PAIR_EXISTS'); // single check is sufficient\n        bytes memory bytecode = type(Pair).creationCode;\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1));\n        assembly {\n            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)\n        }\n        Pair(pair).initialize(token0, token1);\n        getPair[token0][token1] = pair;\n        getPair[token1][token0] = pair; // populate mapping in the reverse direction\n        allPairs.push(pair);\n        emit PairCreated(token0, token1, pair, allPairs.length);\n    }\n}\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT \npragma solidity 0.8.19;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint);\n\n    function balanceOf(address account) external view returns (uint);\n\n    function transfer(address recipient, uint amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint amount\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint amount);\n    event Approval(address indexed owner, address indexed spender, uint amount);\n}"
    },
    "fhevm/abstracts/EIP712WithModifier.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\n\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/EIP712.sol\";\n\nabstract contract EIP712WithModifier is EIP712 {\n    constructor(string memory name, string memory version) EIP712(name, version) {}\n\n    modifier onlySignedPublicKey(bytes32 publicKey, bytes memory signature) {\n        bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(keccak256(\"Reencrypt(bytes32 publicKey)\"), publicKey)));\n        address signer = ECDSA.recover(digest, signature);\n        require(signer == msg.sender, \"EIP712 signer and transaction signer do not match\");\n        _;\n    }\n}\n"
    },
    "fhevm/lib/Impl.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\n\npragma solidity 0.8.19;\n\ninterface FhevmLib {\n    function fheAdd(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\n\n    function fheSub(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\n\n    function fheMul(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\n\n    function fheDiv(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\n\n    function fheBitAnd(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\n\n    function fheBitOr(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\n\n    function fheBitXor(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\n\n    function fheShl(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\n\n    function fheShr(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\n\n    function fheEq(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\n\n    function fheNe(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\n\n    function fheGe(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\n\n    function fheGt(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\n\n    function fheLe(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\n\n    function fheLt(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\n\n    function fheMin(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\n\n    function fheMax(uint256 lhs, uint256 rhs, bytes1 scalarByte) external pure returns (uint256 result);\n\n    function fheNeg(uint256 ct) external pure returns (uint256 result);\n\n    function fheNot(uint256 ct) external pure returns (uint256 result);\n\n    function optimisticRequire(uint256 ct) external view;\n\n    function reencrypt(uint256 ct, uint256 publicKey) external view returns (bytes memory);\n\n    function fhePubKey(bytes1 fromLib) external view returns (bytes memory result);\n\n    function verifyCiphertext(bytes memory input) external pure returns (uint256 result);\n\n    function cast(uint256 ct, bytes1 toType) external pure returns (uint256 result);\n\n    function trivialEncrypt(uint256 ct, bytes1 toType) external pure returns (uint256 result);\n\n    function decrypt(uint256 ct) external view returns (uint256 result);\n\n    function fheRand(bytes1 inp) external view returns (uint256 result);\n}\n\naddress constant EXT_TFHE_LIBRARY = address(93);\n\nlibrary Impl {\n    // 32 bytes for the 'byte' type header + 48 bytes for the NaCl anonymous\n    // box overhead + 4 bytes for the plaintext value.\n    uint256 constant reencryptedSize = 32 + 48 + 4;\n\n    // 32 bytes for the 'byte' header + 16553 bytes of key data.\n    uint256 constant fhePubKeySize = 32 + 16553;\n\n    function add(uint256 lhs, uint256 rhs, bool scalar) internal pure returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheAdd(lhs, rhs, scalarByte);\n    }\n\n    function sub(uint256 lhs, uint256 rhs, bool scalar) internal pure returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheSub(lhs, rhs, scalarByte);\n    }\n\n    function mul(uint256 lhs, uint256 rhs, bool scalar) internal pure returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheMul(lhs, rhs, scalarByte);\n    }\n\n    function div(uint256 lhs, uint256 rhs) internal pure returns (uint256 result) {\n        bytes1 scalarByte = 0x01;\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheDiv(lhs, rhs, scalarByte);\n    }\n\n    function and(uint256 lhs, uint256 rhs) internal pure returns (uint256 result) {\n        bytes1 scalarByte = 0x00;\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheBitAnd(lhs, rhs, scalarByte);\n    }\n\n    function or(uint256 lhs, uint256 rhs) internal pure returns (uint256 result) {\n        bytes1 scalarByte = 0x00;\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheBitOr(lhs, rhs, scalarByte);\n    }\n\n    function xor(uint256 lhs, uint256 rhs) internal pure returns (uint256 result) {\n        bytes1 scalarByte = 0x00;\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheBitXor(lhs, rhs, scalarByte);\n    }\n\n    function shl(uint256 lhs, uint256 rhs, bool scalar) internal pure returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheShl(lhs, rhs, scalarByte);\n    }\n\n    function shr(uint256 lhs, uint256 rhs, bool scalar) internal pure returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheShr(lhs, rhs, scalarByte);\n    }\n\n    function eq(uint256 lhs, uint256 rhs, bool scalar) internal pure returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheEq(lhs, rhs, scalarByte);\n    }\n\n    function ne(uint256 lhs, uint256 rhs, bool scalar) internal pure returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheNe(lhs, rhs, scalarByte);\n    }\n\n    function ge(uint256 lhs, uint256 rhs, bool scalar) internal pure returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheGe(lhs, rhs, scalarByte);\n    }\n\n    function gt(uint256 lhs, uint256 rhs, bool scalar) internal pure returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheGt(lhs, rhs, scalarByte);\n    }\n\n    function le(uint256 lhs, uint256 rhs, bool scalar) internal pure returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheLe(lhs, rhs, scalarByte);\n    }\n\n    function lt(uint256 lhs, uint256 rhs, bool scalar) internal pure returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheLt(lhs, rhs, scalarByte);\n    }\n\n    function min(uint256 lhs, uint256 rhs, bool scalar) internal pure returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheMin(lhs, rhs, scalarByte);\n    }\n\n    function max(uint256 lhs, uint256 rhs, bool scalar) internal pure returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheMax(lhs, rhs, scalarByte);\n    }\n\n    function neg(uint256 ct) internal pure returns (uint256 result) {\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheNeg(ct);\n    }\n\n    function not(uint256 ct) internal pure returns (uint256 result) {\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheNot(ct);\n    }\n\n    // If 'control's value is 'true', the result has the same value as 'ifTrue'.\n    // If 'control's value is 'false', the result has the same value as 'ifFalse'.\n    function cmux(uint256 control, uint256 ifTrue, uint256 ifFalse) internal pure returns (uint256 result) {\n        // result = (ifTrue - ifFalse) * control + ifFalse\n        uint256 subOutput = FhevmLib(address(EXT_TFHE_LIBRARY)).fheSub(ifTrue, ifFalse, bytes1(0x00));\n        uint256 mulOutput = FhevmLib(address(EXT_TFHE_LIBRARY)).fheMul(control, subOutput, bytes1(0x00));\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheAdd(mulOutput, ifFalse, bytes1(0x00));\n    }\n\n    function optReq(uint256 ciphertext) internal view {\n        FhevmLib(address(EXT_TFHE_LIBRARY)).optimisticRequire(ciphertext);\n    }\n\n    function reencrypt(uint256 ciphertext, bytes32 publicKey) internal view returns (bytes memory reencrypted) {\n        return FhevmLib(address(EXT_TFHE_LIBRARY)).reencrypt(ciphertext, uint256(publicKey));\n    }\n\n    function fhePubKey() internal view returns (bytes memory key) {\n        // Set a byte value of 1 to signal the call comes from the library.\n        key = FhevmLib(address(EXT_TFHE_LIBRARY)).fhePubKey(bytes1(0x01));\n    }\n\n    function verify(bytes memory _ciphertextBytes, uint8 _toType) internal pure returns (uint256 result) {\n        bytes memory input = bytes.concat(_ciphertextBytes, bytes1(_toType));\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).verifyCiphertext(input);\n    }\n\n    function cast(uint256 ciphertext, uint8 toType) internal pure returns (uint256 result) {\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).cast(ciphertext, bytes1(toType));\n    }\n\n    function trivialEncrypt(uint256 value, uint8 toType) internal pure returns (uint256 result) {\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).trivialEncrypt(value, bytes1(toType));\n    }\n\n    function decrypt(uint256 ciphertext) internal view returns (uint256 result) {\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).decrypt(ciphertext);\n    }\n\n    function rand(uint8 randType) internal view returns (uint256 result) {\n        result = FhevmLib(address(EXT_TFHE_LIBRARY)).fheRand(bytes1(randType));\n    }\n}\n"
    },
    "fhevm/lib/TFHE.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\n\npragma solidity 0.8.19;\n\ntype ebool is uint256;\ntype euint8 is uint256;\ntype euint16 is uint256;\ntype euint32 is uint256;\n\nlibrary Common {\n    // Values used to communicate types to the runtime.\n    uint8 internal constant ebool_t = 0;\n    uint8 internal constant euint8_t = 0;\n    uint8 internal constant euint16_t = 1;\n    uint8 internal constant euint32_t = 2;\n}\n\nimport \"./Impl.sol\";\n\nlibrary TFHE {\n    euint8 constant NIL8 = euint8.wrap(0);\n    euint16 constant NIL16 = euint16.wrap(0);\n    euint32 constant NIL32 = euint32.wrap(0);\n\n    // Return true if the enrypted integer is initialized and false otherwise.\n    function isInitialized(euint8 v) internal pure returns (bool) {\n        return euint8.unwrap(v) != 0;\n    }\n\n    // Return true if the enrypted integer is initialized and false otherwise.\n    function isInitialized(euint16 v) internal pure returns (bool) {\n        return euint16.unwrap(v) != 0;\n    }\n\n    // Return true if the enrypted integer is initialized and false otherwise.\n    function isInitialized(euint32 v) internal pure returns (bool) {\n        return euint32.unwrap(v) != 0;\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint8 a, euint8 b) internal pure returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.add(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint8 a, euint8 b) internal pure returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.sub(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint8 a, euint8 b) internal pure returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.mul(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint8 a, euint8 b) internal pure returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.and(euint8.unwrap(a), euint8.unwrap(b)));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint8 a, euint8 b) internal pure returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.or(euint8.unwrap(a), euint8.unwrap(b)));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint8 a, euint8 b) internal pure returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.xor(euint8.unwrap(a), euint8.unwrap(b)));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint8 a, euint8 b) internal pure returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.shl(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint8 a, euint8 b) internal pure returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.shr(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint8 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.eq(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint8 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ne(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint8 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ge(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint8 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.gt(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint8 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.le(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint8 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.lt(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint8 a, euint8 b) internal pure returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.min(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint8 a, euint8 b) internal pure returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.max(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint8 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.add(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint8 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.sub(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint8 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.mul(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint8 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.and(euint16.unwrap(asEuint16(a)), euint16.unwrap(b)));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint8 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.or(euint16.unwrap(asEuint16(a)), euint16.unwrap(b)));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint8 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.xor(euint16.unwrap(asEuint16(a)), euint16.unwrap(b)));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint8 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.shl(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint8 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.shr(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint8 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.eq(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint8 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ne(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint8 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ge(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint8 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.gt(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint8 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.le(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint8 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.lt(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint8 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.min(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint8 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.max(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint8 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint8 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint8 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint8 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.and(euint32.unwrap(asEuint32(a)), euint32.unwrap(b)));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint8 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.or(euint32.unwrap(asEuint32(a)), euint32.unwrap(b)));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint8 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.xor(euint32.unwrap(asEuint32(a)), euint32.unwrap(b)));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint8 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.shl(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint8 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.shr(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint8 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.eq(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint8 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ne(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint8 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ge(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint8 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.gt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint8 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.le(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint8 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.lt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint8 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint8 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint8 a, uint8 b) internal pure returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.add(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(uint8 a, euint8 b) internal pure returns (euint8) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.add(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint8 a, uint8 b) internal pure returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.sub(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(uint8 a, euint8 b) internal pure returns (euint8) {\n        euint8 aEnc = asEuint8(a);\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.sub(euint8.unwrap(aEnc), euint8.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint8 a, uint8 b) internal pure returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.mul(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(uint8 a, euint8 b) internal pure returns (euint8) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.mul(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate div(a, b) and return the result.\n    function div(euint8 a, uint8 b) internal pure returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.div(euint8.unwrap(a), uint256(b)));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint8 a, uint8 b) internal pure returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.shl(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(uint8 a, euint8 b) internal pure returns (euint8) {\n        euint8 aEnc = asEuint8(a);\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.shl(euint8.unwrap(aEnc), euint8.unwrap(b), false));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint8 a, uint8 b) internal pure returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.shr(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(uint8 a, euint8 b) internal pure returns (euint8) {\n        euint8 aEnc = asEuint8(a);\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.shr(euint8.unwrap(aEnc), euint8.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint8 a, uint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return ebool.wrap(Impl.eq(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(uint8 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.eq(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint8 a, uint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ne(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(uint8 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ne(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint8 a, uint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ge(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(uint8 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.le(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint8 a, uint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return ebool.wrap(Impl.gt(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(uint8 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.lt(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint8 a, uint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return ebool.wrap(Impl.le(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(uint8 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ge(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint8 a, uint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return ebool.wrap(Impl.lt(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(uint8 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.gt(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint8 a, uint8 b) internal pure returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.min(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(uint8 a, euint8 b) internal pure returns (euint8) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.min(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint8 a, uint8 b) internal pure returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.max(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(uint8 a, euint8 b) internal pure returns (euint8) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.max(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint16 a, euint8 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.add(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint16 a, euint8 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint16 a, euint8 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint16 a, euint8 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.and(euint16.unwrap(a), euint16.unwrap(asEuint16(b))));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint16 a, euint8 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.or(euint16.unwrap(a), euint16.unwrap(asEuint16(b))));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint16 a, euint8 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), euint16.unwrap(asEuint16(b))));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint16 a, euint8 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.shl(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint16 a, euint8 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.shr(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint16 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.eq(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false), Common.ebool_t));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint16 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ne(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false), Common.ebool_t));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint16 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ge(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false), Common.ebool_t));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint16 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.gt(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false), Common.ebool_t));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint16 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.le(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false), Common.ebool_t));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint16 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.lt(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false), Common.ebool_t));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint16 a, euint8 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.min(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint16 a, euint8 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.max(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint16 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.add(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint16 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint16 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint16 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.and(euint16.unwrap(a), euint16.unwrap(b)));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint16 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.or(euint16.unwrap(a), euint16.unwrap(b)));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint16 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), euint16.unwrap(b)));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint16 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.shl(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint16 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.shr(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint16 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.eq(euint16.unwrap(a), euint16.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint16 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ne(euint16.unwrap(a), euint16.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint16 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ge(euint16.unwrap(a), euint16.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint16 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.gt(euint16.unwrap(a), euint16.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint16 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.le(euint16.unwrap(a), euint16.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint16 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.lt(euint16.unwrap(a), euint16.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint16 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.min(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint16 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.max(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint16 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint16 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint16 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint16 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.and(euint32.unwrap(asEuint32(a)), euint32.unwrap(b)));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint16 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.or(euint32.unwrap(asEuint32(a)), euint32.unwrap(b)));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint16 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.xor(euint32.unwrap(asEuint32(a)), euint32.unwrap(b)));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint16 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.shl(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint16 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.shr(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint16 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.eq(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint16 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ne(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint16 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ge(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint16 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.gt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint16 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.le(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint16 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.lt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint16 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint16 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint16 a, uint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.add(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(uint16 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.add(euint16.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint16 a, uint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(uint16 a, euint16 b) internal pure returns (euint16) {\n        euint16 aEnc = asEuint16(a);\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.sub(euint16.unwrap(aEnc), euint16.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint16 a, uint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(uint16 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.mul(euint16.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate div(a, b) and return the result.\n    function div(euint16 a, uint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.div(euint16.unwrap(a), uint256(b)));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint16 a, uint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.shl(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(uint16 a, euint16 b) internal pure returns (euint16) {\n        euint16 aEnc = asEuint16(a);\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.shl(euint16.unwrap(aEnc), euint16.unwrap(b), false));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint16 a, uint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.shr(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(uint16 a, euint16 b) internal pure returns (euint16) {\n        euint16 aEnc = asEuint16(a);\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.shr(euint16.unwrap(aEnc), euint16.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint16 a, uint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.eq(euint16.unwrap(a), uint256(b), true), Common.ebool_t));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(uint16 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.eq(euint16.unwrap(b), uint256(a), true), Common.ebool_t));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint16 a, uint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ne(euint16.unwrap(a), uint256(b), true), Common.ebool_t));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(uint16 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ne(euint16.unwrap(b), uint256(a), true), Common.ebool_t));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint16 a, uint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ge(euint16.unwrap(a), uint256(b), true), Common.ebool_t));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(uint16 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.le(euint16.unwrap(b), uint256(a), true), Common.ebool_t));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint16 a, uint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.gt(euint16.unwrap(a), uint256(b), true), Common.ebool_t));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(uint16 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.lt(euint16.unwrap(b), uint256(a), true), Common.ebool_t));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint16 a, uint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.le(euint16.unwrap(a), uint256(b), true), Common.ebool_t));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(uint16 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ge(euint16.unwrap(b), uint256(a), true), Common.ebool_t));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint16 a, uint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.lt(euint16.unwrap(a), uint256(b), true), Common.ebool_t));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(uint16 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.gt(euint16.unwrap(b), uint256(a), true), Common.ebool_t));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint16 a, uint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.min(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(uint16 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.min(euint16.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint16 a, uint16 b) internal pure returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.max(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(uint16 a, euint16 b) internal pure returns (euint16) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.max(euint16.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint32 a, euint8 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint32 a, euint8 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint32 a, euint8 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint32 a, euint8 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(asEuint32(b))));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint32 a, euint8 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(asEuint32(b))));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint32 a, euint8 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(asEuint32(b))));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint32 a, euint8 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.shl(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint32 a, euint8 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.shr(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint32 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.eq(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false), Common.ebool_t));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint32 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ne(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false), Common.ebool_t));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint32 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ge(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false), Common.ebool_t));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint32 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.gt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false), Common.ebool_t));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint32 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.le(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false), Common.ebool_t));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint32 a, euint8 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.lt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false), Common.ebool_t));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint32 a, euint8 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint32 a, euint8 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint32 a, euint16 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint32 a, euint16 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint32 a, euint16 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint32 a, euint16 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(asEuint32(b))));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint32 a, euint16 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(asEuint32(b))));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint32 a, euint16 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(asEuint32(b))));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint32 a, euint16 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.shl(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint32 a, euint16 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.shr(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint32 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.eq(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false), Common.ebool_t));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint32 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ne(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false), Common.ebool_t));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint32 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ge(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false), Common.ebool_t));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint32 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.gt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false), Common.ebool_t));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint32 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.le(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false), Common.ebool_t));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint32 a, euint16 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.lt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false), Common.ebool_t));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint32 a, euint16 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint32 a, euint16 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint32 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint32 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint32 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint32 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(b)));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint32 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(b)));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint32 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(b)));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint32 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.shl(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint32 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.shr(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint32 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.eq(euint32.unwrap(a), euint32.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint32 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ne(euint32.unwrap(a), euint32.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint32 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ge(euint32.unwrap(a), euint32.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint32 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.gt(euint32.unwrap(a), euint32.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint32 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.le(euint32.unwrap(a), euint32.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint32 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.lt(euint32.unwrap(a), euint32.unwrap(b), false), Common.ebool_t));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint32 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint32 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint32 a, uint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(uint32 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint32 a, uint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(uint32 a, euint32 b) internal pure returns (euint32) {\n        euint32 aEnc = asEuint32(a);\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(aEnc), euint32.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint32 a, uint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(uint32 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate div(a, b) and return the result.\n    function div(euint32 a, uint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.div(euint32.unwrap(a), uint256(b)));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint32 a, uint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.shl(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(uint32 a, euint32 b) internal pure returns (euint32) {\n        euint32 aEnc = asEuint32(a);\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.shl(euint32.unwrap(aEnc), euint32.unwrap(b), false));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint32 a, uint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.shr(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(uint32 a, euint32 b) internal pure returns (euint32) {\n        euint32 aEnc = asEuint32(a);\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.shr(euint32.unwrap(aEnc), euint32.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint32 a, uint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.eq(euint32.unwrap(a), uint256(b), true), Common.ebool_t));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(uint32 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.eq(euint32.unwrap(b), uint256(a), true), Common.ebool_t));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint32 a, uint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ne(euint32.unwrap(a), uint256(b), true), Common.ebool_t));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(uint32 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ne(euint32.unwrap(b), uint256(a), true), Common.ebool_t));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint32 a, uint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ge(euint32.unwrap(a), uint256(b), true), Common.ebool_t));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(uint32 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.le(euint32.unwrap(b), uint256(a), true), Common.ebool_t));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint32 a, uint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.gt(euint32.unwrap(a), uint256(b), true), Common.ebool_t));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(uint32 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.lt(euint32.unwrap(b), uint256(a), true), Common.ebool_t));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint32 a, uint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.le(euint32.unwrap(a), uint256(b), true), Common.ebool_t));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(uint32 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.ge(euint32.unwrap(b), uint256(a), true), Common.ebool_t));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint32 a, uint32 b) internal pure returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.lt(euint32.unwrap(a), uint256(b), true), Common.ebool_t));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(uint32 a, euint32 b) internal pure returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.cast(Impl.gt(euint32.unwrap(b), uint256(a), true), Common.ebool_t));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint32 a, uint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(uint32 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint32 a, uint32 b) internal pure returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(uint32 a, euint32 b) internal pure returns (euint32) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(b), uint256(a), true));\n    }\n\n    // If 'control''s value is 'true', the result has the same value as 'a'.\n    // If 'control''s value is 'false', the result has the same value as 'b'.\n    function cmux(ebool control, euint8 a, euint8 b) internal pure returns (euint8) {\n        return euint8.wrap(Impl.cmux(ebool.unwrap(control), euint8.unwrap(a), euint8.unwrap(b)));\n    }\n\n    // If 'control's value is 'true', the result has the same value as 'a'.\n    // If 'control's value is 'false', the result has the same value as 'b'.\n    function cmux(ebool control, euint16 a, euint16 b) internal pure returns (euint16) {\n        euint16 ctrl = asEuint16(asEuint8(control));\n        return euint16.wrap(Impl.cmux(euint16.unwrap(ctrl), euint16.unwrap(a), euint16.unwrap(b)));\n    }\n\n    // If 'control's value is 'true', the result has the same value as 'a'.\n    // If 'control's value is 'false', the result has the same value as 'b'.\n    function cmux(ebool control, euint32 a, euint32 b) internal pure returns (euint32) {\n        euint32 ctrl = asEuint32(asEuint8(control));\n        return euint32.wrap(Impl.cmux(euint32.unwrap(ctrl), euint32.unwrap(a), euint32.unwrap(b)));\n    }\n\n    // Cast an encrypted integer from euint16 to euint8.\n    function asEuint8(euint16 value) internal pure returns (euint8) {\n        return euint8.wrap(Impl.cast(euint16.unwrap(value), Common.euint8_t));\n    }\n\n    // Cast an encrypted integer from euint32 to euint8.\n    function asEuint8(euint32 value) internal pure returns (euint8) {\n        return euint8.wrap(Impl.cast(euint32.unwrap(value), Common.euint8_t));\n    }\n\n    // Cast an encrypted integer from euint8 to ebool.\n    function asEbool(euint8 value) internal pure returns (ebool) {\n        return ne(value, 0);\n    }\n\n    // Convert a serialized 'ciphertext' to an encrypted boolean.\n    function asEbool(bytes memory ciphertext) internal pure returns (ebool) {\n        return asEbool(asEuint8(ciphertext));\n    }\n\n    // Convert a plaintext boolean to an encrypted boolean.\n    function asEbool(bool value) internal pure returns (ebool) {\n        if (value) {\n            return asEbool(asEuint8(1));\n        } else {\n            return asEbool(asEuint8(0));\n        }\n    }\n\n    // Cast an encrypted integer from euint8 to euint16.\n    function asEuint16(euint8 value) internal pure returns (euint16) {\n        return euint16.wrap(Impl.cast(euint8.unwrap(value), Common.euint16_t));\n    }\n\n    // Cast an encrypted integer from euint32 to euint16.\n    function asEuint16(euint32 value) internal pure returns (euint16) {\n        return euint16.wrap(Impl.cast(euint32.unwrap(value), Common.euint16_t));\n    }\n\n    // Cast an encrypted integer from euint16 to ebool.\n    function asEbool(euint16 value) internal pure returns (ebool) {\n        return ne(value, 0);\n    }\n\n    // Cast an encrypted integer from euint8 to euint32.\n    function asEuint32(euint8 value) internal pure returns (euint32) {\n        return euint32.wrap(Impl.cast(euint8.unwrap(value), Common.euint32_t));\n    }\n\n    // Cast an encrypted integer from euint16 to euint32.\n    function asEuint32(euint16 value) internal pure returns (euint32) {\n        return euint32.wrap(Impl.cast(euint16.unwrap(value), Common.euint32_t));\n    }\n\n    // Cast an encrypted integer from euint32 to ebool.\n    function asEbool(euint32 value) internal pure returns (ebool) {\n        return ne(value, 0);\n    }\n\n    function neg(euint8 value) internal pure returns (euint8) {\n        return euint8.wrap(Impl.neg(euint8.unwrap(value)));\n    }\n\n    function not(euint8 value) internal pure returns (euint8) {\n        return euint8.wrap(Impl.not(euint8.unwrap(value)));\n    }\n\n    function neg(euint16 value) internal pure returns (euint16) {\n        return euint16.wrap(Impl.neg(euint16.unwrap(value)));\n    }\n\n    function not(euint16 value) internal pure returns (euint16) {\n        return euint16.wrap(Impl.not(euint16.unwrap(value)));\n    }\n\n    function neg(euint32 value) internal pure returns (euint32) {\n        return euint32.wrap(Impl.neg(euint32.unwrap(value)));\n    }\n\n    function not(euint32 value) internal pure returns (euint32) {\n        return euint32.wrap(Impl.not(euint32.unwrap(value)));\n    }\n\n    // Convert a serialized 'ciphertext' to an encrypted euint8 integer.\n    function asEuint8(bytes memory ciphertext) internal pure returns (euint8) {\n        return euint8.wrap(Impl.verify(ciphertext, Common.euint8_t));\n    }\n\n    // Convert a plaintext value to an encrypted euint8 integer.\n    function asEuint8(uint256 value) internal pure returns (euint8) {\n        return euint8.wrap(Impl.trivialEncrypt(value, Common.euint8_t));\n    }\n\n    // Reencrypt the given 'value' under the given 'publicKey'.\n    // Return a serialized euint8 ciphertext.\n    function reencrypt(euint8 value, bytes32 publicKey) internal view returns (bytes memory reencrypted) {\n        return Impl.reencrypt(euint8.unwrap(value), publicKey);\n    }\n\n    // Reencrypt the given 'value' under the given 'publicKey'.\n    // If 'value' is not initialized, the returned value will contain the 'defaultValue' constant.\n    // Return a serialized euint8 ciphertext.\n    function reencrypt(\n        euint8 value,\n        bytes32 publicKey,\n        uint8 defaultValue\n    ) internal view returns (bytes memory reencrypted) {\n        if (euint8.unwrap(value) != 0) {\n            return Impl.reencrypt(euint8.unwrap(value), publicKey);\n        } else {\n            return Impl.reencrypt(euint8.unwrap(asEuint8(defaultValue)), publicKey);\n        }\n    }\n\n    // Decrypts the encrypted 'value'.\n    function decrypt(euint8 value) internal view returns (uint8) {\n        return uint8(Impl.decrypt(euint8.unwrap(value)));\n    }\n\n    // Convert a serialized 'ciphertext' to an encrypted euint16 integer.\n    function asEuint16(bytes memory ciphertext) internal pure returns (euint16) {\n        return euint16.wrap(Impl.verify(ciphertext, Common.euint16_t));\n    }\n\n    // Convert a plaintext value to an encrypted euint16 integer.\n    function asEuint16(uint256 value) internal pure returns (euint16) {\n        return euint16.wrap(Impl.trivialEncrypt(value, Common.euint16_t));\n    }\n\n    // Reencrypt the given 'value' under the given 'publicKey'.\n    // Return a serialized euint16 ciphertext.\n    function reencrypt(euint16 value, bytes32 publicKey) internal view returns (bytes memory reencrypted) {\n        return Impl.reencrypt(euint16.unwrap(value), publicKey);\n    }\n\n    // Reencrypt the given 'value' under the given 'publicKey'.\n    // If 'value' is not initialized, the returned value will contain the 'defaultValue' constant.\n    // Return a serialized euint16 ciphertext.\n    function reencrypt(\n        euint16 value,\n        bytes32 publicKey,\n        uint16 defaultValue\n    ) internal view returns (bytes memory reencrypted) {\n        if (euint16.unwrap(value) != 0) {\n            return Impl.reencrypt(euint16.unwrap(value), publicKey);\n        } else {\n            return Impl.reencrypt(euint16.unwrap(asEuint16(defaultValue)), publicKey);\n        }\n    }\n\n    // Decrypts the encrypted 'value'.\n    function decrypt(euint16 value) internal view returns (uint16) {\n        return uint16(Impl.decrypt(euint16.unwrap(value)));\n    }\n\n    // Convert a serialized 'ciphertext' to an encrypted euint32 integer.\n    function asEuint32(bytes memory ciphertext) internal pure returns (euint32) {\n        return euint32.wrap(Impl.verify(ciphertext, Common.euint32_t));\n    }\n\n    // Convert a plaintext value to an encrypted euint32 integer.\n    function asEuint32(uint256 value) internal pure returns (euint32) {\n        return euint32.wrap(Impl.trivialEncrypt(value, Common.euint32_t));\n    }\n\n    // Reencrypt the given 'value' under the given 'publicKey'.\n    // Return a serialized euint32 ciphertext.\n    function reencrypt(euint32 value, bytes32 publicKey) internal view returns (bytes memory reencrypted) {\n        return Impl.reencrypt(euint32.unwrap(value), publicKey);\n    }\n\n    // Reencrypt the given 'value' under the given 'publicKey'.\n    // If 'value' is not initialized, the returned value will contain the 'defaultValue' constant.\n    // Return a serialized euint32 ciphertext.\n    function reencrypt(\n        euint32 value,\n        bytes32 publicKey,\n        uint32 defaultValue\n    ) internal view returns (bytes memory reencrypted) {\n        if (euint32.unwrap(value) != 0) {\n            return Impl.reencrypt(euint32.unwrap(value), publicKey);\n        } else {\n            return Impl.reencrypt(euint32.unwrap(asEuint32(defaultValue)), publicKey);\n        }\n    }\n\n    // Decrypts the encrypted 'value'.\n    function decrypt(euint32 value) internal view returns (uint32) {\n        return uint32(Impl.decrypt(euint32.unwrap(value)));\n    }\n\n    // Optimistically require that 'b' is true.\n    //\n    // This function does not evaluate 'b' at the time of the call.\n    // Instead, it accumulates all optimistic requires and evaluates a single combined\n    // require at the end of the transaction. A side effect of this mechanism\n    // is that a method call with a failed optimistic require will always incur the full\n    // gas cost, as if all optimistic requires were true. Yet, the transaction will be\n    // reverted at the end if any of the optimisic requires were false.\n    //\n    // Exceptions to above rule are reencryptions and decryptions via\n    // TFHE.reencrypt() and TFHE.decrypt(), respectively. If either of them\n    // are encountered and if optimistic requires have been used before in the\n    // txn, the optimisic requires will be immediately evaluated. Rationale is\n    // that we want to avoid decrypting or reencrypting a value if the txn is about\n    // to fail and be reverted anyway at the end. Checking immediately and reverting on the spot\n    // would avoid unnecessary decryptions.\n    //\n    // The benefit of optimistic requires is that they are faster than non-optimistic ones,\n    // because there is a single call to the decryption oracle per transaction, irrespective\n    // of how many optimistic requires were used.\n    function optReq(ebool b) internal view {\n        Impl.optReq(ebool.unwrap(b));\n    }\n\n    // Decrypts the encrypted 'value'.\n    function decrypt(ebool value) internal view returns (bool) {\n        return (Impl.decrypt(ebool.unwrap(value)) != 0);\n    }\n\n    // Converts an 'ebool' to an 'euint8'.\n    function asEuint8(ebool b) internal pure returns (euint8) {\n        return euint8.wrap(ebool.unwrap(b));\n    }\n\n    // Reencrypt the given 'value' under the given 'publicKey'.\n    // Return a serialized euint8 value.\n    function reencrypt(ebool value, bytes32 publicKey) internal view returns (bytes memory reencrypted) {\n        return Impl.reencrypt(ebool.unwrap(value), publicKey);\n    }\n\n    // Reencrypt the given 'value' under the given 'publicKey'.\n    // Return a serialized euint8 value.\n    // If 'value' is not initialized, the returned value will contain the 'defaultValue' constant.\n    function reencrypt(\n        ebool value,\n        bytes32 publicKey,\n        bool defaultValue\n    ) internal view returns (bytes memory reencrypted) {\n        if (ebool.unwrap(value) != 0) {\n            return Impl.reencrypt(ebool.unwrap(value), publicKey);\n        } else {\n            return Impl.reencrypt(ebool.unwrap(asEbool(defaultValue)), publicKey);\n        }\n    }\n\n    // Returns the network public FHE key.\n    function fhePubKey() internal view returns (bytes memory) {\n        return Impl.fhePubKey();\n    }\n\n    // Generates a random encrypted 8-bit unsigned integer.\n    // Important: The random integer is generated in the plain! An FHE-based version is coming soon.\n    function randEuint8() internal view returns (euint8) {\n        return euint8.wrap(Impl.rand(Common.euint8_t));\n    }\n\n    // Generates a random encrypted 16-bit unsigned integer.\n    // Important: The random integer is generated in the plain! An FHE-based version is coming soon.\n    function randEuint16() internal view returns (euint16) {\n        return euint16.wrap(Impl.rand(Common.euint16_t));\n    }\n\n    // Generates a random encrypted 32-bit unsigned integer.\n    // Important: The random integer is generated in the plain! An FHE-based version is coming soon.\n    function randEuint32() internal view returns (euint32) {\n        return euint32.wrap(Impl.rand(Common.euint32_t));\n    }\n}\n\nusing {tfheBinaryOperatorAdd8 as +} for euint8 global;\n\nfunction tfheBinaryOperatorAdd8(euint8 lhs, euint8 rhs) pure returns (euint8) {\n    return TFHE.add(lhs, rhs);\n}\n\nusing {tfheBinaryOperatorSub8 as -} for euint8 global;\n\nfunction tfheBinaryOperatorSub8(euint8 lhs, euint8 rhs) pure returns (euint8) {\n    return TFHE.sub(lhs, rhs);\n}\n\nusing {tfheBinaryOperatorMul8 as *} for euint8 global;\n\nfunction tfheBinaryOperatorMul8(euint8 lhs, euint8 rhs) pure returns (euint8) {\n    return TFHE.mul(lhs, rhs);\n}\n\nusing {tfheBinaryOperatorAnd8 as &} for euint8 global;\n\nfunction tfheBinaryOperatorAnd8(euint8 lhs, euint8 rhs) pure returns (euint8) {\n    return TFHE.and(lhs, rhs);\n}\n\nusing {tfheBinaryOperatorOr8 as |} for euint8 global;\n\nfunction tfheBinaryOperatorOr8(euint8 lhs, euint8 rhs) pure returns (euint8) {\n    return TFHE.or(lhs, rhs);\n}\n\nusing {tfheBinaryOperatorXor8 as ^} for euint8 global;\n\nfunction tfheBinaryOperatorXor8(euint8 lhs, euint8 rhs) pure returns (euint8) {\n    return TFHE.xor(lhs, rhs);\n}\n\nusing {tfheUnaryOperatorNeg8 as -} for euint8 global;\n\nfunction tfheUnaryOperatorNeg8(euint8 input) pure returns (euint8) {\n    return TFHE.neg(input);\n}\n\nusing {tfheUnaryOperatorNot8 as ~} for euint8 global;\n\nfunction tfheUnaryOperatorNot8(euint8 input) pure returns (euint8) {\n    return TFHE.not(input);\n}\n\nusing {tfheBinaryOperatorAdd16 as +} for euint16 global;\n\nfunction tfheBinaryOperatorAdd16(euint16 lhs, euint16 rhs) pure returns (euint16) {\n    return TFHE.add(lhs, rhs);\n}\n\nusing {tfheBinaryOperatorSub16 as -} for euint16 global;\n\nfunction tfheBinaryOperatorSub16(euint16 lhs, euint16 rhs) pure returns (euint16) {\n    return TFHE.sub(lhs, rhs);\n}\n\nusing {tfheBinaryOperatorMul16 as *} for euint16 global;\n\nfunction tfheBinaryOperatorMul16(euint16 lhs, euint16 rhs) pure returns (euint16) {\n    return TFHE.mul(lhs, rhs);\n}\n\nusing {tfheBinaryOperatorAnd16 as &} for euint16 global;\n\nfunction tfheBinaryOperatorAnd16(euint16 lhs, euint16 rhs) pure returns (euint16) {\n    return TFHE.and(lhs, rhs);\n}\n\nusing {tfheBinaryOperatorOr16 as |} for euint16 global;\n\nfunction tfheBinaryOperatorOr16(euint16 lhs, euint16 rhs) pure returns (euint16) {\n    return TFHE.or(lhs, rhs);\n}\n\nusing {tfheBinaryOperatorXor16 as ^} for euint16 global;\n\nfunction tfheBinaryOperatorXor16(euint16 lhs, euint16 rhs) pure returns (euint16) {\n    return TFHE.xor(lhs, rhs);\n}\n\nusing {tfheUnaryOperatorNeg16 as -} for euint16 global;\n\nfunction tfheUnaryOperatorNeg16(euint16 input) pure returns (euint16) {\n    return TFHE.neg(input);\n}\n\nusing {tfheUnaryOperatorNot16 as ~} for euint16 global;\n\nfunction tfheUnaryOperatorNot16(euint16 input) pure returns (euint16) {\n    return TFHE.not(input);\n}\n\nusing {tfheBinaryOperatorAdd32 as +} for euint32 global;\n\nfunction tfheBinaryOperatorAdd32(euint32 lhs, euint32 rhs) pure returns (euint32) {\n    return TFHE.add(lhs, rhs);\n}\n\nusing {tfheBinaryOperatorSub32 as -} for euint32 global;\n\nfunction tfheBinaryOperatorSub32(euint32 lhs, euint32 rhs) pure returns (euint32) {\n    return TFHE.sub(lhs, rhs);\n}\n\nusing {tfheBinaryOperatorMul32 as *} for euint32 global;\n\nfunction tfheBinaryOperatorMul32(euint32 lhs, euint32 rhs) pure returns (euint32) {\n    return TFHE.mul(lhs, rhs);\n}\n\nusing {tfheBinaryOperatorAnd32 as &} for euint32 global;\n\nfunction tfheBinaryOperatorAnd32(euint32 lhs, euint32 rhs) pure returns (euint32) {\n    return TFHE.and(lhs, rhs);\n}\n\nusing {tfheBinaryOperatorOr32 as |} for euint32 global;\n\nfunction tfheBinaryOperatorOr32(euint32 lhs, euint32 rhs) pure returns (euint32) {\n    return TFHE.or(lhs, rhs);\n}\n\nusing {tfheBinaryOperatorXor32 as ^} for euint32 global;\n\nfunction tfheBinaryOperatorXor32(euint32 lhs, euint32 rhs) pure returns (euint32) {\n    return TFHE.xor(lhs, rhs);\n}\n\nusing {tfheUnaryOperatorNeg32 as -} for euint32 global;\n\nfunction tfheUnaryOperatorNeg32(euint32 input) pure returns (euint32) {\n    return TFHE.neg(input);\n}\n\nusing {tfheUnaryOperatorNot32 as ~} for euint32 global;\n\nfunction tfheUnaryOperatorNot32(euint32 input) pure returns (euint32) {\n    return TFHE.not(input);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}